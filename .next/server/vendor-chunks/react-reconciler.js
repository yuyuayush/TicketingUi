"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRywrQkFBK0I7QUFDbEMsR0FBRyw0QkFBNEI7QUFDL0IsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyx1QkFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0XFxDb25jZXJ0IFRpY2tldGluZ1xcVGlja2V0aW5nVWlcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcY2pzXFxyZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKChleHBvcnRzLkNvbmN1cnJlbnRSb290ID0gMSksXG4gIChleHBvcnRzLkNvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gOCksXG4gIChleHBvcnRzLkRlZmF1bHRFdmVudFByaW9yaXR5ID0gMzIpLFxuICAoZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSAyKSxcbiAgKGV4cG9ydHMuSWRsZUV2ZW50UHJpb3JpdHkgPSAyNjg0MzU0NTYpLFxuICAoZXhwb3J0cy5MZWdhY3lSb290ID0gMCksXG4gIChleHBvcnRzLk5vRXZlbnRQcmlvcml0eSA9IDApKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPendingEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n            case REACT_ACTIVITY_TYPE:\n                return \"Activity\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_CONTEXT_TYPE:\n                return type.displayName || \"Context\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 31:\n                return \"Activity\";\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return type.displayName || \"Context\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n                return 128;\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n                return lanes & 261888;\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 3932160;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes, rootHasPendingCommit) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n        root = root.warmLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n            case 64:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function getBumpedLaneForHydration(root, renderLanes) {\n        var renderLane = renderLanes & -renderLanes;\n        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);\n        return 0 !== (renderLane & (root.suspendedLanes | renderLanes)) ? 0 : renderLane;\n    }\n    function getBumpedLaneForHydrationByLane(lane) {\n        switch(lane){\n            case 2:\n                lane = 1;\n                break;\n            case 8:\n                lane = 4;\n                break;\n            case 32:\n                lane = 16;\n                break;\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                lane = 128;\n                break;\n            case 268435456:\n                lane = 134217728;\n                break;\n            default:\n                lane = 0;\n        }\n        return lane;\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %o.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %o\", err));\n        }\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function getArrayKind(array) {\n        for(var kind = 0, i = 0; i < array.length; i++){\n            var value = array[i];\n            if (\"object\" === typeof value && null !== value) if (isArrayImpl(value) && 2 === value.length && \"string\" === typeof value[0]) {\n                if (0 !== kind && 3 !== kind) return 1;\n                kind = 3;\n            } else return 1;\n            else {\n                if (\"function\" === typeof value || \"string\" === typeof value && 50 < value.length || 0 !== kind && 2 !== kind) return 1;\n                kind = 2;\n            }\n        }\n        return kind;\n    }\n    function addObjectToProperties(object, properties, indent, prefix) {\n        for(var key in object)hasOwnProperty.call(object, key) && \"_\" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix);\n    }\n    function addValueToProperties(propertyName, value, properties, indent, prefix) {\n        switch(typeof value){\n            case \"object\":\n                if (null === value) {\n                    value = \"null\";\n                    break;\n                } else {\n                    if (value.$$typeof === REACT_ELEMENT_TYPE) {\n                        var typeName = getComponentNameFromType(value.type) || \"\\u2026\", key = value.key;\n                        value = value.props;\n                        var propsKeys = Object.keys(value), propsLength = propsKeys.length;\n                        if (null == key && 0 === propsLength) {\n                            value = \"<\" + typeName + \" />\";\n                            break;\n                        }\n                        if (3 > indent || 1 === propsLength && \"children\" === propsKeys[0] && null == key) {\n                            value = \"<\" + typeName + \" \\u2026 />\";\n                            break;\n                        }\n                        properties.push([\n                            prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                            \"<\" + typeName\n                        ]);\n                        null !== key && addValueToProperties(\"key\", key, properties, indent + 1, prefix);\n                        propertyName = !1;\n                        for(var propKey in value)\"children\" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = !0) : hasOwnProperty.call(value, propKey) && \"_\" !== propKey[0] && addValueToProperties(propKey, value[propKey], properties, indent + 1, prefix);\n                        properties.push([\n                            \"\",\n                            propertyName ? \">\\u2026</\" + typeName + \">\" : \"/>\"\n                        ]);\n                        return;\n                    }\n                    typeName = Object.prototype.toString.call(value);\n                    typeName = typeName.slice(8, typeName.length - 1);\n                    if (\"Array\" === typeName) {\n                        if (propKey = getArrayKind(value), 2 === propKey || 0 === propKey) {\n                            value = JSON.stringify(value);\n                            break;\n                        } else if (3 === propKey) {\n                            properties.push([\n                                prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                                \"\"\n                            ]);\n                            for(propertyName = 0; propertyName < value.length; propertyName++)typeName = value[propertyName], addValueToProperties(typeName[0], typeName[1], properties, indent + 1, prefix);\n                            return;\n                        }\n                    }\n                    if (\"Promise\" === typeName) {\n                        if (\"fulfilled\" === value.status) {\n                            if (typeName = properties.length, addValueToProperties(propertyName, value.value, properties, indent, prefix), properties.length > typeName) {\n                                properties = properties[typeName];\n                                properties[1] = \"Promise<\" + (properties[1] || \"Object\") + \">\";\n                                return;\n                            }\n                        } else if (\"rejected\" === value.status && (typeName = properties.length, addValueToProperties(propertyName, value.reason, properties, indent, prefix), properties.length > typeName)) {\n                            properties = properties[typeName];\n                            properties[1] = \"Rejected Promise<\" + properties[1] + \">\";\n                            return;\n                        }\n                        properties.push([\n                            \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                            \"Promise\"\n                        ]);\n                        return;\n                    }\n                    \"Object\" === typeName && (propKey = Object.getPrototypeOf(value)) && \"function\" === typeof propKey.constructor && (typeName = propKey.constructor.name);\n                    properties.push([\n                        prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n                        \"Object\" === typeName ? 3 > indent ? \"\" : \"\\u2026\" : typeName\n                    ]);\n                    3 > indent && addObjectToProperties(value, properties, indent + 1, prefix);\n                    return;\n                }\n            case \"function\":\n                value = \"\" === value.name ? \"() => {}\" : value.name + \"() {}\";\n                break;\n            case \"string\":\n                value = \"This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.\" === value ? \"\\u2026\" : JSON.stringify(value);\n                break;\n            case \"undefined\":\n                value = \"undefined\";\n                break;\n            case \"boolean\":\n                value = value ? \"true\" : \"false\";\n                break;\n            default:\n                value = String(value);\n        }\n        properties.push([\n            prefix + \"\\u00a0\\u00a0\".repeat(indent) + propertyName,\n            value\n        ]);\n    }\n    function addObjectDiffToProperties(prev, next, properties, indent) {\n        var isDeeplyEqual = !0;\n        for(key in prev)key in next || (properties.push([\n            \"\\u2013\\u00a0\" + \"\\u00a0\\u00a0\".repeat(indent) + key,\n            \"\\u2026\"\n        ]), isDeeplyEqual = !1);\n        for(var _key in next)if (_key in prev) {\n            var key = prev[_key];\n            var nextValue = next[_key];\n            if (key !== nextValue) {\n                if (0 === indent && \"children\" === _key) isDeeplyEqual = \"\\u00a0\\u00a0\".repeat(indent) + _key, properties.push([\n                    \"\\u2013\\u00a0\" + isDeeplyEqual,\n                    \"\\u2026\"\n                ], [\n                    \"+\\u00a0\" + isDeeplyEqual,\n                    \"\\u2026\"\n                ]);\n                else {\n                    if (!(3 <= indent)) {\n                        if (\"object\" === typeof key && \"object\" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof) if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {\n                            if (key.type === nextValue.type && key.key === nextValue.key) {\n                                key = getComponentNameFromType(nextValue.type) || \"\\u2026\";\n                                isDeeplyEqual = \"\\u00a0\\u00a0\".repeat(indent) + _key;\n                                key = \"<\" + key + \" \\u2026 />\";\n                                properties.push([\n                                    \"\\u2013\\u00a0\" + isDeeplyEqual,\n                                    key\n                                ], [\n                                    \"+\\u00a0\" + isDeeplyEqual,\n                                    key\n                                ]);\n                                isDeeplyEqual = !1;\n                                continue;\n                            }\n                        } else {\n                            var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);\n                            if (prevKind === nextKind && (\"[object Object]\" === nextKind || \"[object Array]\" === nextKind)) {\n                                prevKind = [\n                                    \"\\u2007\\u00a0\" + \"\\u00a0\\u00a0\".repeat(indent) + _key,\n                                    \"[object Array]\" === nextKind ? \"Array\" : \"\"\n                                ];\n                                properties.push(prevKind);\n                                nextKind = properties.length;\n                                addObjectDiffToProperties(key, nextValue, properties, indent + 1) ? nextKind === properties.length && (prevKind[1] = \"Referentially unequal but deeply equal objects. Consider memoization.\") : isDeeplyEqual = !1;\n                                continue;\n                            }\n                        }\n                        else if (\"function\" === typeof key && \"function\" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {\n                            key = \"\" === nextValue.name ? \"() => {}\" : nextValue.name + \"() {}\";\n                            properties.push([\n                                \"\\u2007\\u00a0\" + \"\\u00a0\\u00a0\".repeat(indent) + _key,\n                                key + \" Referentially unequal function closure. Consider memoization.\"\n                            ]);\n                            continue;\n                        }\n                    }\n                    addValueToProperties(_key, key, properties, indent, \"\\u2013\\u00a0\");\n                    addValueToProperties(_key, nextValue, properties, indent, \"+\\u00a0\");\n                }\n                isDeeplyEqual = !1;\n            }\n        } else properties.push([\n            \"+\\u00a0\" + \"\\u00a0\\u00a0\".repeat(indent) + _key,\n            \"\\u2026\"\n        ]), isDeeplyEqual = !1;\n        return isDeeplyEqual;\n    }\n    function setCurrentTrackFromLanes(lanes) {\n        currentTrack = lanes & 63 ? \"Blocking\" : lanes & 64 ? \"Gesture\" : lanes & 4194176 ? \"Transition\" : lanes & 62914560 ? \"Suspense\" : lanes & 2080374784 ? \"Idle\" : \"Other\";\n    }\n    function logComponentTrigger(fiber, startTime, endTime, trigger) {\n        supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = \"warning\", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, trigger, reusableComponentOptions)) : performance.measure(trigger, reusableComponentOptions));\n    }\n    function logComponentReappeared(fiber, startTime, endTime) {\n        logComponentTrigger(fiber, startTime, endTime, \"Reconnect\");\n    }\n    function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {\n        var name = getComponentNameFromFiber(fiber);\n        if (null !== name && supportsUserTiming) {\n            var alternate = fiber.alternate, selfTime = fiber.actualDuration;\n            if (null === alternate || alternate.child !== fiber.child) for(var child = fiber.child; null !== child; child = child.sibling)selfTime -= child.actualDuration;\n            wasHydrated = 0.5 > selfTime ? wasHydrated ? \"tertiary-light\" : \"primary-light\" : 10 > selfTime ? wasHydrated ? \"tertiary\" : \"primary\" : 100 > selfTime ? wasHydrated ? \"tertiary-dark\" : \"primary-dark\" : \"error\";\n            var props = fiber.memoizedProps;\n            selfTime = fiber._debugTask;\n            null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [\n                resuableChangedPropsEntry\n            ], props = addObjectDiffToProperties(alternate.memoizedProps, props, child, 0), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = !0, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = \"warning\", reusableComponentDevToolDetails.tooltipText = \"This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.\") : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(performance.measure.bind(performance, \"\\u200b\" + name, reusableComponentOptions)) : performance.measure(\"\\u200b\" + name, reusableComponentOptions))) : null != selfTime ? selfTime.run(console.timeStamp.bind(console, name, startTime, endTime, \"Components \\u269b\", void 0, wasHydrated)) : console.timeStamp(name, startTime, endTime, \"Components \\u269b\", void 0, wasHydrated);\n        }\n    }\n    function logComponentErrored(fiber, startTime, endTime, errors) {\n        if (supportsUserTiming) {\n            var name = getComponentNameFromFiber(fiber);\n            if (null !== name) {\n                for(var debugTask = null, properties = [], i = 0; i < errors.length; i++){\n                    var capturedValue = errors[i];\n                    null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);\n                    capturedValue = capturedValue.value;\n                    properties.push([\n                        \"Error\",\n                        \"object\" === typeof capturedValue && null !== capturedValue && \"string\" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)\n                    ]);\n                }\n                null !== fiber.key && addValueToProperties(\"key\", fiber.key, properties, 0, \"\");\n                null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, \"\");\n                null == debugTask && (debugTask = fiber._debugTask);\n                fiber = {\n                    start: startTime,\n                    end: endTime,\n                    detail: {\n                        devtools: {\n                            color: \"error\",\n                            track: \"Components \\u269b\",\n                            tooltipText: 13 === fiber.tag ? \"Hydration failed\" : \"Error boundary caught an error\",\n                            properties: properties\n                        }\n                    }\n                };\n                debugTask ? debugTask.run(performance.measure.bind(performance, \"\\u200b\" + name, fiber)) : performance.measure(\"\\u200b\" + name, fiber);\n            }\n        }\n    }\n    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {\n        if (null !== errors) {\n            if (supportsUserTiming) {\n                var name = getComponentNameFromFiber(fiber);\n                if (null !== name) {\n                    selfTime = [];\n                    for(var i = 0; i < errors.length; i++){\n                        var error = errors[i].value;\n                        selfTime.push([\n                            \"Error\",\n                            \"object\" === typeof error && null !== error && \"string\" === typeof error.message ? String(error.message) : String(error)\n                        ]);\n                    }\n                    null !== fiber.key && addValueToProperties(\"key\", fiber.key, selfTime, 0, \"\");\n                    null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, \"\");\n                    startTime = {\n                        start: startTime,\n                        end: endTime,\n                        detail: {\n                            devtools: {\n                                color: \"error\",\n                                track: \"Components \\u269b\",\n                                tooltipText: \"A lifecycle or effect errored\",\n                                properties: selfTime\n                            }\n                        }\n                    };\n                    (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, \"\\u200b\" + name, startTime)) : performance.measure(\"\\u200b\" + name, startTime);\n                }\n            }\n        } else name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? \"secondary-light\" : 100 > selfTime ? \"secondary\" : 500 > selfTime ? \"secondary-dark\" : \"error\", (fiber = fiber._debugTask) ? fiber.run(console.timeStamp.bind(console, name, startTime, endTime, \"Components \\u269b\", void 0, errors)) : console.timeStamp(name, startTime, endTime, \"Components \\u269b\", void 0, errors));\n    }\n    function logRenderPhase(startTime, endTime, lanes, debugTask) {\n        if (supportsUserTiming && !(endTime <= startTime)) {\n            var color = (lanes & 738197653) === lanes ? \"tertiary-dark\" : \"primary-dark\";\n            lanes = (lanes & 536870912) === lanes ? \"Prepared\" : (lanes & 201326741) === lanes ? \"Hydrated\" : \"Render\";\n            debugTask ? debugTask.run(console.timeStamp.bind(console, lanes, startTime, endTime, currentTrack, \"Scheduler \\u269b\", color)) : console.timeStamp(lanes, startTime, endTime, currentTrack, \"Scheduler \\u269b\", color);\n        }\n    }\n    function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {\n        !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? \"tertiary-dark\" : \"primary-dark\", debugTask ? debugTask.run(console.timeStamp.bind(console, \"Prewarm\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", lanes)) : console.timeStamp(\"Prewarm\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", lanes));\n    }\n    function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {\n        !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? \"tertiary-dark\" : \"primary-dark\", debugTask ? debugTask.run(console.timeStamp.bind(console, \"Suspended\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", lanes)) : console.timeStamp(\"Suspended\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", lanes));\n    }\n    function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {\n        if (supportsUserTiming && !(endTime <= startTime)) {\n            lanes = [];\n            for(var i = 0; i < recoverableErrors.length; i++){\n                var error = recoverableErrors[i].value;\n                lanes.push([\n                    \"Recoverable Error\",\n                    \"object\" === typeof error && null !== error && \"string\" === typeof error.message ? String(error.message) : String(error)\n                ]);\n            }\n            startTime = {\n                start: startTime,\n                end: endTime,\n                detail: {\n                    devtools: {\n                        color: \"primary-dark\",\n                        track: currentTrack,\n                        trackGroup: \"Scheduler \\u269b\",\n                        tooltipText: hydrationFailed ? \"Hydration Failed\" : \"Recovered after Error\",\n                        properties: lanes\n                    }\n                }\n            };\n            debugTask ? debugTask.run(performance.measure.bind(performance, \"Recovered\", startTime)) : performance.measure(\"Recovered\", startTime);\n        }\n    }\n    function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {\n        !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, \"Errored\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"error\")) : console.timeStamp(\"Errored\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"error\"));\n    }\n    function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {\n        !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, reason, startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-light\")) : console.timeStamp(reason, startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-light\"));\n    }\n    function logCommitErrored(startTime, endTime, errors, passive, debugTask) {\n        if (supportsUserTiming && !(endTime <= startTime)) {\n            for(var properties = [], i = 0; i < errors.length; i++){\n                var error = errors[i].value;\n                properties.push([\n                    \"Error\",\n                    \"object\" === typeof error && null !== error && \"string\" === typeof error.message ? String(error.message) : String(error)\n                ]);\n            }\n            startTime = {\n                start: startTime,\n                end: endTime,\n                detail: {\n                    devtools: {\n                        color: \"error\",\n                        track: currentTrack,\n                        trackGroup: \"Scheduler \\u269b\",\n                        tooltipText: passive ? \"Remaining Effects Errored\" : \"Commit Errored\",\n                        properties: properties\n                    }\n                }\n            };\n            debugTask ? debugTask.run(performance.measure.bind(performance, \"Errored\", startTime)) : performance.measure(\"Errored\", startTime);\n        }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function formatOwnerStack(error) {\n        var prevPrepareStackTrace = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        error = error.stack;\n        Error.prepareStackTrace = prevPrepareStackTrace;\n        error.startsWith(\"Error: react-stack-top-frame\\n\") && (error = error.slice(29));\n        prevPrepareStackTrace = error.indexOf(\"\\n\");\n        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));\n        prevPrepareStackTrace = error.indexOf(\"react_stack_bottom_frame\");\n        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(\"\\n\", prevPrepareStackTrace));\n        if (-1 !== prevPrepareStackTrace) error = error.slice(0, prevPrepareStackTrace);\n        else return \"\";\n        return error;\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber, childFiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame(\"Suspense Fallback\") : describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return describeNativeComponentFrame(fiber.type, !1);\n            case 11:\n                return describeNativeComponentFrame(fiber.type.render, !1);\n            case 1:\n                return describeNativeComponentFrame(fiber.type, !0);\n            case 31:\n                return describeBuiltInComponentFrame(\"Activity\");\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\", previous = null;\n            do {\n                info += describeFiber(workInProgress, previous);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info;\n                        a: {\n                            var name = entry.name, env = entry.env, location = entry.debugLocation;\n                            if (null != location) {\n                                var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf(\"\\n\"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);\n                                if (-1 !== lastLine.indexOf(name)) {\n                                    var JSCompiler_inline_result = \"\\n\" + lastLine;\n                                    break a;\n                                }\n                            }\n                            JSCompiler_inline_result = describeBuiltInComponentFrame(name + (env ? \" [\" + env + \"]\" : \"\"));\n                        }\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                previous = workInProgress;\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function describeFunctionComponentFrameWithoutLineNumber(fn) {\n        return (fn = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(fn) : \"\";\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function getSuspendedTreeContext() {\n        warnIfNotHydrating();\n        return null !== treeContextProvider ? {\n            id: treeContextId,\n            overflow: treeContextOverflow\n        } : null;\n    }\n    function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextId = suspendedContext.id;\n        treeContextOverflow = suspendedContext.overflow;\n        treeContextProvider = workInProgress;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 31:\n                return \"Activity\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        if (null === current) return \"\";\n        var workInProgress = current;\n        try {\n            var info = \"\";\n            6 === workInProgress.tag && (workInProgress = workInProgress.return);\n            switch(workInProgress.tag){\n                case 26:\n                case 27:\n                case 5:\n                    info += describeBuiltInComponentFrame(workInProgress.type);\n                    break;\n                case 13:\n                    info += describeBuiltInComponentFrame(\"Suspense\");\n                    break;\n                case 19:\n                    info += describeBuiltInComponentFrame(\"SuspenseList\");\n                    break;\n                case 31:\n                    info += describeBuiltInComponentFrame(\"Activity\");\n                    break;\n                case 30:\n                case 0:\n                case 15:\n                case 1:\n                    workInProgress._debugOwner || \"\" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress.type));\n                    break;\n                case 11:\n                    workInProgress._debugOwner || \"\" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress.type.render));\n            }\n            for(; workInProgress;)if (\"number\" === typeof workInProgress.tag) {\n                var fiber = workInProgress;\n                workInProgress = fiber._debugOwner;\n                var debugStack = fiber._debugStack;\n                if (workInProgress && debugStack) {\n                    var formattedStack = formatOwnerStack(debugStack);\n                    \"\" !== formattedStack && (info += \"\\n\" + formattedStack);\n                }\n            } else if (null != workInProgress.debugStack) {\n                var ownerStack = workInProgress.debugStack;\n                (workInProgress = workInProgress.owner) && ownerStack && (info += \"\\n\" + formatOwnerStack(ownerStack));\n            } else break;\n            var JSCompiler_inline_result = info;\n        } catch (x) {\n            JSCompiler_inline_result = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n        return JSCompiler_inline_result;\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        setCurrentFiber(fiber);\n        try {\n            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, arg0, arg1, arg2, arg3, arg4)) : callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            setCurrentFiber(previousFiber);\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function setCurrentFiber(fiber) {\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnIfHydrating() {\n        isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : !1, diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered \" + (fromText ? \"text\" : \"HTML\") + \" didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber, !0);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 5:\n            case 31:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            case 27:\n            case 3:\n                rootOrSingletonContext = !0;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var tag = fiber.tag;\n        supportsSingletons ? 3 !== tag && 27 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber)) : 3 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber));\n        popToNextHostParent(fiber);\n        if (13 === tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else if (31 === tag) {\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterActivityInstance(fiber);\n        } else nextHydratableInstance = supportsSingletons && 27 === tag ? getNextHydratableSiblingAfterSingleton(fiber.type, nextHydratableInstance) : hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function warnIfUnhydratedTailNodes(fiber) {\n        for(var nextInstance = nextHydratableInstance; nextInstance;){\n            var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(nextInstance);\n            diffNode.serverTail.push(description);\n            nextInstance = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(nextInstance) : getNextHydratableSibling(nextInstance);\n        }\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function upgradeHydrationErrorsToRecoverable() {\n        var queuedErrors = hydrationErrors;\n        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);\n        return queuedErrors;\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        if (null !== diffRoot) {\n            hydrationDiffRootDEV = null;\n            for(var diff = describeDiff(diffRoot); 0 < diffRoot.children.length;)diffRoot = diffRoot.children[0];\n            runWithFiberInDEV(diffRoot.fiber, function() {\n                console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diff);\n            });\n        }\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber$1 = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber$1 = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber$1, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function startUpdateTimerByLane(lane, method, fiber) {\n        if (0 !== (lane & 127)) 0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), isAlreadyRendering() && (componentEffectSpawnedUpdate = !0, blockingUpdateType = 1), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = 1), blockingEventTime = lane, blockingEventType = method);\n        else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {\n            lane = resolveEventTimeStamp();\n            method = resolveEventType();\n            if (lane !== transitionEventRepeatTime || method !== transitionEventType) transitionEventRepeatTime = -1.1;\n            transitionEventTime = lane;\n            transitionEventType = method;\n        }\n    }\n    function startHostActionTimer(fiber) {\n        if (0 > blockingUpdateTime) {\n            blockingUpdateTime = now();\n            blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;\n            isAlreadyRendering() && (blockingUpdateType = 1);\n            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();\n            newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = 1);\n            blockingEventTime = newEventTime;\n            blockingEventType = newEventType;\n        }\n        if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {\n            fiber = resolveEventTimeStamp();\n            newEventTime = resolveEventType();\n            if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType) transitionEventRepeatTime = -1.1;\n            transitionEventTime = fiber;\n            transitionEventType = newEventTime;\n        }\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function resetComponentEffectTimers() {\n        componentEffectEndTime = componentEffectStartTime = -1.1;\n    }\n    function pushComponentEffectStart() {\n        var prevEffectStart = componentEffectStartTime;\n        componentEffectStartTime = -1.1;\n        return prevEffectStart;\n    }\n    function popComponentEffectStart(prevEffectStart) {\n        0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);\n    }\n    function pushComponentEffectDuration() {\n        var prevEffectDuration = componentEffectDuration;\n        componentEffectDuration = -0;\n        return prevEffectDuration;\n    }\n    function popComponentEffectDuration(prevEffectDuration) {\n        0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);\n    }\n    function pushComponentEffectErrors() {\n        var prevErrors = componentEffectErrors;\n        componentEffectErrors = null;\n        return prevErrors;\n    }\n    function pushComponentEffectDidSpawnUpdate() {\n        var prev = componentEffectSpawnedUpdate;\n        componentEffectSpawnedUpdate = !1;\n        return prev;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var endTime = now(), elapsedTime = endTime - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n            componentEffectDuration += elapsedTime;\n            componentEffectEndTime = endTime;\n        }\n    }\n    function recordEffectError(errorInfo) {\n        null === componentEffectErrors && (componentEffectErrors = []);\n        componentEffectErrors.push(errorInfo);\n        null === commitErrors && (commitErrors = []);\n        commitErrors.push(errorInfo);\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n        0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function noop$1() {}\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateRootScheduleTask());\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInImmediateTask() {\n        trackSchedulerEvent();\n        processRootScheduleInMicrotask();\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        trackSchedulerEvent();\n        if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return root.callbackNode = null, root.callbackPriority = 0, null;\n        var originalCallbackNode = root.callbackNode;\n        pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);\n        if (flushPendingEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPendingEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateRootScheduleTask() {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            processRootScheduleInMicrotask();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();\n        }) : scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask);\n    }\n    function requestTransitionLane() {\n        if (0 === currentEventTransitionLane) {\n            var actionScopeLane = currentEntangledLane;\n            0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));\n            currentEventTransitionLane = actionScopeLane;\n        }\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        if (void 0 === thenable._debugInfo) {\n            thenableState = performance.now();\n            trackedThenables = thenable.displayName;\n            var ioInfo = {\n                name: \"string\" === typeof trackedThenables ? trackedThenables : \"Promise\",\n                start: thenableState,\n                end: thenableState,\n                value: thenable\n            };\n            thenable._debugInfo = [\n                {\n                    awaited: ioInfo\n                }\n            ];\n            \"fulfilled\" !== thenable.status && \"rejected\" !== thenable.status && (thenableState = function() {\n                ioInfo.end = performance.now();\n            }, thenable.then(thenableState, thenableState));\n        }\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function resolveLazy(lazyType) {\n        try {\n            return callLazyInitInDEV(lazyType);\n        } catch (x) {\n            if (null !== x && \"object\" === typeof x && \"function\" === typeof x.then) throw suspendedThenable = x, needsToResetSuspendedThenableDEV = !0, SuspenseException;\n            throw x;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function getCurrentDebugTask() {\n        var debugInfo = currentDebugInfo;\n        if (null != debugInfo) {\n            for(var i = debugInfo.length - 1; 0 <= i; i--)if (null != debugInfo[i].name) {\n                var debugTask = debugInfo[i].debugTask;\n                if (null != debugTask) return debugTask;\n            }\n        }\n        return null;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        var debugTask = getCurrentDebugTask();\n        null !== debugTask ? debugTask.run(throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);\n    }\n    function warnOnFunctionTypeImpl(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var debugTask = getCurrentDebugTask();\n        null !== debugTask ? debugTask.run(warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnFunctionTypeImpl(returnFiber, invalidChild);\n    }\n    function warnOnSymbolTypeImpl(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var debugTask = getCurrentDebugTask();\n        null !== debugTask ? debugTask.run(warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnSymbolTypeImpl(returnFiber, invalidChild);\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 67108866;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugTask = returnFiber._debugTask, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugTask = returnFiber._debugTask, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = resolveLazy(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = resolveLazy(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException || x === SuspenseActionException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                fiber._debugTask = returnFiber._debugTask;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        fiber._debugTask = debugInfo[i].debugTask;\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [\n            update\n        ] : alternate.push(update), update.lane = lane | 536870912), parent) : null;\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushDehydratedActivitySuspenseHandler(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, fiber, fiber);\n        null === shellBoundary && (shellBoundary = fiber);\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && (\"forwards\" === node.memoizedProps.revealOrder || \"backwards\" === node.memoizedProps.revealOrder || \"unstable_legacy-backwards\" === node.memoizedProps.revealOrder || \"together\" === node.memoizedProps.revealOrder)) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\", null === nextRenderLanes ? \"An unknown Component\" : \"<\" + nextRenderLanes + \">\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 65011712) !== (workInProgress.flags & 65011712) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -402655237 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function createFunctionComponentUpdateQueue() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        gesture: null,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        gesture: null,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    gesture: update.gesture,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushSimpleEffect(HasEffect | Passive, {\n            destroy: void 0\n        }, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushSimpleEffect(HasEffect | Passive, {\n                destroy: void 0\n            }, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, \"updateSyncExternalStore()\", fiber), forceStoreRerender(fiber));\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            currentTransition._updatedFibers = new Set();\n            ReactSharedInternals.T = currentTransition;\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(\"We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React.\"), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        if (\"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then) try {\n            var state = useThenable(currentStateHook);\n        } catch (x) {\n            if (x === SuspenseException) throw SuspenseActionException;\n            throw x;\n        }\n        else state = currentStateHook;\n        currentStateHook = updateWorkInProgressHook();\n        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;\n        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, {\n            destroy: void 0\n        }, actionStateActionEffect.bind(null, actionQueue, action), null));\n        return [\n            state,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushSimpleEffect(tag, inst, create, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            deps: deps,\n            inst: inst,\n            next: null\n        };\n        inst = currentlyRenderingFiber.updateQueue;\n        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);\n        create = inst.lastEffect;\n        null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber.flags |= fiberFlags;\n        hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, {\n            destroy: void 0\n        }, create, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber.mode & 16) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function useEffectEventImpl(payload) {\n        currentlyRenderingFiber.flags |= 4;\n        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n        if (null === componentUpdateQueue) componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [\n            payload\n        ];\n        else {\n            var events = componentUpdateQueue.events;\n            null === events ? componentUpdateQueue.events = [\n                payload\n            ] : events.push(payload);\n        }\n    }\n    function mountEvent(callback) {\n        var hook = mountWorkInProgressHook(), ref = {\n            impl: callback\n        };\n        hook.memoizedState = ref;\n        return function() {\n            if ((executionContext & RenderContext) !== NoContext) throw Error(\"A function wrapped in useEffectEvent can't be called during rendering.\");\n            return ref.impl.apply(void 0, arguments);\n        };\n    }\n    function updateEvent(callback) {\n        var ref = updateWorkInProgressHook().memoizedState;\n        useEffectEventImpl({\n            ref: ref,\n            nextImpl: callback\n        });\n        return function() {\n            if ((executionContext & RenderContext) !== NoContext) throw Error(\"A function wrapped in useEffectEvent can't be called during rendering.\");\n            return ref.impl.apply(void 0, arguments);\n        };\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function releaseAsyncTransition() {\n        ReactSharedInternals.asyncTransitions--;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        currentTransition._updatedFibers = new Set();\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                ReactSharedInternals.asyncTransitions++;\n                returnValue.then(releaseAsyncTransition, releaseAsyncTransition);\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(\"We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React.\"), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \"_\" + identifierPrefix + \"R_\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \"_\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \"_\" + identifierPrefix + \"r_\" + treeId.toString(32) + \"_\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root = enqueueUpdate(provider, refreshUpdate, lane);\n                    null !== root && (startUpdateTimerByLane(lane, \"refresh()\", fiber), scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    fiber = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    refreshUpdate.payload = {\n                        cache: fiber\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action) {\n        var args = arguments;\n        \"function\" === typeof args[3] && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        args = requestUpdateLane(fiber);\n        var update = {\n            lane: args,\n            revertLane: 0,\n            gesture: null,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, \"dispatch()\", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));\n    }\n    function dispatchSetState(fiber, queue, action) {\n        var args = arguments;\n        \"function\" === typeof args[3] && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        args = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, \"setState()\", fiber);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            gesture: null,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            gesture: null,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && (startUpdateTimerByLane(2, \"setOptimistic()\", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194048)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 31:\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes, nextProps) {\n        var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;\n        null === current && null === workInProgress.stateNode && (workInProgress.stateNode = {\n            _visibility: OffscreenVisible,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null\n        });\n        if (\"hidden\" === nextProps.mode) {\n            if (0 !== (workInProgress.flags & 128)) {\n                prevState = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextProps = workInProgress.child = current.child;\n                    for(nextChildren = 0; null !== nextProps;)nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;\n                    nextProps = nextChildren & ~prevState;\n                } else nextProps = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, prevState, renderLanes, nextProps);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return nextProps = workInProgress.lanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes, nextProps);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function bailoutOffscreenComponent(current, workInProgress) {\n        null !== current && 22 === current.tag || null !== workInProgress.stateNode || (workInProgress.stateNode = {\n            _visibility: OffscreenVisible,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null\n        });\n        return workInProgress.sibling;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes, remainingChildLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        workInProgress.childLanes = remainingChildLanes;\n        return null;\n    }\n    function mountActivityChildren(workInProgress, nextProps) {\n        var hiddenProp = nextProps.hidden;\n        void 0 !== hiddenProp && console.error('<Activity> doesn\\'t accept a hidden prop. Use mode=\"hidden\" instead.\\n- <Activity %s>\\n+ <Activity %s>', !0 === hiddenProp ? \"hidden\" : !1 === hiddenProp ? \"hidden={false}\" : \"hidden={...}\", hiddenProp ? 'mode=\"hidden\"' : 'mode=\"visible\"');\n        nextProps = mountWorkInProgressOffscreenFiber({\n            mode: nextProps.mode,\n            children: nextProps.children\n        }, workInProgress.mode);\n        nextProps.ref = workInProgress.ref;\n        workInProgress.child = nextProps;\n        nextProps.return = workInProgress;\n        return nextProps;\n    }\n    function retryActivityComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountActivityChildren(workInProgress, workInProgress.pendingProps);\n        current.flags |= 2;\n        popSuspenseHandler(workInProgress);\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function updateActivityComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, didSuspend = 0 !== (workInProgress.flags & 128);\n        workInProgress.flags &= -129;\n        if (null === current) {\n            if (isHydrating) {\n                if (\"hidden\" === nextProps.mode) return current = mountActivityChildren(workInProgress, nextProps), workInProgress.lanes = 536870912, bailoutOffscreenComponent(null, current);\n                pushDehydratedActivitySuspenseHandler(workInProgress);\n                (current = nextHydratableInstance) ? (renderLanes = canHydrateActivityInstance(current, rootOrSingletonContext), null !== renderLanes && (nextProps = {\n                    dehydrated: renderLanes,\n                    treeContext: getSuspendedTreeContext(),\n                    retryLane: 536870912,\n                    hydrationErrors: null\n                }, workInProgress.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes), nextProps.return = workInProgress, workInProgress.child = nextProps, hydrationParentFiber = workInProgress, nextHydratableInstance = null)) : renderLanes = null;\n                if (null === renderLanes) throw warnNonHydratedInstance(workInProgress, current), throwOnHydrationMismatch(workInProgress);\n                workInProgress.lanes = 536870912;\n                return null;\n            }\n            return mountActivityChildren(workInProgress, nextProps);\n        }\n        var prevState = current.memoizedState;\n        if (null !== prevState) {\n            var activityInstance = prevState.dehydrated;\n            pushDehydratedActivitySuspenseHandler(workInProgress);\n            if (didSuspend) if (workInProgress.flags & 256) workInProgress.flags &= -257, workInProgress = retryActivityComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (null !== workInProgress.memoizedState) workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null;\n            else throw Error(\"Client rendering an Activity suspended it again. This is a bug in React.\");\n            else if (warnIfHydrating(), 0 !== (renderLanes & 536870912) && markRenderDerivedCause(workInProgress), didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), didSuspend = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || didSuspend) {\n                nextProps = workInProgressRoot;\n                if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(nextProps, renderLanes), 0 !== activityInstance && activityInstance !== prevState.retryLane)) throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current, activityInstance), scheduleUpdateOnFiber(nextProps, current, activityInstance), SelectiveHydrationException;\n                renderDidSuspendDelayIfPossible();\n                workInProgress = retryActivityComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else current = prevState.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinActivityInstance(activityInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && restoreSuspendedTreeContext(workInProgress, current)), workInProgress = mountActivityChildren(workInProgress, nextProps), workInProgress.flags |= 4096;\n            return workInProgress;\n        }\n        prevState = current.child;\n        nextProps = {\n            mode: nextProps.mode,\n            children: nextProps.children\n        };\n        0 !== (renderLanes & 536870912) && 0 !== (renderLanes & current.lanes) && markRenderDerivedCause(workInProgress);\n        current = createWorkInProgress(prevState, nextProps);\n        current.ref = workInProgress.ref;\n        workInProgress.child = current;\n        current.return = workInProgress;\n        return current;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 4194816);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 134217728);\n            _instance = !0;\n        } else if (null === current) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 134217728)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 134217728), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 134217728), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            setCurrentFiber(workInProgress);\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else if (Component = callRenderInDEV(lane), workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    callRenderInDEV(lane);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            workInProgress.flags |= 1;\n            null !== current && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current = workInProgress.child;\n        } else current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                (current = nextHydratableInstance) ? (renderLanes = canHydrateSuspenseInstance(current, rootOrSingletonContext), null !== renderLanes && (JSCompiler_temp = {\n                    dehydrated: renderLanes,\n                    treeContext: getSuspendedTreeContext(),\n                    retryLane: 536870912,\n                    hydrationErrors: null\n                }, workInProgress.memoizedState = JSCompiler_temp, JSCompiler_temp = createFiberFromDehydratedFragment(renderLanes), JSCompiler_temp.return = workInProgress, workInProgress.child = JSCompiler_temp, hydrationParentFiber = workInProgress, nextHydratableInstance = null)) : renderLanes = null;\n                if (null === renderLanes) throw warnNonHydratedInstance(workInProgress, current), throwOnHydrationMismatch(workInProgress);\n                isSuspenseInstanceFallback(renderLanes) ? workInProgress.lanes = 32 : workInProgress.lanes = 536870912;\n                return null;\n            }\n            var nextPrimaryChildren = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextPrimaryChildren\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextPrimaryChildren.return = workInProgress, nextProps.return = workInProgress, nextPrimaryChildren.sibling = nextProps, workInProgress.child = nextPrimaryChildren, nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n        }\n        var prevState = current.memoizedState;\n        if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, showFallback), nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes, null), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress, nextPrimaryChildren.return = workInProgress, nextProps.sibling = nextPrimaryChildren, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = bailoutOffscreenComponent(null, nextProps));\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), warnIfHydrating(), 0 !== (renderLanes & 536870912) && markRenderDerivedCause(workInProgress), isSuspenseInstanceFallback(nextPrimaryChildren)) showFallback = getSuspenseInstanceFallbackErrorDetails(nextPrimaryChildren), JSCompiler_temp = showFallback.digest, nextPrimaryChildren = showFallback.message, nextProps = showFallback.stack, showFallback = showFallback.componentStack, nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), nextPrimaryChildren.stack = nextProps || \"\", nextPrimaryChildren.digest = JSCompiler_temp, JSCompiler_temp = void 0 === showFallback ? null : showFallback, nextProps = {\n                value: nextPrimaryChildren,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(nextPrimaryChildren, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes), 0 !== nextProps && nextProps !== prevState.retryLane)) throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress.flags |= 192, workInProgress.child = current.child, workInProgress = null) : (current = prevState.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextPrimaryChildren), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && restoreSuspendedTreeContext(workInProgress, current)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress.mode, prevState = current.child, didSuspend = prevState.sibling, nextProps = createWorkInProgress(prevState, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== didSuspend ? nextPrimaryChildren = createWorkInProgress(didSuspend, nextPrimaryChildren) : (nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes, null), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = nextPrimaryChildren, workInProgress.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, showFallback = showFallback.parent !== prevState ? {\n            parent: prevState,\n            pool: prevState\n        } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {\n            baseLanes: nextPrimaryChildren.baseLanes | renderLanes,\n            cachePool: showFallback\n        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);\n        null !== prevState && (renderLanes & 62914560) === renderLanes && 0 !== (renderLanes & current.lanes) && markRenderDerivedCause(workInProgress);\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        offscreenProps = createFiber(22, offscreenProps, null, mode);\n        offscreenProps.lanes = 0;\n        return offscreenProps;\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, treeForkCount) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode,\n            treeForkCount: treeForkCount\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;\n        (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;\n        push(suspenseStackCursor, suspenseContext, workInProgress);\n        suspenseContext = null == revealOrder ? \"null\" : revealOrder;\n        if (\"forwards\" !== revealOrder && \"unstable_legacy-backwards\" !== revealOrder && \"together\" !== revealOrder && \"independent\" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext]) if (didWarnAboutRevealOrder[suspenseContext] = !0, null == revealOrder) console.error('The default for the <SuspenseList revealOrder=\"...\"> prop is changing. To be future compatible you must explictly specify either \"independent\" (the current default), \"together\", \"forwards\" or \"legacy_unstable-backwards\".');\n        else if (\"backwards\" === revealOrder) console.error('The rendering order of <SuspenseList revealOrder=\"backwards\"> is changing. To be future compatible you must specify revealOrder=\"legacy_unstable-backwards\" instead.');\n        else if (\"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n            case \"independent\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"independent\", \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"independent\", \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        suspenseContext = null == tailMode ? \"null\" : tailMode;\n        if (!didWarnAboutTailOptions[suspenseContext]) if (null == tailMode) {\n            if (\"forwards\" === revealOrder || \"backwards\" === revealOrder || \"unstable_legacy-backwards\" === revealOrder) didWarnAboutTailOptions[suspenseContext] = !0, console.error('The default for the <SuspenseList tail=\"...\"> prop is changing. To be future compatible you must explictly specify either \"visible\" (the current default), \"collapsed\" or \"hidden\".');\n        } else \"visible\" !== tailMode && \"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"visible\", \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"unstable_legacy-backwards\" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder || \"unstable_legacy-backwards\" === revealOrder) && void 0 !== newChildren && null !== newChildren && !1 !== newChildren) if (isArrayImpl(newChildren)) for(suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++){\n            if (!validateSuspenseListNestedChild(newChildren[suspenseContext], suspenseContext)) break a;\n        }\n        else if (suspenseContext = getIteratorFn(newChildren), \"function\" === typeof suspenseContext) {\n            if (suspenseContext = suspenseContext.call(newChildren)) for(var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, newChildren, renderLanes);\n        isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;\n        if (!nextProps && null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n            if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n            else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n            else if (null !== current.child) {\n                current.child.return = current;\n                current = current.child;\n                continue;\n            }\n            if (current === workInProgress) break a;\n            for(; null === current.sibling;){\n                if (null === current.return || current.return === workInProgress) break a;\n                current = current.return;\n            }\n            current.sibling.return = current.return;\n            current = current.sibling;\n        }\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode, newChildren);\n                break;\n            case \"backwards\":\n            case \"unstable_legacy-backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode, newChildren);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0, newChildren);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 31:\n                if (null !== workInProgress.memoizedState) return workInProgress.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress), null;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes, workInProgress.pendingProps);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            renderLanes._debugStack = workInProgress._debugStack;\n            renderLanes._debugTask = workInProgress._debugTask;\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = resolveLazy(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChildWithinSingleton(workInProgress.type, prevSibling, nextHydratableInstance)), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), markRef(current, workInProgress), null === current && (workInProgress.flags |= 4194304), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 31:\n                return updateActivityComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes, workInProgress.pendingProps);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function markCloned(workInProgress) {\n        supportsPersistence && (workInProgress.flags |= 8);\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 8218) || 0 !== (current.subtreeFlags & 8218)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        var hasOffscreenComponentChild = !1;\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) hasOffscreenComponentChild = node.child, null !== hasOffscreenComponentChild && (hasOffscreenComponentChild.return = node), appendAllChildrenToContainer(containerChildSet, node, !0, !0), hasOffscreenComponentChild = !0;\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return hasOffscreenComponentChild;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return hasOffscreenComponentChild;\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (markCloned(workInProgress), finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current && appendAllChildren(_oldProps, workInProgress, !1, !1));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, oldProps, newProps, renderLanes) {\n        if ((workInProgress.mode & 32) !== NoMode && (null === oldProps ? maySuspendCommit(type, newProps) : maySuspendCommitOnUpdate(type, oldProps, newProps))) {\n            if (workInProgress.flags |= 16777216, (renderLanes & 335544128) === renderLanes || maySuspendCommitInSyncRender(type, newProps)) if (preloadInstance(workInProgress.stateNode, type, newProps)) workInProgress.flags |= 8192;\n            else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, upgradeHydrationErrorsToRecoverable());\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    var type = workInProgress.type, nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, type, null, newProps, renderLanes))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (nextResource = current.memoizedProps, supportsMutation ? nextResource !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, type, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, type, nextResource, newProps, renderLanes));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    type = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, type, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(type, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                type = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, type, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    nextResource = getHostContext();\n                    if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, nextResource), finalizeHydratedChildren(workInProgress.stateNode, type, newProps, nextResource) && (workInProgress.flags |= 64);\n                    else {\n                        var _rootContainerInstance = requiredContext(rootInstanceStackCursor.current);\n                        _rootContainerInstance = createInstance(type, newProps, _rootContainerInstance, nextResource, workInProgress);\n                        markCloned(workInProgress);\n                        appendAllChildren(_rootContainerInstance, workInProgress, !1, !1);\n                        workInProgress.stateNode = _rootContainerInstance;\n                        finalizeInitialChildren(_rootContainerInstance, type, newProps, nextResource) && markUpdate(workInProgress);\n                    }\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, null === current ? null : current.memoizedProps, workInProgress.pendingProps, renderLanes);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), markCloned(workInProgress), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        type = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        nextResource = hydrationParentFiber;\n                        if (null !== nextResource) switch(nextResource.tag){\n                            case 3:\n                                type && (type = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== type && (buildHydrationDiffNode(workInProgress, 0).serverProps = type));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== type && (buildHydrationDiffNode(workInProgress, 0).serverProps = type));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress, !0);\n                    } else markCloned(workInProgress), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 31:\n                renderLanes = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState) {\n                    newProps = popHydrationState(workInProgress);\n                    if (null !== renderLanes) {\n                        if (null === current) {\n                            if (!newProps) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostActivityInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            current = workInProgress.memoizedState;\n                            current = null !== current ? current.dehydrated : null;\n                            if (!current) throw Error(\"Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateActivityInstance(current, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (renderLanes = workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                        current = !1;\n                    } else renderLanes = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes), current = !0;\n                    if (!current) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                    if (0 !== (workInProgress.flags & 128)) throw Error(\"Client rendering an Activity suspended it again. This is a bug in React.\");\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    type = newProps;\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== type && null !== type.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== type && (type = workInProgress.child, null !== type && (workInProgress.treeBaseDuration -= type.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (type = workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== type && (type = workInProgress.child, null !== type && (workInProgress.treeBaseDuration -= type.treeBaseDuration));\n                        type = !1;\n                    } else type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = !0;\n                    if (!type) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                newProps = workInProgress.memoizedState;\n                if (null === newProps) return bubbleProperties(workInProgress), null;\n                type = 0 !== (workInProgress.flags & 128);\n                nextResource = newProps.rendering;\n                if (null === nextResource) if (type) cutOffTailIfNeeded(newProps, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        nextResource = findFirstSuspended(current);\n                        if (null !== nextResource) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(newProps, !1);\n                            current = nextResource.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, type = !0, cutOffTailIfNeeded(newProps, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!type) if (current = findFirstSuspended(nextResource), null !== current) {\n                        if (workInProgress.flags |= 128, type = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(newProps, !0), null === newProps.tail && \"hidden\" === newProps.tailMode && !nextResource.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, type = !0, cutOffTailIfNeeded(newProps, !1), workInProgress.lanes = 4194304);\n                    newProps.isBackwards ? (nextResource.sibling = workInProgress.child, workInProgress.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress.child = nextResource, newProps.last = nextResource);\n                }\n                if (null !== newProps.tail) return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = type ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n            case 30:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 31:\n                if (null !== workInProgress.memoizedState) {\n                    popSuspenseHandler(workInProgress);\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 31:\n                null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1));\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    var instanceToUse = getPublicInstance(finishedWork.stateNode);\n                    break;\n                case 30:\n                    instanceToUse = finishedWork.stateNode;\n                    break;\n                default:\n                    instanceToUse = finishedWork.stateNode;\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instanceToUse);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag && isSingletonScope(fiber.type) : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;){\n                if (supportsSingletons && 27 === fiber.tag && isSingletonScope(fiber.type)) continue a;\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        for(var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;){\n            if (isHostParent(parentFiber)) {\n                hostParentFiber = parentFiber;\n                break;\n            }\n            parentFiber = parentFiber.return;\n        }\n        if (supportsMutation) {\n            if (null == hostParentFiber) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            switch(hostParentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        hostParentFiber = hostParentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);\n                        break;\n                    }\n                case 5:\n                    parentFiber = hostParentFiber.stateNode;\n                    hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);\n                    hostParentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);\n                    break;\n                case 3:\n                case 4:\n                    hostParentFiber = hostParentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostSingletonAcquisition(finishedWork) {\n        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;\n        try {\n            runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHydratingParent(current, finishedWork) {\n        return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current = current.memoizedState, finishedWork = finishedWork.memoizedState, null !== current && null !== current.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : !1;\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    if (0 !== (flags & 4) && (firstChild = firstChild.updateQueue, firstChild = null !== firstChild ? firstChild.events : null, null !== firstChild)) for(current = 0; current < firstChild.length; current++)flags = firstChild[current], flags.ref.impl = flags.nextImpl;\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 27:\n                supportsSingletons && null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);\n            case 26:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (null === current) {\n                    if (flags & 4) commitHostMount(finishedWork);\n                    else if (flags & 64) {\n                        finishedRoot = finishedWork.type;\n                        current = finishedWork.memoizedProps;\n                        prevProps = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, commitHydratedInstance, prevProps, finishedRoot, current, finishedWork);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 31:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, flags))));\n                break;\n            case 22:\n                flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!flags) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    prevProps = offscreenSubtreeIsHidden;\n                    var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = flags;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevProps;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                break;\n            case 30:\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, \"Mount\")));\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %o\", err));\n        }\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = !1);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n        (deletedFiber.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(deletedFiber, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n    }\n    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {\n            finishedRoot = finishedRoot.dehydrated;\n            try {\n                runWithFiberInDEV(finishedWork, commitHydratedActivityInstance, finishedRoot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 31:\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart();\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                            if (supportsSingletons) {\n                                if (isSingletonScope(parent.type)) {\n                                    hostParent = parent.stateNode;\n                                    hostParentIsContainer = !1;\n                                    break a;\n                                }\n                                break;\n                            }\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            (deletedFiber.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(deletedFiber, componentEffectStartTime, componentEffectEndTime, \"Unmount\");\n            popComponentEffectStart(prevEffectStart);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13886) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current = flags.callbacks, null !== current && (root = flags.shared.hiddenCallbacks, flags.shared.hiddenCallbacks = null === root ? current : root.concat(current))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);\n                    break;\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                } else supportsPersistence && null !== finishedWork.alternate && (finishedWork.alternate.stateNode = finishedWork.stateNode);\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                if (supportsResources) {\n                    prepareToCommitHoistables();\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(root.containerInfo);\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 31:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                wasHidden && !hoistableRoot && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 8192 && (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, !hoistableRoot || null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, \"Disconnect\")), supportsMutation)) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    previousHoistableRoot = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, previousHoistableRoot) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (18 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance$jscomp$0 = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideDehydratedBoundary, instance$jscomp$0) : runWithFiberInDEV(wasHidden, unhideDehydratedBoundary, wasHidden.stateNode);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 30:\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, \"Mount\")));\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 27:\n                supportsSingletons && runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);\n            case 26:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 30:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 27:\n                supportsSingletons && commitHostSingletonAcquisition(finishedWork);\n            case 26:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 31:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 30:\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions, endTime) {\n        if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var nextSibling = parentFiber.sibling;\n            commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions, null !== nextSibling ? nextSibling.actualStartTime : endTime);\n            parentFiber = nextSibling;\n        }\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 1:\n                (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, []) : 0 !== (finishedWork.flags & 1) && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes));\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                break;\n            case 3:\n                var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;\n                inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                inHydratedSubtree = wasInHydratedSubtree;\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                break;\n            case 31:\n                flags = inHydratedSubtree;\n                prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;\n                wasInHydratedSubtree = finishedWork.memoizedState;\n                null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = !1, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = !0) : inHydratedSubtree = !1;\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                inHydratedSubtree = flags;\n                break;\n            case 13:\n                flags = inHydratedSubtree;\n                prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;\n                wasInHydratedSubtree = finishedWork.memoizedState;\n                null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = !1 : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = !1, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = !0);\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                inHydratedSubtree = flags;\n                break;\n            case 23:\n                break;\n            case 22:\n                wasInHydratedSubtree = finishedWork.stateNode;\n                prevProfilerEffectDuration = finishedWork.alternate;\n                null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child), endTime), (finishedWork.mode & 2) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(prevProfilerEffectDuration, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);\n        }\n        if ((finishedWork.mode & 2) !== NoMode) {\n            if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate) committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(finishedWork, committedLanes, endTime, \"Mount\");\n            0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, \"Mount\"));\n        }\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n        alreadyWarnedForDeepEquality = prevDeepEquality;\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));\n        for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var nextSibling = parentFiber.sibling;\n            reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, null !== nextSibling ? nextSibling.actualStartTime : endTime);\n            parentFiber = nextSibling;\n        }\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;\n        includeWorkInProgressEffects && (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectErrors = prevEffectErrors;\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n        alreadyWarnedForDeepEquality = prevDeepEquality;\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {\n        if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child)) for(var child = parentFiber.child; null !== child;){\n            parentFiber = child.sibling;\n            var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;\n            (child.mode & 2) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(child, child.actualStartTime, endTime, inHydratedSubtree, committedLanes);\n            var flags = child.flags;\n            switch(child.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);\n                    flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);\n            }\n            alreadyWarnedForDeepEquality = prevDeepEquality;\n            child = parentFiber;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber, committedLanes, suspendedState), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);\n                if (fiber.flags & suspenseyCommitFlag) if (null !== fiber.memoizedState) suspendResource(suspendedState, currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);\n                else {\n                    var instance = fiber.stateNode, type = fiber.type;\n                    fiber = fiber.memoizedProps;\n                    ((committedLanes & 335544128) === committedLanes || maySuspendCommitInSyncRender(type, fiber)) && suspendInstance(suspendedState, instance, type, fiber);\n                }\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);\n                fiber.flags & suspenseyCommitFlag && (instance = fiber.stateNode, type = fiber.type, fiber = fiber.memoizedProps, ((committedLanes & 335544128) === committedLanes || maySuspendCommitInSyncRender(type, fiber)) && suspendInstance(suspendedState, instance, type, fiber));\n                break;\n            case 3:\n            case 4:\n                supportsResources ? (instance = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo), recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), currentHoistableRoot = instance) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);\n                break;\n            case 22:\n                null === fiber.memoizedState && (instance = fiber.alternate, null !== instance && null !== instance.memoizedState ? (instance = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), suspenseyCommitFlag = instance) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                (childToDelete.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, \"Unmount\");\n                popComponentEffectStart(prevEffectStart);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevProfilerEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);\n                break;\n            case 12:\n                prevProfilerEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);\n                break;\n            case 22:\n                prevProfilerEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, \"Disconnect\")) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n        componentEffectErrors = prevEffectErrors;\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                (childToDelete.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, \"Unmount\");\n                popComponentEffectStart(prevEffectStart);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n        (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n        popComponentEffectStart(prevEffectStart);\n        popComponentEffectDuration(prevEffectDuration);\n        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n        componentEffectErrors = prevEffectErrors;\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (nearestMountedAncestor = current.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            (current.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(current, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);\n            popComponentEffectStart(prevEffectStart);\n            popComponentEffectDuration(prevEffectDuration);\n            componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;\n            componentEffectErrors = prevEffectErrors;\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                prevEffectStart = current.sibling;\n                prevEffectDuration = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== prevEffectStart) {\n                    prevEffectStart.return = prevEffectDuration;\n                    nextEffect = prevEffectStart;\n                    break a;\n                }\n                nextEffect = prevEffectDuration;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        if (0 === workInProgressDeferredLane) if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {\n            var lane = nextTransitionDeferredLane;\n            nextTransitionDeferredLane <<= 1;\n            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);\n            workInProgressDeferredLane = lane;\n        } else workInProgressDeferredLane = 536870912;\n        lane = suspenseHandlerStackCursor.current;\n        null !== lane && (lane.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if ((executionContext & RenderContext) !== NoContext && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {\n            var yieldedFiber = workInProgress, yieldEndTime = now$1();\n            switch(yieldReason){\n                case SuspendedOnImmediate:\n                case SuspendedOnData:\n                    var startTime = yieldStartTime;\n                    supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, \"Suspended\", startTime, yieldEndTime, \"Components \\u269b\", void 0, \"primary-light\")) : console.timeStamp(\"Suspended\", startTime, yieldEndTime, \"Components \\u269b\", void 0, \"primary-light\"));\n                    break;\n                case SuspendedOnAction:\n                    startTime = yieldStartTime;\n                    supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, \"Action\", startTime, yieldEndTime, \"Components \\u269b\", void 0, \"primary-light\")) : console.timeStamp(\"Action\", startTime, yieldEndTime, \"Components \\u269b\", void 0, \"primary-light\"));\n                    break;\n                default:\n                    supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(\"Blocked\", yieldStartTime, yieldEndTime, \"Components \\u269b\", void 0, 5 > yieldedFiber ? \"primary-light\" : 10 > yieldedFiber ? \"primary\" : 100 > yieldedFiber ? \"primary-dark\" : \"error\"));\n            }\n        }\n        startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes)) ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0);\n        var renderWasConcurrent = forceSync;\n        do {\n            if (startTime === RootInProgress) {\n                workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root, lanes, 0, !1);\n                lanes = workInProgressSuspendedReason;\n                yieldStartTime = now();\n                yieldReason = lanes;\n                break;\n            } else {\n                yieldedFiber = now$1();\n                yieldEndTime = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {\n                    setCurrentTrackFromLanes(lanes);\n                    yieldEndTime = renderStartTime;\n                    startTime = yieldedFiber;\n                    !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, \"Teared Render\", yieldEndTime, startTime, currentTrack, \"Scheduler \\u269b\", \"error\")) : console.timeStamp(\"Teared Render\", yieldEndTime, startTime, currentTrack, \"Scheduler \\u269b\", \"error\"));\n                    finalizeRender(lanes, yieldedFiber);\n                    startTime = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (startTime === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        setCurrentTrackFromLanes(lanes);\n                        logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);\n                        finalizeRender(lanes, yieldedFiber);\n                        lanes = errorRetryLanes;\n                        a: {\n                            yieldedFiber = root;\n                            startTime = renderWasConcurrent;\n                            renderWasConcurrent = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && yieldedFiber.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);\n                            errorRetryLanes = renderRootSync(yieldedFiber, errorRetryLanes, !1);\n                            if (errorRetryLanes !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    yieldedFiber.errorRecoveryDisabledLanes |= startTime;\n                                    workInProgressRootInterleavedUpdatedLanes |= startTime;\n                                    startTime = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                yieldedFiber = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = renderWasConcurrent;\n                                null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, yieldedFiber));\n                            }\n                            startTime = errorRetryLanes;\n                        }\n                        renderWasConcurrent = !1;\n                        if (startTime !== RootErrored) continue;\n                        else yieldedFiber = now$1();\n                    }\n                }\n                if (startTime === RootFatalErrored) {\n                    setCurrentTrackFromLanes(lanes);\n                    logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);\n                    finalizeRender(lanes, yieldedFiber);\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    forceSync = root;\n                    switch(startTime){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194048) !== lanes) break;\n                        case RootSuspendedAtTheShell:\n                            setCurrentTrackFromLanes(lanes);\n                            logSuspendedRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);\n                            finalizeRender(lanes, yieldedFiber);\n                            yieldEndTime = lanes;\n                            0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);\n                            markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            break a;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(forceSync, yieldEndTime, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, startTime, null, null, renderStartTime, yieldedFiber);\n                    else {\n                        if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {\n                            markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(forceSync, 0, !0)) break a;\n                            pendingEffectsLanes = lanes;\n                            forceSync.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, \"Throttled\", renderStartTime, yieldedFiber), renderWasConcurrent);\n                            break a;\n                        }\n                        commitRootWhenReady(forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, null, renderStartTime, yieldedFiber);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        root.timeoutHandle = noTimeout;\n        var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (suspendedState = startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {\n                pendingEffectsLanes = lanes;\n                root.cancelPendingCommit = subtreeFlags(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, getSuspendedCommitReason(suspendedState, root.containerInfo), completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function isAlreadyRendering() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function finalizeRender(lanes, finalizationTime) {\n        0 !== (lanes & 127) && (blockingClampTime = finalizationTime);\n        0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);\n    }\n    function prepareFreshStack(root, lanes) {\n        supportsUserTiming && (console.timeStamp(\"Blocking Track\", 0.003, 0.003, \"Blocking\", \"Scheduler \\u269b\", \"primary-light\"), console.timeStamp(\"Transition Track\", 0.003, 0.003, \"Transition\", \"Scheduler \\u269b\", \"primary-light\"), console.timeStamp(\"Suspense Track\", 0.003, 0.003, \"Suspense\", \"Scheduler \\u269b\", \"primary-light\"), console.timeStamp(\"Idle Track\", 0.003, 0.003, \"Idle\", \"Scheduler \\u269b\", \"primary-light\"));\n        var previousRenderStartTime = renderStartTime;\n        renderStartTime = now();\n        if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {\n            setCurrentTrackFromLanes(workInProgressRootRenderLanes);\n            if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay) logSuspendedRenderPhase(previousRenderStartTime, renderStartTime, lanes, workInProgressUpdateTask);\n            else {\n                var endTime = renderStartTime, debugTask = workInProgressUpdateTask;\n                if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {\n                    var color = (lanes & 738197653) === lanes ? \"tertiary-dark\" : \"primary-dark\", label = (lanes & 536870912) === lanes ? \"Prewarm\" : (lanes & 201326741) === lanes ? \"Interrupted Hydration\" : \"Interrupted Render\";\n                    debugTask ? debugTask.run(console.timeStamp.bind(console, label, previousRenderStartTime, endTime, currentTrack, \"Scheduler \\u269b\", color)) : console.timeStamp(label, previousRenderStartTime, endTime, currentTrack, \"Scheduler \\u269b\", color);\n                }\n            }\n            finalizeRender(workInProgressRootRenderLanes, renderStartTime);\n        }\n        previousRenderStartTime = workInProgressUpdateTask;\n        workInProgressUpdateTask = null;\n        if (0 !== (lanes & 127)) {\n            workInProgressUpdateTask = blockingUpdateTask;\n            debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;\n            endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;\n            color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;\n            0 <= blockingSuspendedTime && (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(blockingSuspendedTime, color, lanes, previousRenderStartTime));\n            previousRenderStartTime = debugTask;\n            var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = 1 === blockingUpdateType, isPingedUpdate = 2 === blockingUpdateType;\n            debugTask = renderStartTime;\n            endTime = blockingUpdateTask;\n            color = blockingUpdateMethodName;\n            label = blockingUpdateComponentName;\n            if (supportsUserTiming) {\n                currentTrack = \"Blocking\";\n                0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;\n                0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;\n                if (null !== eventType && previousRenderStartTime > eventTime) {\n                    var color$jscomp$0 = eventIsRepeat ? \"secondary-light\" : \"warning\";\n                    endTime ? endTime.run(console.timeStamp.bind(console, eventIsRepeat ? \"Consecutive\" : \"Event: \" + eventType, eventTime, previousRenderStartTime, currentTrack, \"Scheduler \\u269b\", color$jscomp$0)) : console.timeStamp(eventIsRepeat ? \"Consecutive\" : \"Event: \" + eventType, eventTime, previousRenderStartTime, currentTrack, \"Scheduler \\u269b\", color$jscomp$0);\n                }\n                debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? \"error\" : (lanes & 738197653) === lanes ? \"tertiary-light\" : \"primary-light\", isSpawnedUpdate = isPingedUpdate ? \"Promise Resolved\" : isSpawnedUpdate ? \"Cascading Update\" : 5 < debugTask - previousRenderStartTime ? \"Update Blocked\" : \"Update\", isPingedUpdate = [], null != label && isPingedUpdate.push([\n                    \"Component name\",\n                    label\n                ]), null != color && isPingedUpdate.push([\n                    \"Method name\",\n                    color\n                ]), previousRenderStartTime = {\n                    start: previousRenderStartTime,\n                    end: debugTask,\n                    detail: {\n                        devtools: {\n                            properties: isPingedUpdate,\n                            track: currentTrack,\n                            trackGroup: \"Scheduler \\u269b\",\n                            color: eventTime\n                        }\n                    }\n                }, endTime ? endTime.run(performance.measure.bind(performance, isSpawnedUpdate, previousRenderStartTime)) : performance.measure(isSpawnedUpdate, previousRenderStartTime));\n            }\n            blockingUpdateTime = -1.1;\n            blockingUpdateType = 0;\n            blockingUpdateComponentName = blockingUpdateMethodName = null;\n            blockingSuspendedTime = -1.1;\n            blockingEventRepeatTime = blockingEventTime;\n            blockingEventTime = -1.1;\n            blockingClampTime = now();\n        }\n        0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime && (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(transitionSuspendedTime, color, lanes, workInProgressUpdateTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = 2 === transitionUpdateType, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = \"Transition\", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? \"secondary-light\" : \"warning\", endTime ? endTime.run(console.timeStamp.bind(console, eventType ? \"Consecutive\" : \"Event: \" + eventTime, isPingedUpdate, debugTask, currentTrack, \"Scheduler \\u269b\", color$jscomp$0)) : console.timeStamp(eventType ? \"Consecutive\" : \"Event: \" + eventTime, isPingedUpdate, debugTask, currentTrack, \"Scheduler \\u269b\", color$jscomp$0)), previousRenderStartTime > debugTask && (endTime ? endTime.run(console.timeStamp.bind(console, \"Action\", debugTask, previousRenderStartTime, currentTrack, \"Scheduler \\u269b\", \"primary-dark\")) : console.timeStamp(\"Action\", debugTask, previousRenderStartTime, currentTrack, \"Scheduler \\u269b\", \"primary-dark\")), color > previousRenderStartTime && (debugTask = eventIsRepeat ? \"Promise Resolved\" : 5 < color - previousRenderStartTime ? \"Update Blocked\" : \"Update\", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push([\n            \"Component name\",\n            isSpawnedUpdate\n        ]), null != label && isPingedUpdate.push([\n            \"Method name\",\n            label\n        ]), previousRenderStartTime = {\n            start: previousRenderStartTime,\n            end: color,\n            detail: {\n                devtools: {\n                    properties: isPingedUpdate,\n                    track: currentTrack,\n                    trackGroup: \"Scheduler \\u269b\",\n                    color: \"primary-light\"\n                }\n            }\n        }, endTime ? endTime.run(performance.measure.bind(performance, debugTask, previousRenderStartTime)) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());\n        previousRenderStartTime = root.timeoutHandle;\n        previousRenderStartTime !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));\n        previousRenderStartTime = root.cancelPendingCommit;\n        null !== previousRenderStartTime && (root.cancelPendingCommit = null, previousRenderStartTime());\n        pendingEffectsLanes = 0;\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = previousRenderStartTime = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        endTime = root.entangledLanes;\n        if (0 !== endTime) for(root = root.entanglements, endTime &= lanes; 0 < endTime;)debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root[debugTask], endTime &= ~color;\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        root = getCurrentTime();\n        1e3 < root - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root);\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return previousRenderStartTime;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current))) : erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function markRenderDerivedCause(fiber) {\n        null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootSuspendedAtTheShell;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnAction:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                case SuspendedOnAction:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(hostFiber.stateNode, type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootSuspendedAtTheShell;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return RootInProgress;\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrentByScheduler() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootSuspendedAtTheShell;\n        workInProgress = null;\n    }\n    function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        root.cancelPendingCommit = null;\n        do flushPendingEffects();\n        while (pendingEffectsStatus !== NO_PENDING_EFFECTS);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        setCurrentTrackFromLanes(lanes);\n        exitStatus === RootErrored ? logErroredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask) : null !== recoverableErrors ? logRecoveredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, recoverableErrors, null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256), workInProgressUpdateTask) : logRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask);\n        if (null !== finishedWork) {\n            0 === lanes && console.error(\"finishedLanes should not be empty during a commit. This is a bug in React.\");\n            if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;\n            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;\n            markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);\n            root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n            pendingFinishedWork = finishedWork;\n            pendingEffectsRoot = root;\n            pendingEffectsLanes = lanes;\n            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;\n            pendingPassiveTransitions = transitions;\n            pendingRecoverableErrors = recoverableErrors;\n            pendingEffectsRenderEndTime = completedRenderEndTime;\n            pendingSuspendedCommitReason = suspendedCommitReason;\n            pendingDelayedCommitReason = IMMEDIATE_COMMIT;\n            pendingSuspendedViewTransitionReason = null;\n            0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback(NormalPriority$1, function() {\n                trackSchedulerEvent();\n                pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);\n                flushPassiveEffects();\n                return null;\n            })) : (root.callbackNode = null, root.callbackPriority = 0);\n            commitErrors = null;\n            commitStartTime = now();\n            null !== suspendedCommitReason && logSuspendedCommitPhase(completedRenderEndTime, commitStartTime, suspendedCommitReason, workInProgressUpdateTask);\n            recoverableErrors = 0 !== (finishedWork.flags & 13878);\n            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {\n                recoverableErrors = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                transitions = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(2);\n                spawnedLane = executionContext;\n                executionContext |= CommitContext;\n                try {\n                    commitBeforeMutationEffects(root, finishedWork, lanes);\n                } finally{\n                    executionContext = spawnedLane, setCurrentUpdatePriority(transitions), ReactSharedInternals.T = recoverableErrors;\n                }\n            }\n            pendingEffectsStatus = PENDING_MUTATION_PHASE;\n            flushMutationEffects();\n            flushLayoutEffects();\n            flushSpawnedWork();\n        }\n    }\n    function flushMutationEffects() {\n        if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);\n            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {\n                rootMutationHasEffect = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(2);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext;\n                try {\n                    inProgressLanes = lanes, inProgressRoot = root, resetComponentEffectTimers(), commitMutationEffectsOnFiber(finishedWork, root), inProgressRoot = inProgressLanes = null, resetAfterCommit(root.containerInfo);\n                } finally{\n                    executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootMutationHasEffect;\n                }\n            }\n            root.current = finishedWork;\n            pendingEffectsStatus = PENDING_LAYOUT_PHASE;\n        }\n    }\n    function flushLayoutEffects() {\n        if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;\n            if (null !== suspendedViewTransitionReason) {\n                commitStartTime = now();\n                var startTime = commitEndTime, endTime = commitStartTime;\n                !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, suspendedViewTransitionReason, startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-light\")) : console.timeStamp(suspendedViewTransitionReason, startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-light\"));\n            }\n            suspendedViewTransitionReason = pendingEffectsRoot;\n            startTime = pendingFinishedWork;\n            endTime = pendingEffectsLanes;\n            var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);\n            if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {\n                rootHasLayoutEffect = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var _previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(2);\n                var _prevExecutionContext = executionContext;\n                executionContext |= CommitContext;\n                try {\n                    inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(suspendedViewTransitionReason, startTime.alternate, startTime), inProgressRoot = inProgressLanes = null;\n                } finally{\n                    executionContext = _prevExecutionContext, setCurrentUpdatePriority(_previousPriority), ReactSharedInternals.T = rootHasLayoutEffect;\n                }\n            }\n            suspendedViewTransitionReason = pendingEffectsRenderEndTime;\n            startTime = pendingSuspendedCommitReason;\n            commitEndTime = now();\n            suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;\n            startTime = commitEndTime;\n            endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;\n            rootHasLayoutEffect = workInProgressUpdateTask;\n            null !== commitErrors ? logCommitErrored(suspendedViewTransitionReason, startTime, commitErrors, !1, rootHasLayoutEffect) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(console.timeStamp.bind(console, endTime ? \"Commit Interrupted View Transition\" : \"Commit\", suspendedViewTransitionReason, startTime, currentTrack, \"Scheduler \\u269b\", endTime ? \"error\" : \"secondary-dark\")) : console.timeStamp(endTime ? \"Commit Interrupted View Transition\" : \"Commit\", suspendedViewTransitionReason, startTime, currentTrack, \"Scheduler \\u269b\", endTime ? \"error\" : \"secondary-dark\"));\n            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;\n        }\n    }\n    function flushSpawnedWork() {\n        if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {\n            if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {\n                var startViewTransitionStartTime = commitEndTime;\n                commitEndTime = now();\n                var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;\n                !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, abortedViewTransition ? \"Interrupted View Transition\" : \"Starting Animation\", startViewTransitionStartTime, endTime, currentTrack, \"Scheduler \\u269b\", abortedViewTransition ? \"error\" : \"secondary-light\")) : console.timeStamp(abortedViewTransition ? \"Interrupted View Transition\" : \"Starting Animation\", startViewTransitionStartTime, endTime, currentTrack, \"Scheduler \\u269b\", abortedViewTransition ? \" error\" : \"secondary-light\"));\n                pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);\n            }\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            requestPaint();\n            startViewTransitionStartTime = pendingEffectsRoot;\n            var finishedWork = pendingFinishedWork;\n            endTime = pendingEffectsLanes;\n            abortedViewTransition = pendingRecoverableErrors;\n            var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);\n            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(startViewTransitionStartTime, startViewTransitionStartTime.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n            var remainingLanes = startViewTransitionStartTime.pendingLanes;\n            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);\n            remainingLanes = lanesToEventPriority(endTime);\n            finishedWork = finishedWork.stateNode;\n            if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n                var didError = 128 === (finishedWork.current.flags & 128);\n                switch(remainingLanes){\n                    case 2:\n                        var schedulerPriority = ImmediatePriority;\n                        break;\n                    case 8:\n                        schedulerPriority = UserBlockingPriority;\n                        break;\n                    case 32:\n                        schedulerPriority = NormalPriority$1;\n                        break;\n                    case 268435456:\n                        schedulerPriority = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriority = NormalPriority$1;\n                }\n                injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);\n            } catch (err) {\n                hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %o\", err));\n            }\n            isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();\n            onCommitRoot();\n            if (null !== abortedViewTransition) {\n                didError = ReactSharedInternals.T;\n                schedulerPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(2);\n                ReactSharedInternals.T = null;\n                try {\n                    var onRecoverableError = startViewTransitionStartTime.onRecoverableError;\n                    for(finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++){\n                        var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);\n                        runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);\n                    }\n                } finally{\n                    ReactSharedInternals.T = didError, setCurrentUpdatePriority(schedulerPriority);\n                }\n            }\n            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();\n            ensureRootIsScheduled(startViewTransitionStartTime);\n            remainingLanes = startViewTransitionStartTime.pendingLanes;\n            0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;\n            rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);\n            supportsHydration && flushHydrationEvents();\n            flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPendingEffects() {\n        flushMutationEffects();\n        flushLayoutEffects();\n        flushSpawnedWork();\n        return flushPassiveEffects();\n    }\n    function flushPassiveEffects() {\n        if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;\n        var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;\n        pendingEffectsRemainingLanes = 0;\n        var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n        renderPriority = ReactSharedInternals.T;\n        var previousPriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(priority);\n            ReactSharedInternals.T = null;\n            var transitions = pendingPassiveTransitions;\n            pendingPassiveTransitions = null;\n            priority = pendingEffectsRoot;\n            var lanes = pendingEffectsLanes;\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            pendingFinishedWork = pendingEffectsRoot = null;\n            pendingEffectsLanes = 0;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n            setCurrentTrackFromLanes(lanes);\n            isFlushingPassiveEffects = !0;\n            didScheduleUpdateDuringPassiveEffects = !1;\n            var passiveEffectStartTime = 0;\n            commitErrors = null;\n            passiveEffectStartTime = now$1();\n            if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT) {\n                var startTime = commitEndTime, endTime = passiveEffectStartTime;\n                !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, \"Animating\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-dark\")) : console.timeStamp(\"Animating\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-dark\"));\n            } else {\n                startTime = commitEndTime;\n                endTime = passiveEffectStartTime;\n                var delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;\n                !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, delayedUntilPaint ? \"Waiting for Paint\" : \"Waiting\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-light\")) : console.timeStamp(delayedUntilPaint ? \"Waiting for Paint\" : \"Waiting\", startTime, endTime, currentTrack, \"Scheduler \\u269b\", \"secondary-light\"));\n            }\n            startTime = executionContext;\n            executionContext |= CommitContext;\n            var finishedWork = priority.current;\n            resetComponentEffectTimers();\n            commitPassiveUnmountOnFiber(finishedWork);\n            var finishedWork$jscomp$0 = priority.current;\n            finishedWork = pendingEffectsRenderEndTime;\n            resetComponentEffectTimers();\n            commitPassiveMountOnFiber(priority, finishedWork$jscomp$0, lanes, transitions, finishedWork);\n            commitDoubleInvokeEffectsInDEV(priority);\n            executionContext = startTime;\n            var passiveEffectsEndTime = now$1();\n            finishedWork$jscomp$0 = passiveEffectStartTime;\n            finishedWork = workInProgressUpdateTask;\n            null !== commitErrors ? logCommitErrored(finishedWork$jscomp$0, passiveEffectsEndTime, commitErrors, !0, finishedWork) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(console.timeStamp.bind(console, \"Remaining Effects\", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, \"Scheduler \\u269b\", \"secondary-dark\")) : console.timeStamp(\"Remaining Effects\", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, \"Scheduler \\u269b\", \"secondary-dark\"));\n            finalizeRender(lanes, passiveEffectsEndTime);\n            flushSyncWorkAcrossRoots_impl(0, !1);\n            didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;\n            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n            if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                injectedHook.onPostCommitFiberRoot(rendererID, priority);\n            } catch (err) {\n                hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %o\", err));\n            }\n            var stateNode = priority.current.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n            return !0;\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n        }\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        recordEffectError(sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        recordEffectError(sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask(\"Promise Resolved\"), blockingUpdateType = 2) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask(\"Promise Resolved\"), transitionUpdateType = 2);\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 31:\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 67117056)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), reconnectPassiveEffects(root, fiber, 0, null, !1, 0);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        do {\n            var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;\n            _fiber = _fiber.type;\n            var candidateType = null;\n            switch(tag){\n                case 0:\n                case 15:\n                case 1:\n                    candidateType = _fiber;\n                    break;\n                case 11:\n                    candidateType = _fiber.render;\n            }\n            if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n            var needsRender = !1;\n            _fiber = !1;\n            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = !0 : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = !0 : needsRender = !0)));\n            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = !0);\n            _fiber && (fiber._debugNeedsRemount = !0);\n            if (_fiber || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n            null === child || _fiber || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n            if (null === sibling) break;\n            fiber = sibling;\n        }while (1);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugStack = current._debugStack, workInProgress._debugTask = current._debugTask, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 65011712;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 65011714;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_ACTIVITY_TYPE:\n                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        mode._debugStack = element._debugStack;\n        mode._debugTask = element._debugTask;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromDehydratedFragment(dehydratedNode) {\n        var fiber = createFiber(18, null, null, NoMode);\n        fiber.stateNode = dehydratedNode;\n        return fiber;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isStrictMode = createFiber(3, null, null, tag | 2);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %o\", err));\n        }\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (startUpdateTimerByLane(lane, \"root.render()\", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    var REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\n    Symbol.for(\"react.view_transition\");\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance;\n    $$$config.cloneMutableInstance;\n    var appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance;\n    $$$config.cloneMutableTextInstance;\n    var scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority, trackSchedulerEvent = $$$config.trackSchedulerEvent, resolveEventType = $$$config.resolveEventType, resolveEventTimeStamp = $$$config.resolveEventTimeStamp, shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, maySuspendCommitOnUpdate = $$$config.maySuspendCommitOnUpdate, maySuspendCommitInSyncRender = $$$config.maySuspendCommitInSyncRender, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance;\n    $$$config.suspendOnActiveViewTransition;\n    var waitForCommitToBeReady = $$$config.waitForCommitToBeReady, getSuspendedCommitReason = $$$config.getSuspendedCommitReason, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance;\n    $$$config.cancelViewTransitionName;\n    $$$config.cancelRootViewTransitionName;\n    $$$config.restoreRootViewTransitionName;\n    $$$config.cloneRootViewTransitionContainer;\n    $$$config.removeRootViewTransitionClone;\n    $$$config.measureClonedInstance;\n    $$$config.hasInstanceChanged;\n    $$$config.hasInstanceAffectedParent;\n    $$$config.startViewTransition;\n    $$$config.startGestureTransition;\n    $$$config.stopViewTransition;\n    $$$config.getCurrentGestureOffset;\n    $$$config.createViewTransitionInstance;\n    var clearContainer = $$$config.clearContainer;\n    $$$config.createFragmentInstance;\n    $$$config.updateFragmentInstanceFiber;\n    $$$config.commitNewChildToFragmentInstance;\n    $$$config.deleteChildFromFragmentInstance;\n    var cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getNextHydratableSiblingAfterSingleton = $$$config.getNextHydratableSiblingAfterSingleton, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinActivityInstance = $$$config.getFirstHydratableChildWithinActivityInstance, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, getFirstHydratableChildWithinSingleton = $$$config.getFirstHydratableChildWithinSingleton, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateActivityInstance = $$$config.canHydrateActivityInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateActivityInstance = $$$config.hydrateActivityInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterActivityInstance = $$$config.getNextHydratableInstanceAfterActivityInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedInstance = $$$config.commitHydratedInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedActivityInstance = $$$config.commitHydratedActivityInstance, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, finalizeHydratedChildren = $$$config.finalizeHydratedChildren, flushHydrationEvents = $$$config.flushHydrationEvents;\n    $$$config.clearActivityBoundary;\n    var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;\n    $$$config.clearActivityBoundaryFromContainer;\n    var clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, hideDehydratedBoundary = $$$config.hideDehydratedBoundary, unhideDehydratedBoundary = $$$config.unhideDehydratedBoundary, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, isSingletonScope = $$$config.isSingletonScope, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, lastResetTime = 0;\n    if (\"object\" === typeof performance && \"function\" === typeof performance.now) {\n        var localPerformance = performance;\n        var getCurrentTime = function() {\n            return localPerformance.now();\n        };\n    } else {\n        var localDate = Date;\n        getCurrentTime = function() {\n            return localDate.now();\n        };\n    }\n    var objectIs = \"function\" === typeof Object.is ? Object.is : is, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, hasOwnProperty = Object.prototype.hasOwnProperty, supportsUserTiming = \"undefined\" !== typeof console && \"function\" === typeof console.timeStamp && \"undefined\" !== typeof performance && \"function\" === typeof performance.measure, currentTrack = \"Blocking\", alreadyWarnedForDeepEquality = !1, reusableComponentDevToolDetails = {\n        color: \"primary\",\n        properties: null,\n        tooltipText: \"\",\n        track: \"Components \\u269b\"\n    }, reusableComponentOptions = {\n        start: -0,\n        end: -0,\n        detail: {\n            devtools: reusableComponentDevToolDetails\n        }\n    }, resuableChangedPropsEntry = [\n        \"Changed Props\",\n        \"\"\n    ], reusableDeeplyEqualPropsEntry = [\n        \"Changed Props\",\n        \"This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.\"\n    ], disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, current = null, isRendering = !1, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {\n        return null;\n    }, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = !1, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        globalMostRecentTransitionTime = now$1();\n        if (\"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then) {\n            if (0 > transitionStartTime && 0 > transitionUpdateTime) {\n                transitionStartTime = now();\n                var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();\n                if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType) transitionEventRepeatTime = -1.1;\n                transitionEventTime = newEventTime;\n                transitionEventType = newEventType;\n            }\n            entangleAsyncAction(transition, returnValue);\n        }\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var callComponent = {\n        react_stack_bottom_frame: function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {\n        react_stack_bottom_frame: function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {\n        react_stack_bottom_frame: function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(callComponentDidMount), callComponentDidUpdate = {\n        react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(callComponentDidUpdate), callComponentDidCatch = {\n        react_stack_bottom_frame: function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(callComponentDidCatch), callComponentWillUnmount = {\n        react_stack_bottom_frame: function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(callComponentWillUnmount), callCreate = {\n        react_stack_bottom_frame: function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {\n        react_stack_bottom_frame: function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {\n        react_stack_bottom_frame: function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), SuspenseActionException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1, ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError,\n        useHostTransitionStatus: throwInvalidHookError,\n        useFormState: throwInvalidHookError,\n        useActionState: throwInvalidHookError,\n        useOptimistic: throwInvalidHookError,\n        useMemoCache: throwInvalidHookError,\n        useCacheRefresh: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useFormState: function(action, initialState) {\n            currentHookNameInDev = \"useFormState\";\n            mountHookTypesDev();\n            warnOnUseFormStateInDev();\n            return mountActionState(action, initialState);\n        },\n        useActionState: function(action, initialState) {\n            currentHookNameInDev = \"useActionState\";\n            mountHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useOptimistic: function(passthrough) {\n            currentHookNameInDev = \"useOptimistic\";\n            mountHookTypesDev();\n            return mountOptimistic(passthrough);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            mountHookTypesDev();\n            return mountEvent(callback);\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useActionState: function(action, initialState) {\n            currentHookNameInDev = \"useActionState\";\n            updateHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useFormState: function(action, initialState) {\n            currentHookNameInDev = \"useFormState\";\n            updateHookTypesDev();\n            warnOnUseFormStateInDev();\n            return mountActionState(action, initialState);\n        },\n        useOptimistic: function(passthrough) {\n            currentHookNameInDev = \"useOptimistic\";\n            updateHookTypesDev();\n            return mountOptimistic(passthrough);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            updateHookTypesDev();\n            return mountEvent(callback);\n        }\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            updateHookTypesDev();\n            warnOnUseFormStateInDev();\n            return updateActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            updateHookTypesDev();\n            return updateActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            updateHookTypesDev();\n            return updateOptimistic(passthrough, reducer);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            updateHookTypesDev();\n            return updateEvent(callback);\n        }\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            updateHookTypesDev();\n            warnOnUseFormStateInDev();\n            return rerenderActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            updateHookTypesDev();\n            return rerenderActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            updateHookTypesDev();\n            return rerenderOptimistic(passthrough, reducer);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            updateHookTypesDev();\n            return updateEvent(callback);\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useFormState: function(action, initialState) {\n            currentHookNameInDev = \"useFormState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useActionState: function(action, initialState) {\n            currentHookNameInDev = \"useActionState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useOptimistic: function(passthrough) {\n            currentHookNameInDev = \"useOptimistic\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountOptimistic(passthrough);\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEvent(callback);\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateOptimistic(passthrough, reducer);\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEvent(callback);\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderOptimistic(passthrough, reducer);\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useEffectEvent: function(callback) {\n            currentHookNameInDev = \"useEffectEvent\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEvent(callback);\n        }\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (startUpdateTimerByLane(lane, \"this.setState()\", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (startUpdateTimerByLane(lane, \"this.replaceState()\", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (startUpdateTimerByLane(lane, \"this.forceUpdate()\", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n        }\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0,\n        hydrationErrors: null\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, inHydratedSubtree = !1, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        cacheSignal: function() {\n            return readContext(CacheContext).controller.signal;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    scheduleRetry = function(fiber) {\n        var lane = claimNextRetryLane(), root = enqueueConcurrentRenderForLane(fiber, lane);\n        null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag || 31 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag || 31 === fiber.tag) {\n            var lane = requestUpdateLane(fiber);\n            lane = getBumpedLaneForHydrationByLane(lane);\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 31:\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, null, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        tag = getBumpedLaneForHydrationByLane(tag);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        startUpdateTimerByLane(tag, \"hydrateRoot()\", null);\n        callback = tag;\n        initialChildren.current.lanes = callback;\n        markRootUpdated$1(initialChildren, callback);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\");\n        \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n            \"%o\\n\\n%s\\n\\n%s\\n\",\n            error,\n            componentNameMessage,\n            recreateMessage\n        ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error) {\n        reportGlobalError(error);\n        console.warn(\"%s\\n\\n%s\\n\", componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\", \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPendingEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            reconcilerVersion: \"19.2.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.scheduleRetry = scheduleRetry;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = isAlreadyRendering;\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startHostActionTimer(formFiber);\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);\n            dispatchSetStateInternal(formFiber, stateHook.next.queue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0FjVyxJQWJSLFFBQVFDLE9BQU8sR0FBRyxTQUFVQyxTQUFTO0lBQ3BDLFNBQVNDLFNBQVNDLEtBQUssRUFBRUMsRUFBRTtRQUN6QixJQUFLRCxRQUFRQSxNQUFNRSxhQUFhLEVBQUUsU0FBU0YsU0FBUyxJQUFJQyxJQUN0RCxRQUFTRCxNQUFNRyxJQUFJLEVBQUdGO1FBQ3hCLE9BQU9EO0lBQ1Q7SUFDQSxTQUFTSSxnQkFBZ0JDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7UUFDOUMsSUFBSUQsU0FBU0QsS0FBS0csTUFBTSxFQUFFLE9BQU9EO1FBQ2pDLElBQUlFLE1BQU1KLElBQUksQ0FBQ0MsTUFBTSxFQUNuQkksVUFBVUMsWUFBWVAsT0FBT0EsSUFBSVEsS0FBSyxLQUFLQyxPQUFPLENBQUMsR0FBR1Q7UUFDeERNLE9BQU8sQ0FBQ0QsSUFBSSxHQUFHTixnQkFBZ0JDLEdBQUcsQ0FBQ0ssSUFBSSxFQUFFSixNQUFNQyxRQUFRLEdBQUdDO1FBQzFELE9BQU9HO0lBQ1Q7SUFDQSxTQUFTSSxlQUFlVixHQUFHLEVBQUVXLE9BQU8sRUFBRUMsT0FBTztRQUMzQyxJQUFJRCxRQUFRUCxNQUFNLEtBQUtRLFFBQVFSLE1BQU0sRUFDbkNTLFFBQVFDLElBQUksQ0FBQzthQUNWO1lBQ0gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFFBQVFSLE1BQU0sR0FBRyxHQUFHVyxJQUN0QyxJQUFJSixPQUFPLENBQUNJLEVBQUUsS0FBS0gsT0FBTyxDQUFDRyxFQUFFLEVBQUU7Z0JBQzdCRixRQUFRQyxJQUFJLENBQ1Y7Z0JBRUY7WUFDRjtZQUNGLE9BQU9FLG1CQUFtQmhCLEtBQUtXLFNBQVNDLFNBQVM7UUFDbkQ7SUFDRjtJQUNBLFNBQVNJ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LEVBQ053akMsUUFBUTtRQUVSLElBQUksTUFBTS82QixVQUFVaGxDLEdBQUcsRUFDckIsTUFBTXdDLE1BQ0o7UUFFSixJQUFJZ3dCLFFBQVF1Uyw4QkFBOEJDLFdBQVd4UyxLQUFLO1FBQzFEalAscUJBQXFCeWhCO1FBQ3JCVixnQkFDRVUsV0FDQXhTLE9BQ0ErUixjQUNBNXNCLHNCQUNBLFNBQVM0a0IsU0FDTC82QixPQUNBO1lBQ0UsU0FBU2dSLHFCQUFxQit0QixDQUFDLElBQzdCamhDLFFBQVFnQyxLQUFLLENBQ1g7WUFFSixJQUFJOGdDLFlBQVkyQyw4QkFBOEJDO1lBQzlDLFNBQVM1QyxVQUFVN2pDLElBQUksSUFDcEI2akMsQ0FBQUEsWUFBWTRDLFVBQVU1aUMsU0FBUyxDQUFDOUQsYUFBYTtZQUNoRHVtQyx5QkFDRUcsV0FDQTVDLFVBQVU3akMsSUFBSSxDQUFDaTBCLEtBQUssRUFDcEIsQ0FBQyxHQUNEc1Msa0JBQWtCRTtZQUVwQixPQUFPekksT0FBT3dqQztRQUNoQjtJQUVSO0lBQ0E5aEUsUUFBUStoRSxlQUFlLEdBQUcsU0FDeEIxL0QsT0FBTyxFQUNQZzBDLFNBQVMsRUFDVGlkLGVBQWUsRUFDZmgyQyxRQUFRO1FBRVIsSUFBSXJhLFVBQVVvekMsVUFBVXB6QyxPQUFPLEVBQzdCMkYsT0FBT2krQixrQkFBa0I1akM7UUFDM0Jzd0Qsb0JBQ0V0d0QsU0FDQTJGLE1BQ0F2RyxTQUNBZzBDLFdBQ0FpZCxpQkFDQWgyQztRQUVGLE9BQU8xVTtJQUNUO0lBQ0E1SSxRQUFRd0MsbUJBQW1CLEdBQUdBO0lBQzlCLE9BQU94QztBQUNULEdBQ0NELHlCQUFzQixHQUFHQSxPQUFPQyxPQUFPLEVBQ3hDd04sT0FBT29ILGNBQWMsQ0FBQzdVLE9BQU9DLE9BQU8sRUFBRSxjQUFjO0lBQUVXLE9BQU8sQ0FBQztBQUFFLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0XFxDb25jZXJ0IFRpY2tldGluZ1xcVGlja2V0aW5nVWlcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcY2pzXFxyZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gICgobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJCQkY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gZmluZEhvb2soZmliZXIsIGlkKSB7XG4gICAgICBmb3IgKGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTsgbnVsbCAhPT0gZmliZXIgJiYgMCA8IGlkOyApXG4gICAgICAgIChmaWJlciA9IGZpYmVyLm5leHQpLCBpZC0tO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZShvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpXG4gICAgICAgIGNvbnNvbGUud2FybihcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aFxuICAgICAgICA/ICgodXBkYXRlZFtuZXdQYXRoW2luZGV4XV0gPSB1cGRhdGVkW29sZEtleV0pLFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpXG4gICAgICAgICAgICA/IHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSlcbiAgICAgICAgICAgIDogZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XSlcbiAgICAgICAgOiAodXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKFxuICAgICAgICAgICAgb2JqW29sZEtleV0sXG4gICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIGluZGV4ICsgMVxuICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIGluZGV4KSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc0FycmF5SW1wbCh1cGRhdGVkKSA/IHVwZGF0ZWQuc3BsaWNlKGtleSwgMSkgOiBkZWxldGUgdXBkYXRlZFtrZXldLFxuICAgICAgICAgIHVwZGF0ZWRcbiAgICAgICAgKTtcbiAgICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kSW1wbCgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkRXJyb3JJbXBsKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJvb3Qocm9vdCwgZWxlbWVudCkge1xuICAgICAgcm9vdC5jb250ZXh0ID09PSBlbXB0eUNvbnRleHRPYmplY3QgJiZcbiAgICAgICAgKHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCksIGZsdXNoU3luY1dvcmsoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpIHtcbiAgICAgIGlmIChudWxsICE9PSByZXNvbHZlRmFtaWx5KSB7XG4gICAgICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXM7XG4gICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgICAgIGZsdXNoUGVuZGluZ0VmZmVjdHMoKTtcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICAgICAgZmx1c2hTeW5jV29yaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSZWZyZXNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRIb29rQWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KCkge31cbiAgICBmdW5jdGlvbiBzZXRUb1NvcnRlZFN0cmluZyhzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlcixcbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcbiAgICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIGZvciAoOyBub2RlLnJldHVybjsgKSBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmliZXIgPSBub2RlO1xuICAgICAgICBkb1xuICAgICAgICAgIChub2RlID0gZmliZXIpLFxuICAgICAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJiAobmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybiksXG4gICAgICAgICAgICAoZmliZXIgPSBub2RlLnJldHVybik7XG4gICAgICAgIHdoaWxlIChmaWJlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBuZWFyZXN0TW91bnRlZCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAgICAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuICAgICAgICBpZiAobnVsbCA9PT0gYWx0ZXJuYXRlKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgcmV0dXJuIGFsdGVybmF0ZSAhPT0gZmliZXIgPyBudWxsIDogZmliZXI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBhID0gZmliZXIsIGIgPSBhbHRlcm5hdGU7IDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRBKSBicmVhaztcbiAgICAgICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudEIpIHtcbiAgICAgICAgICBiID0gcGFyZW50QS5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgIT09IGIpIHtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICAgICAgZm9yIChwYXJlbnRCID0gcGFyZW50QS5jaGlsZDsgcGFyZW50QjsgKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYSkgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgZmliZXI7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYikgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgYWx0ZXJuYXRlO1xuICAgICAgICAgICAgcGFyZW50QiA9IHBhcmVudEIuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIChhID0gcGFyZW50QSksIChiID0gcGFyZW50Qik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGRpZEZpbmRDaGlsZCA9ICExLCBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkOyBfY2hpbGQ7ICkge1xuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIGZvciAoX2NoaWxkID0gcGFyZW50Qi5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoMyAhPT0gYS50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgIHJldHVybiBhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhID8gZmliZXIgOiBhbHRlcm5hdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgICAgIHJldHVybiBudWxsICE9PSBwYXJlbnQgPyBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwocGFyZW50KSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIHRhZyA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHRhZykgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnIHx8IDYgPT09IHRhZykgcmV0dXJuIG5vZGU7XG4gICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDQgIT09IG5vZGUudGFnICYmXG4gICAgICAgICAgKCh0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpKSwgbnVsbCAhPT0gdGFnKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB7XG4gICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIFwiQ2FjaGVcIjtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHJldHVybiBcIkRlaHlkcmF0ZWRGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSB0eXBlLnJlbmRlciksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgICAoXCJcIiAhPT0gZmliZXIgPyBcIkZvcndhcmRSZWYoXCIgKyBmaWJlciArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIFwiUm9vdFwiO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIFwiVGV4dFwiO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA/IFwiU3RyaWN0TW9kZVwiIDogXCJNb2RlXCI7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZXR1cm4gXCJTY29wZVwiO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIFwiVHJhY2luZ01hcmtlclwiO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdHlwZSA9IGZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICAgICAgaWYgKG51bGwgIT0gdHlwZSlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0eXBlLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGVbaV0ubmFtZSkgcmV0dXJuIHR5cGVbaV0ubmFtZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIucmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIucmV0dXJuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjdXJyZW50OiBkZWZhdWx0VmFsdWUgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgICAgIDAgPiBpbmRleCRqc2NvbXAkMFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIHBvcC5cIilcbiAgICAgICAgOiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuXCIpLFxuICAgICAgICAgIChjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdKSxcbiAgICAgICAgICAodmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBudWxsKSxcbiAgICAgICAgICAoZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBudWxsKSxcbiAgICAgICAgICBpbmRleCRqc2NvbXAkMC0tKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICAgICAgaW5kZXgkanNjb21wJDArKztcbiAgICAgIHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdID0gY3Vyc29yLmN1cnJlbnQ7XG4gICAgICBmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSA9IGZpYmVyO1xuICAgICAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gICAgICB4ID4+Pj0gMDtcbiAgICAgIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyQxKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gICAgICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgICBzd2l0Y2ggKGxhbmVzICYgLWxhbmVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgcmV0dXJuIDEyODtcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDI2MTg4ODtcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiAzOTMyMTYwO1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA2MjkxNDU2MDtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICAgIHJldHVybiAxMzQyMTc3Mjg7XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzLCByb290SGFzUGVuZGluZ0NvbW1pdCkge1xuICAgICAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgcmV0dXJuIDA7XG4gICAgICB2YXIgbmV4dExhbmVzID0gMCxcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gICAgICByb290ID0gcm9vdC53YXJtTGFuZXM7XG4gICAgICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIDEzNDIxNzcyNztcbiAgICAgIDAgIT09IG5vbklkbGVQZW5kaW5nTGFuZXNcbiAgICAgICAgPyAoKHBlbmRpbmdMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgICAgIDAgIT09IHBlbmRpbmdMYW5lc1xuICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogKChwaW5nZWRMYW5lcyAmPSBub25JZGxlUGVuZGluZ0xhbmVzKSxcbiAgICAgICAgICAgICAgMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICAgICAgOiByb290SGFzUGVuZGluZ0NvbW1pdCB8fFxuICAgICAgICAgICAgICAgICAgKChyb290SGFzUGVuZGluZ0NvbW1pdCA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+cm9vdCksXG4gICAgICAgICAgICAgICAgICAwICE9PSByb290SGFzUGVuZGluZ0NvbW1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAobmV4dExhbmVzID1cbiAgICAgICAgICAgICAgICAgICAgICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhyb290SGFzUGVuZGluZ0NvbW1pdCkpKSkpXG4gICAgICAgIDogKChub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICA6IHJvb3RIYXNQZW5kaW5nQ29tbWl0IHx8XG4gICAgICAgICAgICAgICAgKChyb290SGFzUGVuZGluZ0NvbW1pdCA9IHBlbmRpbmdMYW5lcyAmIH5yb290KSxcbiAgICAgICAgICAgICAgICAwICE9PSByb290SGFzUGVuZGluZ0NvbW1pdCAmJlxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3RIYXNQZW5kaW5nQ29tbWl0KSkpKTtcbiAgICAgIHJldHVybiAwID09PSBuZXh0TGFuZXNcbiAgICAgICAgPyAwXG4gICAgICAgIDogMCAhPT0gd2lwTGFuZXMgJiZcbiAgICAgICAgICAgIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgIDAgPT09ICh3aXBMYW5lcyAmIHN1c3BlbmRlZExhbmVzKSAmJlxuICAgICAgICAgICAgKChzdXNwZW5kZWRMYW5lcyA9IG5leHRMYW5lcyAmIC1uZXh0TGFuZXMpLFxuICAgICAgICAgICAgKHJvb3RIYXNQZW5kaW5nQ29tbWl0ID0gd2lwTGFuZXMgJiAtd2lwTGFuZXMpLFxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPj0gcm9vdEhhc1BlbmRpbmdDb21taXQgfHxcbiAgICAgICAgICAgICAgKDMyID09PSBzdXNwZW5kZWRMYW5lcyAmJiAwICE9PSAocm9vdEhhc1BlbmRpbmdDb21taXQgJiA0MTk0MDQ4KSkpXG4gICAgICAgICAgPyB3aXBMYW5lc1xuICAgICAgICAgIDogbmV4dExhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAwID09PVxuICAgICAgICAocm9vdC5wZW5kaW5nTGFuZXMgJlxuICAgICAgICAgIH4ocm9vdC5zdXNwZW5kZWRMYW5lcyAmIH5yb290LnBpbmdlZExhbmVzKSAmXG4gICAgICAgICAgcmVuZGVyTGFuZXMpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgICAgIHN3aXRjaCAobGFuZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDVlMztcbiAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgICBjYXNlIDEzNDIxNzcyODpcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICBjYXNlIDEwNzM3NDE4MjQ6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLTFcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gICAgICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRSZXRyeUxhbmUgJiA2MjkxNDU2MCkgJiYgKG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgICAgIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gICAgICByZXR1cm4gbGFuZU1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTtcbiAgICAgIDI2ODQzNTQ1NiAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkTGFuZXMsXG4gICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICAgICAgcm9vdC53YXJtTGFuZXMgPSAwO1xuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gICAgICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gICAgICBmb3IgKFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gICAgICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IDA7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSAtMTtcbiAgICAgICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG4gICAgICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsLCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpbmRleF07XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgMCk7XG4gICAgICAwICE9PSBzdXNwZW5kZWRSZXRyeUxhbmVzICYmXG4gICAgICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgICAgICAwICE9PSByb290LnRhZyAmJlxuICAgICAgICAocm9vdC5zdXNwZW5kZWRMYW5lcyB8PVxuICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7XG4gICAgICB2YXIgc3Bhd25lZExhbmVJbmRleCA9IDMxIC0gY2x6MzIoc3Bhd25lZExhbmUpO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSA9XG4gICAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8XG4gICAgICAgIDEwNzM3NDE4MjQgfFxuICAgICAgICAoZW50YW5nbGVkTGFuZXMgJiAyNjE5MzApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgdmFyIHJvb3RFbnRhbmdsZWRMYW5lcyA9IChyb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgICAgIGZvciAocm9vdCA9IHJvb3QuZW50YW5nbGVtZW50czsgcm9vdEVudGFuZ2xlZExhbmVzOyApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihyb290RW50YW5nbGVkTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAobGFuZSAmIGVudGFuZ2xlZExhbmVzKSB8IChyb290W2luZGV4XSAmIGVudGFuZ2xlZExhbmVzKSAmJlxuICAgICAgICAgIChyb290W2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICAgIHJvb3RFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihyb290LCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIHJlbmRlckxhbmUgPSByZW5kZXJMYW5lcyAmIC1yZW5kZXJMYW5lcztcbiAgICAgIHJlbmRlckxhbmUgPVxuICAgICAgICAwICE9PSAocmVuZGVyTGFuZSAmIDQyKVxuICAgICAgICAgID8gMVxuICAgICAgICAgIDogZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbkJ5TGFuZShyZW5kZXJMYW5lKTtcbiAgICAgIHJldHVybiAwICE9PSAocmVuZGVyTGFuZSAmIChyb290LnN1c3BlbmRlZExhbmVzIHwgcmVuZGVyTGFuZXMpKVxuICAgICAgICA/IDBcbiAgICAgICAgOiByZW5kZXJMYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uQnlMYW5lKGxhbmUpIHtcbiAgICAgIHN3aXRjaCAobGFuZSkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbGFuZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBsYW5lID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBsYW5lID0gMTY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgbGFuZSA9IDEyODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgbGFuZSA9IDEzNDIxNzcyODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsYW5lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgIGZvciAocm9vdCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDsgMCA8IGxhbmVzOyApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIHJvb3RbaW5kZXhdLmFkZChmaWJlcik7XG4gICAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAsXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgICAgICAgICByb290ID0gMSA8PCBpbmRleDtcbiAgICAgICAgICBpbmRleCA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgICAgICAgIDAgPCBpbmRleC5zaXplICYmXG4gICAgICAgICAgICAoaW5kZXguZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKSB8fFxuICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5kZXguY2xlYXIoKSk7XG4gICAgICAgICAgbGFuZXMgJj0gfnJvb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpIHtcbiAgICAgIGxhbmVzICY9IC1sYW5lcztcbiAgICAgIHJldHVybiAyIDwgbGFuZXNcbiAgICAgICAgPyA4IDwgbGFuZXNcbiAgICAgICAgICA/IDAgIT09IChsYW5lcyAmIDEzNDIxNzcyNylcbiAgICAgICAgICAgID8gMzJcbiAgICAgICAgICAgIDogMjY4NDM1NDU2XG4gICAgICAgICAgOiA4XG4gICAgICAgIDogMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHJldHVybiAhMTtcbiAgICAgIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICAgICAgaWYgKGhvb2suaXNEaXNhYmxlZCkgcmV0dXJuICEwO1xuICAgICAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiBodHRwczovL3JlYWN0LmRldi9saW5rL3JlYWN0LWRldnRvb2xzXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICEwXG4gICAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICAocmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscykpLCAoaW5qZWN0ZWRIb29rID0gaG9vayk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJW8uXCIsIGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9vay5jaGVja0RDRSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9nICYmXG4gICAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVvXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRBcnJheUtpbmQoYXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGtpbmQgPSAwLCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzQXJyYXlJbXBsKHZhbHVlKSAmJlxuICAgICAgICAgICAgMiA9PT0gdmFsdWUubGVuZ3RoICYmXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVbMF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICgwICE9PSBraW5kICYmIDMgIT09IGtpbmQpIHJldHVybiAxO1xuICAgICAgICAgICAga2luZCA9IDM7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiAxO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSAmJiA1MCA8IHZhbHVlLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICgwICE9PSBraW5kICYmIDIgIT09IGtpbmQpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAga2luZCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBraW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRPYmplY3RUb1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzLCBpbmRlbnQsIHByZWZpeCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdClcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiZcbiAgICAgICAgICBcIl9cIiAhPT0ga2V5WzBdICYmXG4gICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoa2V5LCBvYmplY3Rba2V5XSwgcHJvcGVydGllcywgaW5kZW50LCBwcmVmaXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRWYWx1ZVRvUHJvcGVydGllcyhcbiAgICAgIHByb3BlcnR5TmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGluZGVudCxcbiAgICAgIHByZWZpeFxuICAgICkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBcIm51bGxcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkgfHwgXCJcXHUyMDI2XCIsXG4gICAgICAgICAgICAgICAga2V5ID0gdmFsdWUua2V5O1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJvcHNLZXlzID0gT2JqZWN0LmtleXModmFsdWUpLFxuICAgICAgICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHNLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT0ga2V5ICYmIDAgPT09IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjxcIiArIHR5cGVOYW1lICsgXCIgLz5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMyA+IGluZGVudCB8fFxuICAgICAgICAgICAgICAgICgxID09PSBwcm9wc0xlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiID09PSBwcm9wc0tleXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgPT0ga2V5KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiPFwiICsgdHlwZU5hbWUgKyBcIiBcXHUyMDI2IC8+XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgICAgICAgICBwcmVmaXggKyBcIlxcdTAwYTBcXHUwMGEwXCIucmVwZWF0KGluZGVudCkgKyBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgXCI8XCIgKyB0eXBlTmFtZVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0ga2V5ICYmXG4gICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICBcImtleVwiLFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgIGluZGVudCArIDEsXG4gICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSAhMTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCIgPT09IHByb3BLZXlcbiAgICAgICAgICAgICAgICAgID8gbnVsbCAhPSB2YWx1ZS5jaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgICAgICAoIWlzQXJyYXlJbXBsKHZhbHVlLmNoaWxkcmVuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIDAgPCB2YWx1ZS5jaGlsZHJlbi5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgICAgIChwcm9wZXJ0eU5hbWUgPSAhMClcbiAgICAgICAgICAgICAgICAgIDogaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcHJvcEtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJfXCIgIT09IHByb3BLZXlbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtwcm9wS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPyBcIj5cXHUyMDI2PC9cIiArIHR5cGVOYW1lICsgXCI+XCIgOiBcIi8+XCJcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWUuc2xpY2UoOCwgdHlwZU5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoXCJBcnJheVwiID09PSB0eXBlTmFtZSlcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgocHJvcEtleSA9IGdldEFycmF5S2luZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgIDIgPT09IHByb3BLZXkgfHwgMCA9PT0gcHJvcEtleSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gcHJvcEtleSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIlxcdTAwYTBcXHUwMGEwXCIucmVwZWF0KGluZGVudCkgKyBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IDA7XG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPCB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUrK1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICh0eXBlTmFtZSA9IHZhbHVlW3Byb3BlcnR5TmFtZV0pLFxuICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJQcm9taXNlXCIgPT09IHR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChcImZ1bGZpbGxlZFwiID09PSB2YWx1ZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoKHR5cGVOYW1lID0gcHJvcGVydGllcy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5sZW5ndGggPiB0eXBlTmFtZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzW3R5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbMV0gPVxuICAgICAgICAgICAgICAgICAgICBcIlByb21pc2U8XCIgKyAocHJvcGVydGllc1sxXSB8fCBcIk9iamVjdFwiKSArIFwiPlwiO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBcInJlamVjdGVkXCIgPT09IHZhbHVlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICgodHlwZU5hbWUgPSBwcm9wZXJ0aWVzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5yZWFzb24sXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgaW5kZW50LFxuICAgICAgICAgICAgICAgICAgcHJlZml4XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmxlbmd0aCA+IHR5cGVOYW1lKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllc1t0eXBlTmFtZV07XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1sxXSA9IFwiUmVqZWN0ZWQgUHJvbWlzZTxcIiArIHByb3BlcnRpZXNbMV0gKyBcIj5cIjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgICAgICAgICBcIlxcdTAwYTBcXHUwMGEwXCIucmVwZWF0KGluZGVudCkgKyBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlXCJcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IHR5cGVOYW1lICYmXG4gICAgICAgICAgICAgIChwcm9wS2V5ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSkgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvcEtleS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAodHlwZU5hbWUgPSBwcm9wS2V5LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgICAgICAgcHJlZml4ICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSB0eXBlTmFtZSA/ICgzID4gaW5kZW50ID8gXCJcIiA6IFwiXFx1MjAyNlwiKSA6IHR5cGVOYW1lXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIDMgPiBpbmRlbnQgJiZcbiAgICAgICAgICAgICAgYWRkT2JqZWN0VG9Qcm9wZXJ0aWVzKHZhbHVlLCBwcm9wZXJ0aWVzLCBpbmRlbnQgKyAxLCBwcmVmaXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgdmFsdWUgPSBcIlwiID09PSB2YWx1ZS5uYW1lID8gXCIoKSA9PiB7fVwiIDogdmFsdWUubmFtZSArIFwiKCkge31cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgIFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gb21pdHRlZCBieSBSZWFjdCBpbiB0aGUgY29uc29sZSBsb2cgdG8gYXZvaWQgc2VuZGluZyB0b28gbXVjaCBkYXRhIGZyb20gdGhlIHNlcnZlci4gVHJ5IGxvZ2dpbmcgc21hbGxlciBvciBtb3JlIHNwZWNpZmljIG9iamVjdHMuXCIgPT09XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICA/IFwiXFx1MjAyNlwiXG4gICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgdmFsdWUgPSBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICBwcmVmaXggKyBcIlxcdTAwYTBcXHUwMGEwXCIucmVwZWF0KGluZGVudCkgKyBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkT2JqZWN0RGlmZlRvUHJvcGVydGllcyhwcmV2LCBuZXh0LCBwcm9wZXJ0aWVzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBpc0RlZXBseUVxdWFsID0gITA7XG4gICAgICBmb3IgKGtleSBpbiBwcmV2KVxuICAgICAgICBrZXkgaW4gbmV4dCB8fFxuICAgICAgICAgIChwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICAgICAgXCJcXHUyMDEzXFx1MDBhMFwiICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsga2V5LFxuICAgICAgICAgICAgXCJcXHUyMDI2XCJcbiAgICAgICAgICBdKSxcbiAgICAgICAgICAoaXNEZWVwbHlFcXVhbCA9ICExKSk7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG5leHQpXG4gICAgICAgIGlmIChfa2V5IGluIHByZXYpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJldltfa2V5XTtcbiAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dFtfa2V5XTtcbiAgICAgICAgICBpZiAoa2V5ICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBpbmRlbnQgJiYgXCJjaGlsZHJlblwiID09PSBfa2V5KVxuICAgICAgICAgICAgICAoaXNEZWVwbHlFcXVhbCA9IFwiXFx1MDBhMFxcdTAwYTBcIi5yZXBlYXQoaW5kZW50KSArIF9rZXkpLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChcbiAgICAgICAgICAgICAgICAgIFtcIlxcdTIwMTNcXHUwMGEwXCIgKyBpc0RlZXBseUVxdWFsLCBcIlxcdTIwMjZcIl0sXG4gICAgICAgICAgICAgICAgICBbXCIrXFx1MDBhMFwiICsgaXNEZWVwbHlFcXVhbCwgXCJcXHUyMDI2XCJdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoISgzIDw9IGluZGVudCkpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGtleSAmJlxuICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5leHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0ga2V5ICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIGtleS4kJHR5cGVvZiA9PT0gbmV4dFZhbHVlLiQkdHlwZW9mXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgaWYgKG5leHRWYWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBrZXkudHlwZSA9PT0gbmV4dFZhbHVlLnR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBrZXkua2V5ID09PSBuZXh0VmFsdWUua2V5XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUobmV4dFZhbHVlLnR5cGUpIHx8IFwiXFx1MjAyNlwiO1xuICAgICAgICAgICAgICAgICAgICAgIGlzRGVlcGx5RXF1YWwgPSBcIlxcdTAwYTBcXHUwMGEwXCIucmVwZWF0KGluZGVudCkgKyBfa2V5O1xuICAgICAgICAgICAgICAgICAgICAgIGtleSA9IFwiPFwiICsga2V5ICsgXCIgXFx1MjAyNiAvPlwiO1xuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcIlxcdTIwMTNcXHUwMGEwXCIgKyBpc0RlZXBseUVxdWFsLCBrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiK1xcdTAwYTBcIiArIGlzRGVlcGx5RXF1YWwsIGtleV1cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGlzRGVlcGx5RXF1YWwgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZLaW5kID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dEtpbmQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIHByZXZLaW5kID09PSBuZXh0S2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBuZXh0S2luZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJbb2JqZWN0IEFycmF5XVwiID09PSBuZXh0S2luZClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJldktpbmQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdTIwMDdcXHUwMGEwXCIgKyBcIlxcdTAwYTBcXHUwMGEwXCIucmVwZWF0KGluZGVudCkgKyBfa2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJbb2JqZWN0IEFycmF5XVwiID09PSBuZXh0S2luZCA/IFwiQXJyYXlcIiA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcmV2S2luZCk7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dEtpbmQgPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPYmplY3REaWZmVG9Qcm9wZXJ0aWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArIDFcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5leHRLaW5kID09PSBwcm9wZXJ0aWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldktpbmRbMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVmZXJlbnRpYWxseSB1bmVxdWFsIGJ1dCBkZWVwbHkgZXF1YWwgb2JqZWN0cy4gQ29uc2lkZXIgbWVtb2l6YXRpb24uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChpc0RlZXBseUVxdWFsID0gITEpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBrZXkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5leHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAga2V5Lm5hbWUgPT09IG5leHRWYWx1ZS5uYW1lICYmXG4gICAgICAgICAgICAgICAgICBrZXkubGVuZ3RoID09PSBuZXh0VmFsdWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAoKHByZXZLaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoa2V5KSksXG4gICAgICAgICAgICAgICAgICAobmV4dEtpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXh0VmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgIHByZXZLaW5kID09PSBuZXh0S2luZClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGtleSA9XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IG5leHRWYWx1ZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgPyBcIigpID0+IHt9XCJcbiAgICAgICAgICAgICAgICAgICAgICA6IG5leHRWYWx1ZS5uYW1lICsgXCIoKSB7fVwiO1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHUyMDA3XFx1MDBhMFwiICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgX2tleSxcbiAgICAgICAgICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiBSZWZlcmVudGlhbGx5IHVuZXF1YWwgZnVuY3Rpb24gY2xvc3VyZS4gQ29uc2lkZXIgbWVtb2l6YXRpb24uXCJcbiAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICBfa2V5LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGluZGVudCxcbiAgICAgICAgICAgICAgICBcIlxcdTIwMTNcXHUwMGEwXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgX2tleSxcbiAgICAgICAgICAgICAgICBuZXh0VmFsdWUsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICAgICAgXCIrXFx1MDBhMFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0RlZXBseUVxdWFsID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICAgICAgXCIrXFx1MDBhMFwiICsgXCJcXHUwMGEwXFx1MDBhMFwiLnJlcGVhdChpbmRlbnQpICsgX2tleSxcbiAgICAgICAgICAgIFwiXFx1MjAyNlwiXG4gICAgICAgICAgXSksXG4gICAgICAgICAgICAoaXNEZWVwbHlFcXVhbCA9ICExKTtcbiAgICAgIHJldHVybiBpc0RlZXBseUVxdWFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDdXJyZW50VHJhY2tGcm9tTGFuZXMobGFuZXMpIHtcbiAgICAgIGN1cnJlbnRUcmFjayA9XG4gICAgICAgIGxhbmVzICYgNjNcbiAgICAgICAgICA/IFwiQmxvY2tpbmdcIlxuICAgICAgICAgIDogbGFuZXMgJiA2NFxuICAgICAgICAgICAgPyBcIkdlc3R1cmVcIlxuICAgICAgICAgICAgOiBsYW5lcyAmIDQxOTQxNzZcbiAgICAgICAgICAgICAgPyBcIlRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICA6IGxhbmVzICYgNjI5MTQ1NjBcbiAgICAgICAgICAgICAgICA/IFwiU3VzcGVuc2VcIlxuICAgICAgICAgICAgICAgIDogbGFuZXMgJiAyMDgwMzc0Nzg0XG4gICAgICAgICAgICAgICAgICA/IFwiSWRsZVwiXG4gICAgICAgICAgICAgICAgICA6IFwiT3RoZXJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ29tcG9uZW50VHJpZ2dlcihmaWJlciwgc3RhcnRUaW1lLCBlbmRUaW1lLCB0cmlnZ2VyKSB7XG4gICAgICBzdXBwb3J0c1VzZXJUaW1pbmcgJiZcbiAgICAgICAgKChyZXVzYWJsZUNvbXBvbmVudE9wdGlvbnMuc3RhcnQgPSBzdGFydFRpbWUpLFxuICAgICAgICAocmV1c2FibGVDb21wb25lbnRPcHRpb25zLmVuZCA9IGVuZFRpbWUpLFxuICAgICAgICAocmV1c2FibGVDb21wb25lbnREZXZUb29sRGV0YWlscy5jb2xvciA9IFwid2FybmluZ1wiKSxcbiAgICAgICAgKHJldXNhYmxlQ29tcG9uZW50RGV2VG9vbERldGFpbHMudG9vbHRpcFRleHQgPSB0cmlnZ2VyKSxcbiAgICAgICAgKHJldXNhYmxlQ29tcG9uZW50RGV2VG9vbERldGFpbHMucHJvcGVydGllcyA9IG51bGwpLFxuICAgICAgICAoZmliZXIgPSBmaWJlci5fZGVidWdUYXNrKVxuICAgICAgICAgID8gZmliZXIucnVuKFxuICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQoXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICAgICAgICByZXVzYWJsZUNvbXBvbmVudE9wdGlvbnNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogcGVyZm9ybWFuY2UubWVhc3VyZSh0cmlnZ2VyLCByZXVzYWJsZUNvbXBvbmVudE9wdGlvbnMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ29tcG9uZW50UmVhcHBlYXJlZChmaWJlciwgc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gICAgICBsb2dDb21wb25lbnRUcmlnZ2VyKGZpYmVyLCBzdGFydFRpbWUsIGVuZFRpbWUsIFwiUmVjb25uZWN0XCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dDb21wb25lbnRSZW5kZXIoXG4gICAgICBmaWJlcixcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICB3YXNIeWRyYXRlZCxcbiAgICAgIGNvbW1pdHRlZExhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuICAgICAgaWYgKG51bGwgIT09IG5hbWUgJiYgc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgICAgc2VsZlRpbWUgPSBmaWJlci5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgaWYgKG51bGwgPT09IGFsdGVybmF0ZSB8fCBhbHRlcm5hdGUuY2hpbGQgIT09IGZpYmVyLmNoaWxkKVxuICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyBjaGlsZCA9IGNoaWxkLnNpYmxpbmcpXG4gICAgICAgICAgICBzZWxmVGltZSAtPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgd2FzSHlkcmF0ZWQgPVxuICAgICAgICAgIDAuNSA+IHNlbGZUaW1lXG4gICAgICAgICAgICA/IHdhc0h5ZHJhdGVkXG4gICAgICAgICAgICAgID8gXCJ0ZXJ0aWFyeS1saWdodFwiXG4gICAgICAgICAgICAgIDogXCJwcmltYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgIDogMTAgPiBzZWxmVGltZVxuICAgICAgICAgICAgICA/IHdhc0h5ZHJhdGVkXG4gICAgICAgICAgICAgICAgPyBcInRlcnRpYXJ5XCJcbiAgICAgICAgICAgICAgICA6IFwicHJpbWFyeVwiXG4gICAgICAgICAgICAgIDogMTAwID4gc2VsZlRpbWVcbiAgICAgICAgICAgICAgICA/IHdhc0h5ZHJhdGVkXG4gICAgICAgICAgICAgICAgICA/IFwidGVydGlhcnktZGFya1wiXG4gICAgICAgICAgICAgICAgICA6IFwicHJpbWFyeS1kYXJrXCJcbiAgICAgICAgICAgICAgICA6IFwiZXJyb3JcIjtcbiAgICAgICAgdmFyIHByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgc2VsZlRpbWUgPSBmaWJlci5fZGVidWdUYXNrO1xuICAgICAgICBudWxsICE9PSBwcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgYWx0ZXJuYXRlLm1lbW9pemVkUHJvcHMgIT09IHByb3BzXG4gICAgICAgICAgPyAoKGNoaWxkID0gW3Jlc3VhYmxlQ2hhbmdlZFByb3BzRW50cnldKSxcbiAgICAgICAgICAgIChwcm9wcyA9IGFkZE9iamVjdERpZmZUb1Byb3BlcnRpZXMoXG4gICAgICAgICAgICAgIGFsdGVybmF0ZS5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgMSA8IGNoaWxkLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAocHJvcHMgJiZcbiAgICAgICAgICAgICAgIWFscmVhZHlXYXJuZWRGb3JEZWVwRXF1YWxpdHkgJiZcbiAgICAgICAgICAgICAgMCA9PT0gKGFsdGVybmF0ZS5sYW5lcyAmIGNvbW1pdHRlZExhbmVzKSAmJlxuICAgICAgICAgICAgICAxMDAgPCBmaWJlci5hY3R1YWxEdXJhdGlvblxuICAgICAgICAgICAgICAgID8gKChhbHJlYWR5V2FybmVkRm9yRGVlcEVxdWFsaXR5ID0gITApLFxuICAgICAgICAgICAgICAgICAgKGNoaWxkWzBdID0gcmV1c2FibGVEZWVwbHlFcXVhbFByb3BzRW50cnkpLFxuICAgICAgICAgICAgICAgICAgKHJldXNhYmxlQ29tcG9uZW50RGV2VG9vbERldGFpbHMuY29sb3IgPSBcIndhcm5pbmdcIiksXG4gICAgICAgICAgICAgICAgICAocmV1c2FibGVDb21wb25lbnREZXZUb29sRGV0YWlscy50b29sdGlwVGV4dCA9XG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyBjb21wb25lbnQgcmVjZWl2ZWQgZGVlcGx5IGVxdWFsIHByb3BzLiBJdCBtaWdodCBiZW5lZml0IGZyb20gdXNlTWVtbyBvciB0aGUgUmVhY3QgQ29tcGlsZXIgaW4gaXRzIG93bmVyLlwiKSlcbiAgICAgICAgICAgICAgICA6ICgocmV1c2FibGVDb21wb25lbnREZXZUb29sRGV0YWlscy5jb2xvciA9IHdhc0h5ZHJhdGVkKSxcbiAgICAgICAgICAgICAgICAgIChyZXVzYWJsZUNvbXBvbmVudERldlRvb2xEZXRhaWxzLnRvb2x0aXBUZXh0ID0gbmFtZSkpLFxuICAgICAgICAgICAgICAocmV1c2FibGVDb21wb25lbnREZXZUb29sRGV0YWlscy5wcm9wZXJ0aWVzID0gY2hpbGQpLFxuICAgICAgICAgICAgICAocmV1c2FibGVDb21wb25lbnRPcHRpb25zLnN0YXJ0ID0gc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgKHJldXNhYmxlQ29tcG9uZW50T3B0aW9ucy5lbmQgPSBlbmRUaW1lKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBzZWxmVGltZVxuICAgICAgICAgICAgICAgID8gc2VsZlRpbWUucnVuKFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgXCJcXHUyMDBiXCIgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHJldXNhYmxlQ29tcG9uZW50T3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgICAgICAgICAgICAgICBcIlxcdTIwMGJcIiArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJldXNhYmxlQ29tcG9uZW50T3B0aW9uc1xuICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgOiBudWxsICE9IHNlbGZUaW1lXG4gICAgICAgICAgICA/IHNlbGZUaW1lLnJ1bihcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHdhc0h5ZHJhdGVkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgd2FzSHlkcmF0ZWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ29tcG9uZW50RXJyb3JlZChmaWJlciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBlcnJvcnMpIHtcbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5hbWUpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIGRlYnVnVGFzayA9IG51bGwsIHByb3BlcnRpZXMgPSBbXSwgaSA9IDA7XG4gICAgICAgICAgICBpIDwgZXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmVkVmFsdWUgPSBlcnJvcnNbaV07XG4gICAgICAgICAgICBudWxsID09IGRlYnVnVGFzayAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjYXB0dXJlZFZhbHVlLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAoZGVidWdUYXNrID0gY2FwdHVyZWRWYWx1ZS5zb3VyY2UuX2RlYnVnVGFzayk7XG4gICAgICAgICAgICBjYXB0dXJlZFZhbHVlID0gY2FwdHVyZWRWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbXG4gICAgICAgICAgICAgIFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNhcHR1cmVkVmFsdWUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY2FwdHVyZWRWYWx1ZSAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2FwdHVyZWRWYWx1ZS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcoY2FwdHVyZWRWYWx1ZS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIDogU3RyaW5nKGNhcHR1cmVkVmFsdWUpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPT0gZmliZXIua2V5ICYmXG4gICAgICAgICAgICBhZGRWYWx1ZVRvUHJvcGVydGllcyhcImtleVwiLCBmaWJlci5rZXksIHByb3BlcnRpZXMsIDAsIFwiXCIpO1xuICAgICAgICAgIG51bGwgIT09IGZpYmVyLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgIGFkZE9iamVjdFRvUHJvcGVydGllcyhmaWJlci5tZW1vaXplZFByb3BzLCBwcm9wZXJ0aWVzLCAwLCBcIlwiKTtcbiAgICAgICAgICBudWxsID09IGRlYnVnVGFzayAmJiAoZGVidWdUYXNrID0gZmliZXIuX2RlYnVnVGFzayk7XG4gICAgICAgICAgZmliZXIgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kOiBlbmRUaW1lLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgIGRldnRvb2xzOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0cmFjazogXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICB0b29sdGlwVGV4dDpcbiAgICAgICAgICAgICAgICAgIDEzID09PSBmaWJlci50YWdcbiAgICAgICAgICAgICAgICAgICAgPyBcIkh5ZHJhdGlvbiBmYWlsZWRcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiRXJyb3IgYm91bmRhcnkgY2F1Z2h0IGFuIGVycm9yXCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQocGVyZm9ybWFuY2UsIFwiXFx1MjAwYlwiICsgbmFtZSwgZmliZXIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogcGVyZm9ybWFuY2UubWVhc3VyZShcIlxcdTIwMGJcIiArIG5hbWUsIGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dDb21wb25lbnRFZmZlY3QoZmliZXIsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2VsZlRpbWUsIGVycm9ycykge1xuICAgICAgaWYgKG51bGwgIT09IGVycm9ycykge1xuICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gbmFtZSkge1xuICAgICAgICAgICAgc2VsZlRpbWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yc1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgc2VsZlRpbWUucHVzaChbXG4gICAgICAgICAgICAgICAgXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudWxsICE9PSBmaWJlci5rZXkgJiZcbiAgICAgICAgICAgICAgYWRkVmFsdWVUb1Byb3BlcnRpZXMoXCJrZXlcIiwgZmliZXIua2V5LCBzZWxmVGltZSwgMCwgXCJcIik7XG4gICAgICAgICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgIGFkZE9iamVjdFRvUHJvcGVydGllcyhmaWJlci5tZW1vaXplZFByb3BzLCBzZWxmVGltZSwgMCwgXCJcIik7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZDogZW5kVGltZSxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICB0cmFjazogXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBcIkEgbGlmZWN5Y2xlIG9yIGVmZmVjdCBlcnJvcmVkXCIsXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBzZWxmVGltZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLl9kZWJ1Z1Rhc2spXG4gICAgICAgICAgICAgID8gZmliZXIucnVuKFxuICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZS5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgXCJcXHUyMDBiXCIgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcGVyZm9ybWFuY2UubWVhc3VyZShcIlxcdTIwMGJcIiArIG5hbWUsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgKG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSksXG4gICAgICAgICAgbnVsbCAhPT0gbmFtZSAmJlxuICAgICAgICAgICAgc3VwcG9ydHNVc2VyVGltaW5nICYmXG4gICAgICAgICAgICAoKGVycm9ycyA9XG4gICAgICAgICAgICAgIDEgPiBzZWxmVGltZVxuICAgICAgICAgICAgICAgID8gXCJzZWNvbmRhcnktbGlnaHRcIlxuICAgICAgICAgICAgICAgIDogMTAwID4gc2VsZlRpbWVcbiAgICAgICAgICAgICAgICAgID8gXCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgICAgOiA1MDAgPiBzZWxmVGltZVxuICAgICAgICAgICAgICAgICAgICA/IFwic2Vjb25kYXJ5LWRhcmtcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZXJyb3JcIiksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5fZGVidWdUYXNrKVxuICAgICAgICAgICAgICA/IGZpYmVyLnJ1bihcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIFwiQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nUmVuZGVyUGhhc2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBsYW5lcywgZGVidWdUYXNrKSB7XG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICEoZW5kVGltZSA8PSBzdGFydFRpbWUpKSB7XG4gICAgICAgIHZhciBjb2xvciA9XG4gICAgICAgICAgKGxhbmVzICYgNzM4MTk3NjUzKSA9PT0gbGFuZXMgPyBcInRlcnRpYXJ5LWRhcmtcIiA6IFwicHJpbWFyeS1kYXJrXCI7XG4gICAgICAgIGxhbmVzID1cbiAgICAgICAgICAobGFuZXMgJiA1MzY4NzA5MTIpID09PSBsYW5lc1xuICAgICAgICAgICAgPyBcIlByZXBhcmVkXCJcbiAgICAgICAgICAgIDogKGxhbmVzICYgMjAxMzI2NzQxKSA9PT0gbGFuZXNcbiAgICAgICAgICAgICAgPyBcIkh5ZHJhdGVkXCJcbiAgICAgICAgICAgICAgOiBcIlJlbmRlclwiO1xuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wLmJpbmQoXG4gICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgIGNvbG9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgY29sb3JcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1N1c3BlbmRlZFJlbmRlclBoYXNlKHN0YXJ0VGltZSwgZW5kVGltZSwgbGFuZXMsIGRlYnVnVGFzaykge1xuICAgICAgIXN1cHBvcnRzVXNlclRpbWluZyB8fFxuICAgICAgICBlbmRUaW1lIDw9IHN0YXJ0VGltZSB8fFxuICAgICAgICAoKGxhbmVzID1cbiAgICAgICAgICAobGFuZXMgJiA3MzgxOTc2NTMpID09PSBsYW5lcyA/IFwidGVydGlhcnktZGFya1wiIDogXCJwcmltYXJ5LWRhcmtcIiksXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgIFwiUHJld2FybVwiLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgIFwiUHJld2FybVwiLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1N1c3BlbmRlZFdpdGhEZWxheVBoYXNlKHN0YXJ0VGltZSwgZW5kVGltZSwgbGFuZXMsIGRlYnVnVGFzaykge1xuICAgICAgIXN1cHBvcnRzVXNlclRpbWluZyB8fFxuICAgICAgICBlbmRUaW1lIDw9IHN0YXJ0VGltZSB8fFxuICAgICAgICAoKGxhbmVzID1cbiAgICAgICAgICAobGFuZXMgJiA3MzgxOTc2NTMpID09PSBsYW5lcyA/IFwidGVydGlhcnktZGFya1wiIDogXCJwcmltYXJ5LWRhcmtcIiksXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgIFwiU3VzcGVuZGVkXCIsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgXCJTdXNwZW5kZWRcIixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dSZWNvdmVyZWRSZW5kZXJQaGFzZShcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBsYW5lcyxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgaHlkcmF0aW9uRmFpbGVkLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICEoZW5kVGltZSA8PSBzdGFydFRpbWUpKSB7XG4gICAgICAgIGxhbmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSByZWNvdmVyYWJsZUVycm9yc1tpXS52YWx1ZTtcbiAgICAgICAgICBsYW5lcy5wdXNoKFtcbiAgICAgICAgICAgIFwiUmVjb3ZlcmFibGUgRXJyb3JcIixcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0VGltZSA9IHtcbiAgICAgICAgICBzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgIGVuZDogZW5kVGltZSxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGRldnRvb2xzOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBcInByaW1hcnktZGFya1wiLFxuICAgICAgICAgICAgICB0cmFjazogY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICB0cmFja0dyb3VwOiBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBoeWRyYXRpb25GYWlsZWRcbiAgICAgICAgICAgICAgICA/IFwiSHlkcmF0aW9uIEZhaWxlZFwiXG4gICAgICAgICAgICAgICAgOiBcIlJlY292ZXJlZCBhZnRlciBFcnJvclwiLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBsYW5lc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQocGVyZm9ybWFuY2UsIFwiUmVjb3ZlcmVkXCIsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHBlcmZvcm1hbmNlLm1lYXN1cmUoXCJSZWNvdmVyZWRcIiwgc3RhcnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nRXJyb3JlZFJlbmRlclBoYXNlKHN0YXJ0VGltZSwgZW5kVGltZSwgbGFuZXMsIGRlYnVnVGFzaykge1xuICAgICAgIXN1cHBvcnRzVXNlclRpbWluZyB8fFxuICAgICAgICBlbmRUaW1lIDw9IHN0YXJ0VGltZSB8fFxuICAgICAgICAoZGVidWdUYXNrXG4gICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgXCJFcnJvcmVkXCIsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgIFwiRXJyb3JlZFwiLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dTdXNwZW5kZWRDb21taXRQaGFzZShzdGFydFRpbWUsIGVuZFRpbWUsIHJlYXNvbiwgZGVidWdUYXNrKSB7XG4gICAgICAhc3VwcG9ydHNVc2VyVGltaW5nIHx8XG4gICAgICAgIGVuZFRpbWUgPD0gc3RhcnRUaW1lIHx8XG4gICAgICAgIChkZWJ1Z1Rhc2tcbiAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wLmJpbmQoXG4gICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICBcInNlY29uZGFyeS1saWdodFwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgIFwic2Vjb25kYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dDb21taXRFcnJvcmVkKHN0YXJ0VGltZSwgZW5kVGltZSwgZXJyb3JzLCBwYXNzaXZlLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcgJiYgIShlbmRUaW1lIDw9IHN0YXJ0VGltZSkpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydGllcyA9IFtdLCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yc1tpXS52YWx1ZTtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW1xuICAgICAgICAgICAgXCJFcnJvclwiLFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRUaW1lID0ge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgZW5kOiBlbmRUaW1lLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICAgICAgY29sb3I6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgdHJhY2s6IGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgdHJhY2tHcm91cDogXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICB0b29sdGlwVGV4dDogcGFzc2l2ZVxuICAgICAgICAgICAgICAgID8gXCJSZW1haW5pbmcgRWZmZWN0cyBFcnJvcmVkXCJcbiAgICAgICAgICAgICAgICA6IFwiQ29tbWl0IEVycm9yZWRcIixcbiAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQocGVyZm9ybWFuY2UsIFwiRXJyb3JlZFwiLCBzdGFydFRpbWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBwZXJmb3JtYW5jZS5tZWFzdXJlKFwiRXJyb3JlZFwiLCBzdGFydFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdE93bmVyU3RhY2soZXJyb3IpIHtcbiAgICAgIHZhciBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgZXJyb3IgPSBlcnJvci5zdGFjaztcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldlByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgZXJyb3Iuc3RhcnRzV2l0aChcIkVycm9yOiByZWFjdC1zdGFjay10b3AtZnJhbWVcXG5cIikgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UoMjkpKTtcbiAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlICYmXG4gICAgICAgIChlcnJvciA9IGVycm9yLnNsaWNlKHByZXZQcmVwYXJlU3RhY2tUcmFjZSArIDEpKTtcbiAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmluZGV4T2YoXCJyZWFjdF9zdGFja19ib3R0b21fZnJhbWVcIik7XG4gICAgICAtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlICYmXG4gICAgICAgIChwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBlcnJvci5sYXN0SW5kZXhPZihcbiAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZVxuICAgICAgICApKTtcbiAgICAgIGlmICgtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlKVxuICAgICAgICBlcnJvciA9IGVycm9yLnNsaWNlKDAsIHByZXZQcmVwYXJlU3RhY2tUcmFjZSk7XG4gICAgICBlbHNlIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyLCBjaGlsZEZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIkxhenlcIik7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIGZpYmVyLmNoaWxkICE9PSBjaGlsZEZpYmVyICYmIG51bGwgIT09IGNoaWxkRmliZXJcbiAgICAgICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZSBGYWxsYmFja1wiKVxuICAgICAgICAgICAgOiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICExKTtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlciwgITEpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSwgITApO1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIkFjdGl2aXR5XCIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIixcbiAgICAgICAgICBwcmV2aW91cyA9IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya0luUHJvZ3Jlc3MsIHByZXZpb3VzKTtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZW50cnkubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvO1xuICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZW50cnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZW52ID0gZW50cnkuZW52LFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGVudHJ5LmRlYnVnTG9jYXRpb247XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRTdGFjayA9IGZvcm1hdE93bmVyU3RhY2sobG9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGNoaWxkU3RhY2subGFzdEluZGV4T2YoXCJcXG5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdExpbmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT09IGlkeCA/IGNoaWxkU3RhY2sgOiBjaGlsZFN0YWNrLnNsaWNlKGlkeCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGxhc3RMaW5lLmluZGV4T2YobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gXCJcXG5cIiArIGxhc3RMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICAgICAgICBuYW1lICsgKGVudiA/IFwiIFtcIiArIGVudiArIFwiXVwiIDogXCJcIilcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZm8gPSBKU0NvbXBpbGVyX3RlbXBfY29uc3QgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91cyA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWVXaXRob3V0TGluZU51bWJlcihmbikge1xuICAgICAgcmV0dXJuIChmbiA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZm4pXG4gICAgICAgIDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgICB9O1xuICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya0NvdW50O1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHRyZWVGb3JrQ291bnQgPSB0b3RhbENoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICB0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCAoMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGgpKSB8XG4gICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdDtcbiAgICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IGxlbmd0aCArIHdvcmtJblByb2dyZXNzO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCBsZW5ndGgpIHwgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHwgYmFzZUlkV2l0aExlYWRpbmdCaXQpLFxuICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLnJldHVybiAmJlxuICAgICAgICAocHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCAxKSwgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgMSwgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyOyApXG4gICAgICAgICh0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpO1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlQ29udGV4dFByb3ZpZGVyOyApXG4gICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgcmV0dXJuIG51bGwgIT09IHRyZWVDb250ZXh0UHJvdmlkZXJcbiAgICAgICAgPyB7IGlkOiB0cmVlQ29udGV4dElkLCBvdmVyZmxvdzogdHJlZUNvbnRleHRPdmVyZmxvdyB9XG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5kZWRDb250ZXh0KSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgICAgIHRyZWVDb250ZXh0SWQgPSBzdXNwZW5kZWRDb250ZXh0LmlkO1xuICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IHN1c3BlbmRlZENvbnRleHQub3ZlcmZsb3c7XG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpIHtcbiAgICAgIGlzSHlkcmF0aW5nIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgICBudWxsID09PSBjICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBudWxsLCBmaWJlcik7XG4gICAgICBuZXh0Um9vdEluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIHB1c2goaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpO1xuICAgICAgY29udGV4dCAhPT0gbmV4dENvbnRleHQgJiZcbiAgICAgICAgKHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAgIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlciksIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpKTtcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAgICAgKHBvcChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciksXG4gICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgPyAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBOb3RQZW5kaW5nVHJhbnNpdGlvbilcbiAgICAgICAgICA6IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBOb3RQZW5kaW5nVHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzICYmXG4gICAgICAgIDAgPT09IG5vZGUuc2VydmVyVGFpbC5sZW5ndGggJiZcbiAgICAgICAgMSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgMyA8IG5vZGUuZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICBub2RlLmRpc3RhbmNlRnJvbUxlYWYgPiAxNSAtIGluZGVudFxuICAgICAgICA/IGZpbmROb3RhYmxlTm9kZShub2RlLmNoaWxkcmVuWzBdLCBpbmRlbnQpXG4gICAgICAgIDogbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZW50YXRpb24oaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIgIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRlZChpbmRlbnQpIHtcbiAgICAgIHJldHVybiBcIisgXCIgKyBcIiAgXCIucmVwZWF0KGluZGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCItIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZpYmVyVHlwZShmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBmaWJlci50eXBlO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBcIkxhenlcIjtcbiAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZmliZXIudHlwZSksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIudHlwZS5yZW5kZXIpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGZpYmVyLnR5cGUpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVGV4dE5vZGUoY29udGVudCwgbWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmVlZHNFc2NhcGluZy50ZXN0KGNvbnRlbnQpXG4gICAgICAgID8gKChjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY29udGVudCkpLFxuICAgICAgICAgIGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMlxuICAgICAgICAgICAgPyA4ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgID8gJ3tcIi4uLlwifSdcbiAgICAgICAgICAgICAgOiBcIntcIiArIGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNykgKyAnLi4uXCJ9J1xuICAgICAgICAgICAgOiBcIntcIiArIGNvbnRlbnQgKyBcIn1cIilcbiAgICAgICAgOiBjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aFxuICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgPyAne1wiLi4uXCJ9J1xuICAgICAgICAgICAgOiBjb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCAtIDMpICsgXCIuLi5cIlxuICAgICAgICAgIDogY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVUZXh0RGlmZihjbGllbnRUZXh0LCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGluZGVudDtcbiAgICAgIGlmIChudWxsID09PSBzZXJ2ZXJQcm9wcylcbiAgICAgICAgcmV0dXJuIGFkZGVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyBcIlxcblwiO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJQcm9wcykge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBmaXJzdERpZmYgPSAwO1xuICAgICAgICAgIGZpcnN0RGlmZiA8IHNlcnZlclByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGZpcnN0RGlmZiA8IGNsaWVudFRleHQubGVuZ3RoICYmXG4gICAgICAgICAgc2VydmVyUHJvcHMuY2hhckNvZGVBdChmaXJzdERpZmYpID09PVxuICAgICAgICAgICAgY2xpZW50VGV4dC5jaGFyQ29kZUF0KGZpcnN0RGlmZik7XG4gICAgICAgICAgZmlyc3REaWZmKytcbiAgICAgICAgKTtcbiAgICAgICAgZmlyc3REaWZmID4gbWF4TGVuZ3RoIC0gOCAmJlxuICAgICAgICAgIDEwIDwgZmlyc3REaWZmICYmXG4gICAgICAgICAgKChjbGllbnRUZXh0ID0gXCIuLi5cIiArIGNsaWVudFRleHQuc2xpY2UoZmlyc3REaWZmIC0gOCkpLFxuICAgICAgICAgIChzZXJ2ZXJQcm9wcyA9IFwiLi4uXCIgKyBzZXJ2ZXJQcm9wcy5zbGljZShmaXJzdERpZmYgLSA4KSkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGFkZGVkKGluZGVudCkgK1xuICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICtcbiAgICAgICAgICBkZXNjcmliZVRleHROb2RlKHNlcnZlclByb3BzLCBtYXhMZW5ndGgpICtcbiAgICAgICAgICBcIlxcblwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgXCJcXG5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgIC5jYWxsKG9iamVjdClcbiAgICAgICAgLnJlcGxhY2UoL15cXFtvYmplY3QgKC4qKVxcXSQvLCBmdW5jdGlvbiAobSwgcDApIHtcbiAgICAgICAgICByZXR1cm4gcDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSxcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aFxuICAgICAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgICA/ICdcIi4uLlwiJ1xuICAgICAgICAgICAgICAgIDogdmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNCkgKyAnLi4uXCInXG4gICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKG51bGwgPT09IHZhbHVlKSByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiAobWF4TGVuZ3RoID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHZhbHVlLnR5cGUpKVxuICAgICAgICAgICAgICA/IFwiPFwiICsgbWF4TGVuZ3RoICsgXCI+XCJcbiAgICAgICAgICAgICAgOiBcIjwuLi4+XCI7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcbiAgICAgICAgICBpZiAoXCJPYmplY3RcIiA9PT0gbmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBtYXhMZW5ndGggLT0gMjtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHZhbHVlKVxuICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25Qcm9wTmFtZSA9IEpTT04uc3RyaW5naWZ5KHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBqc29uUHJvcE5hbWUgIT09ICdcIicgKyBwcm9wTmFtZSArICdcIicgJiZcbiAgICAgICAgICAgICAgICAgIChwcm9wTmFtZSA9IGpzb25Qcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAganNvblByb3BOYW1lID0gZGVzY3JpYmVWYWx1ZShcbiAgICAgICAgICAgICAgICAgIHZhbHVlW3Byb3BOYW1lXSxcbiAgICAgICAgICAgICAgICAgIDE1ID4gbWF4TGVuZ3RoID8gbWF4TGVuZ3RoIDogMTVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCAtPSBqc29uUHJvcE5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICgwID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBuYW1lICs9IFwiXCIgPT09IG5hbWUgPyBcIi4uLlwiIDogXCIsIC4uLlwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWUgKz1cbiAgICAgICAgICAgICAgICAgIChcIlwiID09PSBuYW1lID8gXCJcIiA6IFwiLFwiKSArIHByb3BOYW1lICsgXCI6XCIgKyBqc29uUHJvcE5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIntcIiArIG5hbWUgKyBcIn1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiAobWF4TGVuZ3RoID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgID8gXCJmdW5jdGlvbiBcIiArIG1heExlbmd0aFxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlUHJvcFZhbHVlKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWUgfHwgbmVlZHNFc2NhcGluZy50ZXN0KHZhbHVlKVxuICAgICAgICA/IFwie1wiICsgZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoIC0gMikgKyBcIn1cIlxuICAgICAgICA6IHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCAtIDJcbiAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgID8gJ1wiLi4uXCInXG4gICAgICAgICAgICA6ICdcIicgKyB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA1KSArICcuLi5cIidcbiAgICAgICAgICA6ICdcIicgKyB2YWx1ZSArICdcIic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIHByb3BzLCByb3dQcmVmaXgpIHtcbiAgICAgIHZhciByZW1haW5pbmdSb3dMZW5ndGggPSAxMjAgLSByb3dQcmVmaXgubGVuZ3RoIC0gdHlwZS5sZW5ndGgsXG4gICAgICAgIHByb3BlcnRpZXMgPSBbXSxcbiAgICAgICAgcHJvcE5hbWU7XG4gICAgICBmb3IgKHByb3BOYW1lIGluIHByb3BzKVxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0sXG4gICAgICAgICAgICAxMjAgLSByb3dQcmVmaXgubGVuZ3RoIC0gcHJvcE5hbWUubGVuZ3RoIC0gMVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVtYWluaW5nUm93TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wTmFtZSArIFwiPVwiICsgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIDAgPT09IHByb3BlcnRpZXMubGVuZ3RoXG4gICAgICAgID8gcm93UHJlZml4ICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCJcbiAgICAgICAgOiAwIDwgcmVtYWluaW5nUm93TGVuZ3RoXG4gICAgICAgICAgPyByb3dQcmVmaXggKyBcIjxcIiArIHR5cGUgKyBcIiBcIiArIHByb3BlcnRpZXMuam9pbihcIiBcIikgKyBcIj5cXG5cIlxuICAgICAgICAgIDogcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCIgIFwiICtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuam9pbihcIlxcblwiICsgcm93UHJlZml4ICsgXCIgIFwiKSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIj5cXG5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihjbGllbnRPYmplY3QsIHNlcnZlck9iamVjdCwgaW5kZW50KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFwiXCIsXG4gICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMgPSBhc3NpZ24oe30sIHNlcnZlck9iamVjdCksXG4gICAgICAgIHByb3BOYW1lO1xuICAgICAgZm9yIChwcm9wTmFtZSBpbiBjbGllbnRPYmplY3QpXG4gICAgICAgIGlmIChjbGllbnRPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogaW5kZW50IC0gcHJvcE5hbWUubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoY2xpZW50T2JqZWN0W3Byb3BOYW1lXSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICBzZXJ2ZXJPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpXG4gICAgICAgICAgICA/ICgobWF4TGVuZ3RoID0gZGVzY3JpYmVWYWx1ZShzZXJ2ZXJPYmplY3RbcHJvcE5hbWVdLCBtYXhMZW5ndGgpKSxcbiAgICAgICAgICAgICAgKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRQcm9wVmFsdWUgKyBcIlxcblwiKSxcbiAgICAgICAgICAgICAgKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIG1heExlbmd0aCArIFwiXFxuXCIpKVxuICAgICAgICAgICAgOiAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudFByb3BWYWx1ZSArIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gcmVtYWluaW5nU2VydmVyUHJvcGVydGllcylcbiAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpICYmXG4gICAgICAgICAgKChjbGllbnRPYmplY3QgPSBkZXNjcmliZVZhbHVlKFxuICAgICAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1tfcHJvcE5hbWVdLFxuICAgICAgICAgICAgMTIwIC0gMiAqIGluZGVudCAtIF9wcm9wTmFtZS5sZW5ndGggLSAyXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArIF9wcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudE9iamVjdCArIFwiXFxuXCIpKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUVsZW1lbnREaWZmKHR5cGUsIGNsaWVudFByb3BzLCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCIsXG4gICAgICAgIHNlcnZlclByb3BOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAocHJvcE5hbWUkanNjb21wJDAgaW4gc2VydmVyUHJvcHMpXG4gICAgICAgIHNlcnZlclByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lJGpzY29tcCQwKSAmJlxuICAgICAgICAgIHNlcnZlclByb3BOYW1lcy5zZXQoXG4gICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgaWYgKDEgPT09IHNlcnZlclByb3BOYW1lcy5zaXplICYmIHNlcnZlclByb3BOYW1lcy5oYXMoXCJjaGlsZHJlblwiKSlcbiAgICAgICAgY29udGVudCArPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGNsaWVudFByb3BzLFxuICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudClcbiAgICAgICAgKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUyIGluIGNsaWVudFByb3BzKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNsaWVudFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZTIpICYmXG4gICAgICAgICAgICBcImNoaWxkcmVuXCIgIT09IF9wcm9wTmFtZTJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBtYXhMZW5ndGgkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIDEyMCAtIDIgKiAoaW5kZW50ICsgMSkgLSBfcHJvcE5hbWUyLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lID0gc2VydmVyUHJvcE5hbWVzLmdldChfcHJvcE5hbWUyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gc2VydmVyUHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWVzLmRlbGV0ZShfcHJvcE5hbWUyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUkanNjb21wJDAgPSBjbGllbnRQcm9wc1tfcHJvcE5hbWUyXTtcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wc1tzZXJ2ZXJQcm9wTmFtZV07XG4gICAgICAgICAgICAgIHZhciBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wTmFtZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBwcm9wTmFtZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygc2VydmVyUHJvcE5hbWUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gc2VydmVyUHJvcE5hbWUgJiZcbiAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gb2JqZWN0TmFtZShwcm9wTmFtZSRqc2NvbXAkMCkgJiZcbiAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gb2JqZWN0TmFtZShzZXJ2ZXJQcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgKDIgPCBPYmplY3Qua2V5cyhwcm9wTmFtZSRqc2NvbXAkMCkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgMiA8IE9iamVjdC5rZXlzKHNlcnZlclByb3BOYW1lKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAtMSA8IGNsaWVudFByb3BWYWx1ZS5pbmRleE9mKFwiLi4uXCIpIHx8XG4gICAgICAgICAgICAgICAgLTEgPCBtYXhMZW5ndGgkanNjb21wJDAuaW5kZXhPZihcIi4uLlwiKSlcbiAgICAgICAgICAgICAgICA/IChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgICAgIFwiPXt7XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZVByb3BlcnRpZXNEaWZmKFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArIDJcbiAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCJ9fVxcblwiKVxuICAgICAgICAgICAgICAgIDogKChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UHJvcFZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiksXG4gICAgICAgICAgICAgICAgICAoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5cIikpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlUHJvcFZhbHVlKGNsaWVudFByb3BzW19wcm9wTmFtZTJdLCBtYXhMZW5ndGgkanNjb21wJDApICtcbiAgICAgICAgICAgICAgICBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgc2VydmVyUHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgaWYgKFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogKGluZGVudCArIDEpIC0gcHJvcE5hbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgIHByb3BOYW1lICtcbiAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICBkZXNjcmliZVByb3BWYWx1ZShzZXJ2ZXJQcm9wc1twcm9wTmFtZV0sIG1heExlbmd0aCkgK1xuICAgICAgICAgICAgICBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQgPVxuICAgICAgICAgIFwiXCIgPT09IGNvbnRlbnRcbiAgICAgICAgICAgID8gaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiXG4gICAgICAgICAgICA6IGluZGVudGF0aW9uKGluZGVudCkgK1xuICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgY29udGVudCArXG4gICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgK1xuICAgICAgICAgICAgICBcIj5cXG5cIjtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSBzZXJ2ZXJQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGNsaWVudFByb3BzID0gY2xpZW50UHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICApIHtcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gXCJcIjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBjbGllbnRQcm9wc1xuICAgICAgICApXG4gICAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gXCJcIiArIGNsaWVudFByb3BzO1xuICAgICAgICBjb250ZW50ICs9IGRlc2NyaWJlVGV4dERpZmYoc2VydmVyUHJvcE5hbWVzLCBcIlwiICsgdHlwZSwgaW5kZW50ICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBjbGllbnRQcm9wc1xuICAgICAgKVxuICAgICAgICBjb250ZW50ID1cbiAgICAgICAgICBudWxsID09IHR5cGVcbiAgICAgICAgICAgID8gY29udGVudCArIGRlc2NyaWJlVGV4dERpZmYoXCJcIiArIGNsaWVudFByb3BzLCBudWxsLCBpbmRlbnQgKyAxKVxuICAgICAgICAgICAgOiBjb250ZW50ICsgZGVzY3JpYmVUZXh0RGlmZihcIlwiICsgY2xpZW50UHJvcHMsIHZvaWQgMCwgaW5kZW50ICsgMSk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkge1xuICAgICAgdmFyIHR5cGUgPSBkZXNjcmliZUZpYmVyVHlwZShmaWJlcik7XG4gICAgICBpZiAobnVsbCA9PT0gdHlwZSkge1xuICAgICAgICB0eXBlID0gXCJcIjtcbiAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBmaWJlcjsgKVxuICAgICAgICAgICh0eXBlICs9IGRlc2NyaWJlU2libGluZ0ZpYmVyKGZpYmVyLCBpbmRlbnQpKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTm9kZShub2RlLCBpbmRlbnQpIHtcbiAgICAgIHZhciBza2lwVG9Ob2RlID0gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCk7XG4gICAgICBpZiAoXG4gICAgICAgIHNraXBUb05vZGUgIT09IG5vZGUgJiZcbiAgICAgICAgKDEgIT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIHx8IG5vZGUuY2hpbGRyZW5bMF0gIT09IHNraXBUb05vZGUpXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIFwiLi4uXFxuXCIgKyBkZXNjcmliZU5vZGUoc2tpcFRvTm9kZSwgaW5kZW50ICsgMSlcbiAgICAgICAgKTtcbiAgICAgIHNraXBUb05vZGUgPSBcIlwiO1xuICAgICAgdmFyIGRlYnVnSW5mbyA9IG5vZGUuZmliZXIuX2RlYnVnSW5mbztcbiAgICAgIGlmIChkZWJ1Z0luZm8pXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNlcnZlckNvbXBvbmVudE5hbWUgPSBkZWJ1Z0luZm9baV0ubmFtZTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyQ29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgKChza2lwVG9Ob2RlICs9XG4gICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHNlcnZlckNvbXBvbmVudE5hbWUgKyBcIj5cXG5cIiksXG4gICAgICAgICAgICBpbmRlbnQrKyk7XG4gICAgICAgIH1cbiAgICAgIGRlYnVnSW5mbyA9IFwiXCI7XG4gICAgICBpID0gbm9kZS5maWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICBpZiAoNiA9PT0gbm9kZS5maWJlci50YWcpXG4gICAgICAgIChkZWJ1Z0luZm8gPSBkZXNjcmliZVRleHREaWZmKGksIG5vZGUuc2VydmVyUHJvcHMsIGluZGVudCkpLCBpbmRlbnQrKztcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAoKHNlcnZlckNvbXBvbmVudE5hbWUgPSBkZXNjcmliZUZpYmVyVHlwZShub2RlLmZpYmVyKSksXG4gICAgICAgIG51bGwgIT09IHNlcnZlckNvbXBvbmVudE5hbWUpXG4gICAgICApXG4gICAgICAgIGlmICh2b2lkIDAgPT09IG5vZGUuc2VydmVyUHJvcHMpIHtcbiAgICAgICAgICBkZWJ1Z0luZm8gPSBpbmRlbnQ7XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBkZWJ1Z0luZm8gLSBzZXJ2ZXJDb21wb25lbnROYW1lLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHByb3BOYW1lIGluIGkpXG4gICAgICAgICAgICBpZiAoaS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoaVtwcm9wTmFtZV0sIDE1KTtcbiAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuICAgICAgICAgICAgICBpZiAoMCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCIgLi4uXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGVudCArPSBcIiBcIiArIHByb3BOYW1lICsgXCI9XCIgKyBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVidWdJbmZvID1cbiAgICAgICAgICAgIGluZGVudGF0aW9uKGRlYnVnSW5mbykgK1xuICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICBjb250ZW50ICtcbiAgICAgICAgICAgIFwiPlxcblwiO1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBudWxsID09PSBub2RlLnNlcnZlclByb3BzXG4gICAgICAgICAgICA/ICgoZGVidWdJbmZvID0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudClcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGluZGVudCsrKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygbm9kZS5zZXJ2ZXJQcm9wc1xuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlNob3VsZCBub3QgaGF2ZSBtYXRjaGVkIGEgbm9uIEhvc3RUZXh0IGZpYmVyIHRvIGEgVGV4dCBub2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6ICgoZGVidWdJbmZvID0gZGVzY3JpYmVFbGVtZW50RGlmZihcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgbm9kZS5zZXJ2ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGluZGVudFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGluZGVudCsrKTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IFwiXCI7XG4gICAgICBpID0gbm9kZS5maWJlci5jaGlsZDtcbiAgICAgIGZvciAoXG4gICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUgPSAwO1xuICAgICAgICBpICYmIHNlcnZlckNvbXBvbmVudE5hbWUgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgKVxuICAgICAgICAobWF4TGVuZ3RoID0gbm9kZS5jaGlsZHJlbltzZXJ2ZXJDb21wb25lbnROYW1lXSksXG4gICAgICAgICAgbWF4TGVuZ3RoLmZpYmVyID09PSBpXG4gICAgICAgICAgICA/ICgocHJvcE5hbWUgKz0gZGVzY3JpYmVOb2RlKG1heExlbmd0aCwgaW5kZW50KSksXG4gICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUrKylcbiAgICAgICAgICAgIDogKHByb3BOYW1lICs9IGRlc2NyaWJlU2libGluZ0ZpYmVyKGksIGluZGVudCkpLFxuICAgICAgICAgIChpID0gaS5zaWJsaW5nKTtcbiAgICAgIGkgJiZcbiAgICAgICAgMCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChwcm9wTmFtZSArPSBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCIuLi5cXG5cIik7XG4gICAgICBpID0gbm9kZS5zZXJ2ZXJUYWlsO1xuICAgICAgbnVsbCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcyAmJiBpbmRlbnQtLTtcbiAgICAgIGZvciAobm9kZSA9IDA7IG5vZGUgPCBpLmxlbmd0aDsgbm9kZSsrKVxuICAgICAgICAoc2VydmVyQ29tcG9uZW50TmFtZSA9IGlbbm9kZV0pLFxuICAgICAgICAgIChwcm9wTmFtZSA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyQ29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICA/IHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICAocmVtb3ZlZChpbmRlbnQpICtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyQ29tcG9uZW50TmFtZSwgMTIwIC0gMiAqIGluZGVudCkgK1xuICAgICAgICAgICAgICAgICAgXCJcXG5cIilcbiAgICAgICAgICAgICAgOiBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLnR5cGUsXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLnByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICByZXR1cm4gc2tpcFRvTm9kZSArIGRlYnVnSW5mbyArIHByb3BOYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZURpZmYocm9vdE5vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBcIlxcblxcblwiICsgZGVzY3JpYmVOb2RlKHJvb3ROb2RlLCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICA2ID09PSB3b3JrSW5Qcm9ncmVzcy50YWcgJiYgKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuKTtcbiAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiQWN0aXZpdHlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8XG4gICAgICAgICAgICAgIFwiXCIgIT09IGluZm8gfHxcbiAgICAgICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lV2l0aG91dExpbmVOdW1iZXIoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fFxuICAgICAgICAgICAgICBcIlwiICE9PSBpbmZvIHx8XG4gICAgICAgICAgICAgIChpbmZvICs9IGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZVdpdGhvdXRMaW5lTnVtYmVyKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUucmVuZGVyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzczsgKVxuICAgICAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgICB2YXIgZGVidWdTdGFjayA9IGZpYmVyLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzICYmIGRlYnVnU3RhY2spIHtcbiAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFN0YWNrID0gZm9ybWF0T3duZXJTdGFjayhkZWJ1Z1N0YWNrKTtcbiAgICAgICAgICAgICAgXCJcIiAhPT0gZm9ybWF0dGVkU3RhY2sgJiYgKGluZm8gKz0gXCJcXG5cIiArIGZvcm1hdHRlZFN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG51bGwgIT0gd29ya0luUHJvZ3Jlc3MuZGVidWdTdGFjaykge1xuICAgICAgICAgICAgdmFyIG93bmVyU3RhY2sgPSB3b3JrSW5Qcm9ncmVzcy5kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3Mub3duZXIpICYmXG4gICAgICAgICAgICAgIG93bmVyU3RhY2sgJiZcbiAgICAgICAgICAgICAgKGluZm8gKz0gXCJcXG5cIiArIGZvcm1hdE93bmVyU3RhY2sob3duZXJTdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGNhbGxiYWNrLCBhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG4gICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IGZpYmVyICYmIGZpYmVyLl9kZWJ1Z1Rhc2tcbiAgICAgICAgICA/IGZpYmVyLl9kZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICBjYWxsYmFjay5iaW5kKG51bGwsIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjYWxsYmFjayhhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcInJ1bldpdGhGaWJlckluREVWIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgaW4gcHJvZHVjdGlvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPVxuICAgICAgICBudWxsID09PSBmaWJlciA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybikge1xuICAgICAgICBpZiAobnVsbCA9PT0gaHlkcmF0aW9uRGlmZlJvb3RERVYpXG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlNhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmICsgMVxuICAgICAgKS5jaGlsZHJlbjtcbiAgICAgIGlmICgwIDwgc2libGluZ3MubGVuZ3RoICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2libGluZ3MgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZiksXG4gICAgICAgICAgc2libGluZ3NcbiAgICAgICAgKTtcbiAgICAgIGRpc3RhbmNlRnJvbUxlYWYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzLnB1c2goZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIldlIHNob3VsZCBub3QgYmUgaHlkcmF0aW5nIGhlcmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGEgYnVnLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCByZWplY3RlZENhbmRpZGF0ZSkge1xuICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgKChmaWJlciA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApKSxcbiAgICAgICAgKGZpYmVyLnNlcnZlclByb3BzID0gbnVsbCksXG4gICAgICAgIG51bGwgIT09IHJlamVjdGVkQ2FuZGlkYXRlICYmXG4gICAgICAgICAgKChyZWplY3RlZENhbmRpZGF0ZSA9XG4gICAgICAgICAgICBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHJlamVjdGVkQ2FuZGlkYXRlKSksXG4gICAgICAgICAgZmliZXIuc2VydmVyVGFpbC5wdXNoKHJlamVjdGVkQ2FuZGlkYXRlKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgICAgIHZhciBmcm9tVGV4dCA9XG4gICAgICAgICAgMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAhMSxcbiAgICAgICAgZGlmZiA9IFwiXCIsXG4gICAgICAgIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICBudWxsICE9PSBkaWZmUm9vdCAmJlxuICAgICAgICAoKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksIChkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KSkpO1xuICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBcIkh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkIFwiICtcbiAgICAgICAgICAgICAgKGZyb21UZXh0ID8gXCJ0ZXh0XCIgOiBcIkhUTUxcIikgK1xuICAgICAgICAgICAgICBcIiBkaWRuJ3QgbWF0Y2ggdGhlIGNsaWVudC4gQXMgYSByZXN1bHQgdGhpcyB0cmVlIHdpbGwgYmUgcmVnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG5cXG4tIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcbi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcbi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuXFxuSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuXFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9oeWRyYXRpb24tbWlzbWF0Y2hcIiArXG4gICAgICAgICAgICAgIGRpZmZcbiAgICAgICAgICApLFxuICAgICAgICAgIGZpYmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0aHJvdyBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgaG9zdENvbnRleHQpIHtcbiAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgaHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICBmaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgIGZpYmVyLnR5cGUsXG4gICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGhvc3RDb250ZXh0LFxuICAgICAgICBmaWJlclxuICAgICAgKSB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgICAgZm9yIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjsgaHlkcmF0aW9uUGFyZW50RmliZXI7IClcbiAgICAgICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbiB8fCBmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHJldHVybiAhMTtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHJldHVybiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSwgKGlzSHlkcmF0aW5nID0gITApLCAhMTtcbiAgICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgPyAzICE9PSB0YWcgJiZcbiAgICAgICAgICAyNyAhPT0gdGFnICYmXG4gICAgICAgICAgKDUgIT09IHRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSAmJlxuICAgICAgICAgICh3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKSwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKSlcbiAgICAgICAgOiAzICE9PSB0YWcgJiZcbiAgICAgICAgICAoNSAhPT0gdGFnIHx8XG4gICAgICAgICAgICAoc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICAgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkgJiZcbiAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlICYmXG4gICAgICAgICAgKHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpLCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpKTtcbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaWYgKDEzID09PSB0YWcpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgZmliZXIgPSBudWxsICE9PSBmaWJlciA/IGZpYmVyLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICBpZiAoIWZpYmVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoMzEgPT09IHRhZykge1xuICAgICAgICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGZpYmVyID0gbnVsbCAhPT0gZmliZXIgPyBmaWJlci5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgaWYgKCFmaWJlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyQWN0aXZpdHlJbnN0YW5jZShmaWJlcik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSB0YWdcbiAgICAgICAgICAgID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nQWZ0ZXJTaW5nbGV0b24oXG4gICAgICAgICAgICAgICAgZmliZXIudHlwZSxcbiAgICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogaHlkcmF0aW9uUGFyZW50RmliZXJcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpIHtcbiAgICAgIGZvciAodmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7IG5leHRJbnN0YW5jZTsgKSB7XG4gICAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApLFxuICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhuZXh0SW5zdGFuY2UpO1xuICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPVxuICAgICAgICAgIFwiU3VzcGVuc2VcIiA9PT0gZGVzY3JpcHRpb24udHlwZVxuICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSlcbiAgICAgICAgICAgIDogZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwpLFxuICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBpc0h5ZHJhdGluZyA9ICExKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkge1xuICAgICAgdmFyIHF1ZXVlZEVycm9ycyA9IGh5ZHJhdGlvbkVycm9ycztcbiAgICAgIG51bGwgIT09IHF1ZXVlZEVycm9ycyAmJlxuICAgICAgICAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnNcbiAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IHF1ZXVlZEVycm9ycylcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICBxdWV1ZWRFcnJvcnNcbiAgICAgICAgICAgICksXG4gICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSk7XG4gICAgICByZXR1cm4gcXVldWVkRXJyb3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICBudWxsID09PSBoeWRyYXRpb25FcnJvcnNcbiAgICAgICAgPyAoaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSB7XG4gICAgICB2YXIgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIGlmIChudWxsICE9PSBkaWZmUm9vdCkge1xuICAgICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGRpZmYgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpOyAwIDwgZGlmZlJvb3QuY2hpbGRyZW4ubGVuZ3RoOyApXG4gICAgICAgICAgZGlmZlJvb3QgPSBkaWZmUm9vdC5jaGlsZHJlblswXTtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZGlmZlJvb3QuZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBIHRyZWUgaHlkcmF0ZWQgYnV0IHNvbWUgYXR0cmlidXRlcyBvZiB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQgcHJvcGVydGllcy4gVGhpcyB3b24ndCBiZSBwYXRjaGVkIHVwLiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG4lcyVzXCIsXG4gICAgICAgICAgICBcImh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoXCIsXG4gICAgICAgICAgICBkaWZmXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICA/IChwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWUpLFxuICAgICAgICAgIHB1c2gocmVuZGVyZXJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgdm9pZCAwICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsKSlcbiAgICAgICAgOiAocHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWUpLFxuICAgICAgICAgIHB1c2gocmVuZGVyZXIyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICB2b2lkIDAgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyAoKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9IHJlbmRlcmVyQ3Vyc29yREVWLmN1cnJlbnQpLFxuICAgICAgICAgIHBvcChyZW5kZXJlckN1cnNvckRFViwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IGN1cnJlbnRWYWx1ZSkpXG4gICAgICAgIDogKChjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlKSxcbiAgICAgICAgICAoY3VycmVudFZhbHVlID0gcmVuZGVyZXIyQ3Vyc29yREVWLmN1cnJlbnQpLFxuICAgICAgICAgIHBvcChyZW5kZXJlcjJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gY3VycmVudFZhbHVlKSk7XG4gICAgICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgcGFyZW50LFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBwcm9wYWdhdGlvblJvb3RcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgKHBhcmVudC5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgID8gKChwYXJlbnQuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSlcbiAgICAgICAgICA6IG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcHJvcGFnYXRpb25Sb290KSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmVudCAhPT0gcHJvcGFnYXRpb25Sb290ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGNvbnRleHRzLFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGZvciAoOyBudWxsICE9PSBmaWJlcjsgKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGlzdCkge1xuICAgICAgICAgIHZhciBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICBsaXN0ID0gbGlzdC5maXJzdENvbnRleHQ7XG4gICAgICAgICAgYTogZm9yICg7IG51bGwgIT09IGxpc3Q7ICkge1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0O1xuICAgICAgICAgICAgbGlzdCA9IGZpYmVyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBsaXN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgICBudWxsICE9PSBkZXBlbmRlbmN5ICYmIChkZXBlbmRlbmN5LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgICAgICAgbGlzdC5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUgfHwgKG5leHRGaWJlciA9IG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKDE4ID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRGaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIldlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dEZpYmVyLmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgIGxpc3QgPSBuZXh0RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IGxpc3QgJiYgKGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICBuZXh0RmliZXIsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2UgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXh0RmliZXIpIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobmV4dEZpYmVyID0gZmliZXI7IG51bGwgIT09IG5leHRGaWJlcjsgKSB7XG4gICAgICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpYmVyID0gbmV4dEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgZmliZXIucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBwYXJlbnQgPSB3b3JrSW5Qcm9ncmVzcywgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMTtcbiAgICAgICAgbnVsbCAhPT0gcGFyZW50O1xuXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dClcbiAgICAgICAgICBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDUyNDI4OCkpIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITA7XG4gICAgICAgICAgZWxzZSBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDI2MjE0NCkpIGJyZWFrO1xuICAgICAgICBpZiAoMTAgPT09IHBhcmVudC50YWcpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIG9iamVjdElzKHBhcmVudC5wZW5kaW5nUHJvcHMudmFsdWUsIGN1cnJlbnRQYXJlbnQudmFsdWUpIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBjdXJyZW50LnB1c2goY29udGV4dClcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50ID0gW2NvbnRleHRdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50KSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgIT09XG4gICAgICAgICAgICBwYXJlbnQubWVtb2l6ZWRTdGF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICA/IGN1cnJlbnQucHVzaChIb3N0VHJhbnNpdGlvbkNvbnRleHQpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBbSG9zdFRyYW5zaXRpb25Db250ZXh0XSkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNjIxNDQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50RGVwZW5kZW5jaWVzKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnREZXBlbmRlbmNpZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGN1cnJlbnREZXBlbmRlbmNpZXMuY29udGV4dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvYmplY3RJcyhcbiAgICAgICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyID8gY29udGV4dC5fY3VycmVudFZhbHVlIDogY29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMubWVtb2l6ZWRWYWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcztcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICh3b3JrSW5Qcm9ncmVzcy5maXJzdENvbnRleHQgPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gICAgICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxICYmIHByZXBhcmVUb1JlYWRDb250ZXh0KGNvbnN1bWVyKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgY29udGV4dCA9IHsgY29udGV4dDogY29udGV4dCwgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsIG5leHQ6IG51bGwgfTtcbiAgICAgIGlmIChudWxsID09PSBsYXN0Q29udGV4dERlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdW1lci5mbGFncyB8PSA1MjQyODg7XG4gICAgICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgICAgICBkYXRhOiBuZXcgTWFwKCksXG4gICAgICAgIHJlZkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuICAgICAgY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJBIGNhY2hlIGluc3RhbmNlIHdhcyByZXRhaW5lZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBjYWNoZS5yZWZDb3VudCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnJlZkNvdW50LS07XG4gICAgICAwID4gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmVsZWFzZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQyKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FjaGUuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRVcGRhdGVUaW1lckJ5TGFuZShsYW5lLCBtZXRob2QsIGZpYmVyKSB7XG4gICAgICBpZiAoMCAhPT0gKGxhbmUgJiAxMjcpKVxuICAgICAgICAwID4gYmxvY2tpbmdVcGRhdGVUaW1lICYmXG4gICAgICAgICAgKChibG9ja2luZ1VwZGF0ZVRpbWUgPSBub3coKSksXG4gICAgICAgICAgKGJsb2NraW5nVXBkYXRlVGFzayA9IGNyZWF0ZVRhc2sobWV0aG9kKSksXG4gICAgICAgICAgKGJsb2NraW5nVXBkYXRlTWV0aG9kTmFtZSA9IG1ldGhvZCksXG4gICAgICAgICAgbnVsbCAhPSBmaWJlciAmJlxuICAgICAgICAgICAgKGJsb2NraW5nVXBkYXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpKSxcbiAgICAgICAgICBpc0FscmVhZHlSZW5kZXJpbmcoKSAmJlxuICAgICAgICAgICAgKChjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlID0gITApLCAoYmxvY2tpbmdVcGRhdGVUeXBlID0gMSkpLFxuICAgICAgICAgIChsYW5lID0gcmVzb2x2ZUV2ZW50VGltZVN0YW1wKCkpLFxuICAgICAgICAgIChtZXRob2QgPSByZXNvbHZlRXZlbnRUeXBlKCkpLFxuICAgICAgICAgIGxhbmUgIT09IGJsb2NraW5nRXZlbnRSZXBlYXRUaW1lIHx8IG1ldGhvZCAhPT0gYmxvY2tpbmdFdmVudFR5cGVcbiAgICAgICAgICAgID8gKGJsb2NraW5nRXZlbnRSZXBlYXRUaW1lID0gLTEuMSlcbiAgICAgICAgICAgIDogbnVsbCAhPT0gbWV0aG9kICYmIChibG9ja2luZ1VwZGF0ZVR5cGUgPSAxKSxcbiAgICAgICAgICAoYmxvY2tpbmdFdmVudFRpbWUgPSBsYW5lKSxcbiAgICAgICAgICAoYmxvY2tpbmdFdmVudFR5cGUgPSBtZXRob2QpKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAwICE9PSAobGFuZSAmIDQxOTQwNDgpICYmXG4gICAgICAgIDAgPiB0cmFuc2l0aW9uVXBkYXRlVGltZSAmJlxuICAgICAgICAoKHRyYW5zaXRpb25VcGRhdGVUaW1lID0gbm93KCkpLFxuICAgICAgICAodHJhbnNpdGlvblVwZGF0ZVRhc2sgPSBjcmVhdGVUYXNrKG1ldGhvZCkpLFxuICAgICAgICAodHJhbnNpdGlvblVwZGF0ZU1ldGhvZE5hbWUgPSBtZXRob2QpLFxuICAgICAgICBudWxsICE9IGZpYmVyICYmXG4gICAgICAgICAgKHRyYW5zaXRpb25VcGRhdGVDb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpLFxuICAgICAgICAwID4gdHJhbnNpdGlvblN0YXJ0VGltZSlcbiAgICAgICkge1xuICAgICAgICBsYW5lID0gcmVzb2x2ZUV2ZW50VGltZVN0YW1wKCk7XG4gICAgICAgIG1ldGhvZCA9IHJlc29sdmVFdmVudFR5cGUoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxhbmUgIT09IHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUgfHxcbiAgICAgICAgICBtZXRob2QgIT09IHRyYW5zaXRpb25FdmVudFR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUgPSAtMS4xO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnRUaW1lID0gbGFuZTtcbiAgICAgICAgdHJhbnNpdGlvbkV2ZW50VHlwZSA9IG1ldGhvZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRIb3N0QWN0aW9uVGltZXIoZmliZXIpIHtcbiAgICAgIGlmICgwID4gYmxvY2tpbmdVcGRhdGVUaW1lKSB7XG4gICAgICAgIGJsb2NraW5nVXBkYXRlVGltZSA9IG5vdygpO1xuICAgICAgICBibG9ja2luZ1VwZGF0ZVRhc2sgPSBudWxsICE9IGZpYmVyLl9kZWJ1Z1Rhc2sgPyBmaWJlci5fZGVidWdUYXNrIDogbnVsbDtcbiAgICAgICAgaXNBbHJlYWR5UmVuZGVyaW5nKCkgJiYgKGJsb2NraW5nVXBkYXRlVHlwZSA9IDEpO1xuICAgICAgICB2YXIgbmV3RXZlbnRUaW1lID0gcmVzb2x2ZUV2ZW50VGltZVN0YW1wKCksXG4gICAgICAgICAgbmV3RXZlbnRUeXBlID0gcmVzb2x2ZUV2ZW50VHlwZSgpO1xuICAgICAgICBuZXdFdmVudFRpbWUgIT09IGJsb2NraW5nRXZlbnRSZXBlYXRUaW1lIHx8XG4gICAgICAgIG5ld0V2ZW50VHlwZSAhPT0gYmxvY2tpbmdFdmVudFR5cGVcbiAgICAgICAgICA/IChibG9ja2luZ0V2ZW50UmVwZWF0VGltZSA9IC0xLjEpXG4gICAgICAgICAgOiBudWxsICE9PSBuZXdFdmVudFR5cGUgJiYgKGJsb2NraW5nVXBkYXRlVHlwZSA9IDEpO1xuICAgICAgICBibG9ja2luZ0V2ZW50VGltZSA9IG5ld0V2ZW50VGltZTtcbiAgICAgICAgYmxvY2tpbmdFdmVudFR5cGUgPSBuZXdFdmVudFR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIDAgPiB0cmFuc2l0aW9uVXBkYXRlVGltZSAmJlxuICAgICAgICAoKHRyYW5zaXRpb25VcGRhdGVUaW1lID0gbm93KCkpLFxuICAgICAgICAodHJhbnNpdGlvblVwZGF0ZVRhc2sgPVxuICAgICAgICAgIG51bGwgIT0gZmliZXIuX2RlYnVnVGFzayA/IGZpYmVyLl9kZWJ1Z1Rhc2sgOiBudWxsKSxcbiAgICAgICAgMCA+IHRyYW5zaXRpb25TdGFydFRpbWUpXG4gICAgICApIHtcbiAgICAgICAgZmliZXIgPSByZXNvbHZlRXZlbnRUaW1lU3RhbXAoKTtcbiAgICAgICAgbmV3RXZlbnRUaW1lID0gcmVzb2x2ZUV2ZW50VHlwZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZmliZXIgIT09IHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUgfHxcbiAgICAgICAgICBuZXdFdmVudFRpbWUgIT09IHRyYW5zaXRpb25FdmVudFR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUgPSAtMS4xO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnRUaW1lID0gZmliZXI7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudFR5cGUgPSBuZXdFdmVudFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgcmV0dXJuIHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgICByZXR1cm4gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IHByb2ZpbGVyRWZmZWN0RHVyYXRpb247XG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRDb21wb25lbnRFZmZlY3RUaW1lcnMoKSB7XG4gICAgICBjb21wb25lbnRFZmZlY3RFbmRUaW1lID0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lID0gLTEuMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCkge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZTtcbiAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSA9IC0xLjE7XG4gICAgICByZXR1cm4gcHJldkVmZmVjdFN0YXJ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpIHtcbiAgICAgIDAgPD0gcHJldkVmZmVjdFN0YXJ0ICYmIChjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgPSBwcmV2RWZmZWN0U3RhcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gY29tcG9uZW50RWZmZWN0RHVyYXRpb247XG4gICAgICBjb21wb25lbnRFZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgcmV0dXJuIHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQ29tcG9uZW50RWZmZWN0RHVyYXRpb24ocHJldkVmZmVjdER1cmF0aW9uKSB7XG4gICAgICAwIDw9IHByZXZFZmZlY3REdXJhdGlvbiAmJiAoY29tcG9uZW50RWZmZWN0RHVyYXRpb24gPSBwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQ29tcG9uZW50RWZmZWN0RXJyb3JzKCkge1xuICAgICAgdmFyIHByZXZFcnJvcnMgPSBjb21wb25lbnRFZmZlY3RFcnJvcnM7XG4gICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnMgPSBudWxsO1xuICAgICAgcmV0dXJuIHByZXZFcnJvcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb21wb25lbnRFZmZlY3REaWRTcGF3blVwZGF0ZSgpIHtcbiAgICAgIHZhciBwcmV2ID0gY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZTtcbiAgICAgIGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgPSAhMTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAwID4gZmliZXIuYWN0dWFsU3RhcnRUaW1lICYmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPSBwcm9maWxlclN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb3JkRWZmZWN0RHVyYXRpb24oKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZW5kVGltZSA9IG5vdygpLFxuICAgICAgICAgIGVsYXBzZWRUaW1lID0gZW5kVGltZSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBjb21wb25lbnRFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29yZEVmZmVjdEVycm9yKGVycm9ySW5mbykge1xuICAgICAgbnVsbCA9PT0gY29tcG9uZW50RWZmZWN0RXJyb3JzICYmIChjb21wb25lbnRFZmZlY3RFcnJvcnMgPSBbXSk7XG4gICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnMucHVzaChlcnJvckluZm8pO1xuICAgICAgbnVsbCA9PT0gY29tbWl0RXJyb3JzICYmIChjb21taXRFcnJvcnMgPSBbXSk7XG4gICAgICBjb21taXRFcnJvcnMucHVzaChlcnJvckluZm8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEVmZmVjdFRpbWVyKCkge1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcbiAgICAgIDAgPiBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgKGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSA9IHByb2ZpbGVyU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAgICAgZm9yICh2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgY2hpbGQ7IClcbiAgICAgICAgKGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMSgpIHt9XG4gICAgZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpIHtcbiAgICAgIHJvb3QgIT09IGxhc3RTY2hlZHVsZWRSb290ICYmXG4gICAgICAgIG51bGwgPT09IHJvb3QubmV4dCAmJlxuICAgICAgICAobnVsbCA9PT0gbGFzdFNjaGVkdWxlZFJvb3RcbiAgICAgICAgICA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3QpXG4gICAgICAgICAgOiAobGFzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0ID0gcm9vdCkpO1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICA/IGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCB8fFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gITApLCBzY2hlZHVsZUltbWVkaWF0ZVJvb3RTY2hlZHVsZVRhc2soKSlcbiAgICAgICAgOiBkaWRTY2hlZHVsZU1pY3JvdGFzayB8fFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMCksIHNjaGVkdWxlSW1tZWRpYXRlUm9vdFNjaGVkdWxlVGFzaygpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgb25seUxlZ2FjeSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nV29yayAmJiBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBkaWRQZXJmb3JtU29tZVdvcmsgPSAhMTtcbiAgICAgICAgICBmb3IgKHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290OyBudWxsICE9PSByb290OyApIHtcbiAgICAgICAgICAgIGlmICghb25seUxlZ2FjeSlcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgdmFyIG5leHRMYW5lcyA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICAoMSA8PCAoMzEgLSBjbHozMig0MiB8IHN5bmNUcmFuc2l0aW9uTGFuZXMpICsgMSkpIC0gMTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmPSBwZW5kaW5nTGFuZXMgJiB+KHN1c3BlbmRlZExhbmVzICYgfnBpbmdlZExhbmVzKTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmIDIwMTMyNjc0MVxuICAgICAgICAgICAgICAgICAgICAgID8gKG5leHRMYW5lcyAmIDIwMTMyNjc0MSkgfCAxXG4gICAgICAgICAgICAgICAgICAgICAgOiBuZXh0TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dExhbmVzIHwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAwICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gbmV4dExhbmVzIDogMCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXRcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgMCA9PT0gKG5leHRMYW5lcyAmIDMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbmV4dExhbmVzKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgcm9vdCA9IHJvb3QubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFBlcmZvcm1Tb21lV29yayk7XG4gICAgICAgIGlzRmx1c2hpbmdXb3JrID0gITE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSb290U2NoZWR1bGVJbkltbWVkaWF0ZVRhc2soKSB7XG4gICAgICB0cmFja1NjaGVkdWxlckV2ZW50KCk7XG4gICAgICBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPVxuICAgICAgICAgICExO1xuICAgICAgdmFyIHN5bmNUcmFuc2l0aW9uTGFuZXMgPSAwO1xuICAgICAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAgICAgc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpICYmXG4gICAgICAgIChzeW5jVHJhbnNpdGlvbkxhbmVzID0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbm93JDEoKSwgcHJldiA9IG51bGwsIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIG51bGwgIT09IHJvb3Q7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dCxcbiAgICAgICAgICBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKDAgPT09IG5leHRMYW5lcylcbiAgICAgICAgICAocm9vdC5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2ID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQpIDogKHByZXYubmV4dCA9IG5leHQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gbmV4dCAmJiAobGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2KTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKChwcmV2ID0gcm9vdCksIDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMgfHwgMCAhPT0gKG5leHRMYW5lcyAmIDMpKVxuICAgICAgICApXG4gICAgICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICAgIHJvb3QgPSBuZXh0O1xuICAgICAgfVxuICAgICAgKHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBOT19QRU5ESU5HX0VGRkVDVFMgJiZcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgIT09IFBFTkRJTkdfUEFTU0lWRV9QSEFTRSkgfHxcbiAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgITEpO1xuICAgICAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgICAgIGxhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiAtNjI5MTQ1NjE7XG4gICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4LFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcbiAgICAgICAgaWYgKC0xID09PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIGlmICgwID09PSAobGFuZSAmIHN1c3BlbmRlZExhbmVzKSB8fCAwICE9PSAobGFuZSAmIHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2UgZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUgJiYgKHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmUpO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRUaW1lID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgc3VzcGVuZGVkTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSBjdXJyZW50VGltZSA/IHN1c3BlbmRlZExhbmVzIDogMCxcbiAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0IHx8IHJvb3QudGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0XG4gICAgICApO1xuICAgICAgcGluZ2VkTGFuZXMgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc3VzcGVuZGVkTGFuZXMgfHxcbiAgICAgICAgKHJvb3QgPT09IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgfHxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkFjdGlvbikpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKHN1c3BlbmRlZExhbmVzICYgMykgfHxcbiAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBzdXNwZW5kZWRMYW5lcylcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50VGltZSA9IHN1c3BlbmRlZExhbmVzICYgLXN1c3BlbmRlZExhbmVzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudFRpbWUgIT09IHJvb3QuY2FsbGJhY2tQcmlvcml0eSB8fFxuICAgICAgICAgIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAgICAgcGluZ2VkTGFuZXMgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSlcbiAgICAgICAgKVxuICAgICAgICAgIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgICAgZWxzZSByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkoc3VzcGVuZGVkTGFuZXMpKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgIH1cbiAgICAgICAgcGluZ2VkTGFuZXMgPSBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgICA/IChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAgIChzdXNwZW5kZWRMYW5lcyA9IGZha2VBY3RDYWxsYmFja05vZGUkMSkpXG4gICAgICAgICAgOiAoc3VzcGVuZGVkTGFuZXMgPSBzY2hlZHVsZUNhbGxiYWNrJDMoc3VzcGVuZGVkTGFuZXMsIHBpbmdlZExhbmVzKSk7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyk7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAyO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayhyb290LCBkaWRUaW1lb3V0KSB7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMTtcbiAgICAgIHRyYWNrU2NoZWR1bGVyRXZlbnQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgIT09IE5PX1BFTkRJTkdfRUZGRUNUUyAmJlxuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyAhPT0gUEVORElOR19QQVNTSVZFX1BIQVNFXG4gICAgICApXG4gICAgICAgIHJldHVybiAocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSwgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApLCBudWxsO1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBwZW5kaW5nRGVsYXllZENvbW1pdFJlYXNvbiA9PT0gSU1NRURJQVRFX0NPTU1JVCAmJlxuICAgICAgICAocGVuZGluZ0RlbGF5ZWRDb21taXRSZWFzb24gPSBERUxBWUVEX1BBU1NJVkVfQ09NTUlUKTtcbiAgICAgIGlmIChmbHVzaFBlbmRpbmdFZmZlY3RzKCkgJiYgcm9vdC5jYWxsYmFja05vZGUgIT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdFxuICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDBcbiAgICAgICAgICA6IDAsXG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCB8fCByb290LnRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dFxuICAgICAgKTtcbiAgICAgIGlmICgwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCkgcmV0dXJuIG51bGw7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAsXG4gICAgICAgIGRpZFRpbWVvdXRcbiAgICAgICk7XG4gICAgICBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIG5vdyQxKCkpO1xuICAgICAgcmV0dXJuIG51bGwgIT0gcm9vdC5jYWxsYmFja05vZGUgJiZcbiAgICAgICAgcm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlXG4gICAgICAgID8gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlmIChmbHVzaFBlbmRpbmdFZmZlY3RzKCkpIHJldHVybiBudWxsO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gbmVzdGVkVXBkYXRlU2NoZWR1bGVkO1xuICAgICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gITE7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBsYW5lcywgITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpIHtcbiAgICAgIGNhbGxiYWNrTm9kZSAhPT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxICYmXG4gICAgICAgIG51bGwgIT09IGNhbGxiYWNrTm9kZSAmJlxuICAgICAgICBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSW1tZWRpYXRlUm9vdFNjaGVkdWxlVGFzaygpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIHN1cHBvcnRzTWljcm90YXNrc1xuICAgICAgICA/IHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dFxuICAgICAgICAgICAgICA/IHNjaGVkdWxlQ2FsbGJhY2skMyhcbiAgICAgICAgICAgICAgICAgIEltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgcHJvY2Vzc1Jvb3RTY2hlZHVsZUluSW1tZWRpYXRlVGFza1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKTtcbiAgICAgICAgICB9KVxuICAgICAgICA6IHNjaGVkdWxlQ2FsbGJhY2skMyhcbiAgICAgICAgICAgIEltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgICAgICAgcHJvY2Vzc1Jvb3RTY2hlZHVsZUluSW1tZWRpYXRlVGFza1xuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpIHtcbiAgICAgIGlmICgwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSkge1xuICAgICAgICB2YXIgYWN0aW9uU2NvcGVMYW5lID0gY3VycmVudEVudGFuZ2xlZExhbmU7XG4gICAgICAgIDAgPT09IGFjdGlvblNjb3BlTGFuZSAmJlxuICAgICAgICAgICgoYWN0aW9uU2NvcGVMYW5lID0gbmV4dFRyYW5zaXRpb25VcGRhdGVMYW5lKSxcbiAgICAgICAgICAobmV4dFRyYW5zaXRpb25VcGRhdGVMYW5lIDw8PSAxKSxcbiAgICAgICAgICAwID09PSAobmV4dFRyYW5zaXRpb25VcGRhdGVMYW5lICYgMjYxODg4KSAmJlxuICAgICAgICAgICAgKG5leHRUcmFuc2l0aW9uVXBkYXRlTGFuZSA9IDI1NikpO1xuICAgICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGFjdGlvblNjb3BlTGFuZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICAgICAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgICAgICgtMSA8IHRyYW5zaXRpb25VcGRhdGVUaW1lIHx8ICh0cmFuc2l0aW9uU3RhcnRUaW1lID0gLTEuMSksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpXG4gICAgICApIHtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICYmXG4gICAgICAgICAgKGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnM7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDA7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIHJlc3VsdCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZSA9IHtcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUudmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICBmb3IgKGVycm9yID0gMDsgZXJyb3IgPCBsaXN0ZW5lcnMubGVuZ3RoOyBlcnJvcisrKVxuICAgICAgICAgICAgKDAsIGxpc3RlbmVyc1tlcnJvcl0pKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICAgICAgdmFyIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciA9IHJlc3VtZWRDYWNoZS5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgIT09IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA/IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdC5wb29sZWRDYWNoZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpIHtcbiAgICAgIG51bGwgPT09IHByZXZDYWNoZVBvb2xcbiAgICAgICAgPyBwdXNoKHJlc3VtZWRDYWNoZSwgcmVzdW1lZENhY2hlLmN1cnJlbnQsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKVxuICAgICAgICA6IHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gICAgICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY2FjaGVGcm9tUG9vbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB7XG4gICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gICAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgICAgIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQSB8fFxuICAgICAgICBudWxsID09PSBvYmpBIHx8XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgICAgIG51bGwgPT09IG9iakJcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSksXG4gICAgICAgIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAoa2V5c0IgPSAwOyBrZXlzQiA8IGtleXNBLmxlbmd0aDsga2V5c0IrKykge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2tleXNCXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8XG4gICAgICAgICAgIW9iamVjdElzKG9iakFbY3VycmVudEtleV0sIG9iakJbY3VycmVudEtleV0pXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4geyBkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2U6ICExLCB0aGVuYWJsZXM6IFtdIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkge1xuICAgICAgdGhlbmFibGUgPSB0aGVuYWJsZS5zdGF0dXM7XG4gICAgICByZXR1cm4gXCJmdWxmaWxsZWRcIiA9PT0gdGhlbmFibGUgfHwgXCJyZWplY3RlZFwiID09PSB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSA9ICEwKTtcbiAgICAgIHZhciB0cmFja2VkVGhlbmFibGVzID0gdGhlbmFibGVTdGF0ZS50aGVuYWJsZXM7XG4gICAgICBpbmRleCA9IHRyYWNrZWRUaGVuYWJsZXNbaW5kZXhdO1xuICAgICAgdm9pZCAwID09PSBpbmRleFxuICAgICAgICA/IHRyYWNrZWRUaGVuYWJsZXMucHVzaCh0aGVuYWJsZSlcbiAgICAgICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAodGhlbmFibGVTdGF0ZS5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgfHxcbiAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZS5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkEgY29tcG9uZW50IHdhcyBzdXNwZW5kZWQgYnkgYW4gdW5jYWNoZWQgcHJvbWlzZS4gQ3JlYXRpbmcgcHJvbWlzZXMgaW5zaWRlIGEgQ2xpZW50IENvbXBvbmVudCBvciBob29rIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLCBleGNlcHQgdmlhIGEgU3VzcGVuc2UtY29tcGF0aWJsZSBsaWJyYXJ5IG9yIGZyYW1ld29yay5cIlxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSksXG4gICAgICAgICAgKHRoZW5hYmxlID0gaW5kZXgpKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHRoZW5hYmxlLl9kZWJ1Z0luZm8pIHtcbiAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0cmFja2VkVGhlbmFibGVzID0gdGhlbmFibGUuZGlzcGxheU5hbWU7XG4gICAgICAgIHZhciBpb0luZm8gPSB7XG4gICAgICAgICAgbmFtZTpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0cmFja2VkVGhlbmFibGVzID8gdHJhY2tlZFRoZW5hYmxlcyA6IFwiUHJvbWlzZVwiLFxuICAgICAgICAgIHN0YXJ0OiB0aGVuYWJsZVN0YXRlLFxuICAgICAgICAgIGVuZDogdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgICB2YWx1ZTogdGhlbmFibGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhlbmFibGUuX2RlYnVnSW5mbyA9IFt7IGF3YWl0ZWQ6IGlvSW5mbyB9XTtcbiAgICAgICAgXCJmdWxmaWxsZWRcIiAhPT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgXCJyZWplY3RlZFwiICE9PSB0aGVuYWJsZS5zdGF0dXMgJiZcbiAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpb0luZm8uZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGhlbmFibGUudGhlbih0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZVN0YXRlKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2godGhlbmFibGVTdGF0ZSksXG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgMTAwIDwgdGhlbmFibGVTdGF0ZS5zaGVsbFN1c3BlbmRDb3VudGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQW4gdW5rbm93biBDb21wb25lbnQgaXMgYW4gYXN5bmMgQ2xpZW50IENvbXBvbmVudC4gT25seSBTZXJ2ZXIgQ29tcG9uZW50cyBjYW4gYmUgYXN5bmMgYXQgdGhlIG1vbWVudC4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlLnJlYXNvbiksXG4gICAgICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2godGhlbmFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICEwO1xuICAgICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlTGF6eShsYXp5VHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxMYXp5SW5pdEluREVWKGxhenlUeXBlKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IHggJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSB4KSxcbiAgICAgICAgICAgIChuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICEwKSxcbiAgICAgICAgICAgIFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICAgICk7XG4gICAgICAgIHRocm93IHg7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZFJlYXNvbikge1xuICAgICAgaWYgKFxuICAgICAgICByZWplY3RlZFJlYXNvbiA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHxcbiAgICAgICAgcmVqZWN0ZWRSZWFzb24gPT09IFN1c3BlbnNlQWN0aW9uRXhjZXB0aW9uXG4gICAgICApXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSG9va3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGFuIGFzeW5jIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaERlYnVnSW5mbyhkZWJ1Z0luZm8pIHtcbiAgICAgIHZhciBwcmV2aW91c0RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICBudWxsICE9IGRlYnVnSW5mbyAmJlxuICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNEZWJ1Z0luZm9cbiAgICAgICAgICAgID8gZGVidWdJbmZvXG4gICAgICAgICAgICA6IHByZXZpb3VzRGVidWdJbmZvLmNvbmNhdChkZWJ1Z0luZm8pKTtcbiAgICAgIHJldHVybiBwcmV2aW91c0RlYnVnSW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudERlYnVnVGFzaygpIHtcbiAgICAgIHZhciBkZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgaWYgKG51bGwgIT0gZGVidWdJbmZvKVxuICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mb1tpXS5uYW1lKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdUYXNrID0gZGVidWdJbmZvW2ldLmRlYnVnVGFzaztcbiAgICAgICAgICAgIGlmIChudWxsICE9IGRlYnVnVGFzaykgcmV0dXJuIGRlYnVnVGFzaztcbiAgICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGZpYmVyLCByZXR1cm5GaWJlcikge1xuICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQucHJvcHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChcImNoaWxkcmVuXCIgIT09IGtleSAmJiBcImtleVwiICE9PSBrZXkpIHtcbiAgICAgICAgICBudWxsID09PSBmaWJlciAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgMCkpLFxuICAgICAgICAgICAgKGZpYmVyLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIChmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcikpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3JlZEtleSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIixcbiAgICAgICAgICAgICAgICBlcnJvcmVkS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUkMSAmJiAodGhlbmFibGVTdGF0ZSQxID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlJDEsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZVJlZih3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucHJvcHMucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gdm9pZCAwICE9PSBlbGVtZW50ID8gZWxlbWVudCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZUltcGwocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBjYW4gaGFwcGVuIGlmOlxcbi0gTXVsdGlwbGUgY29waWVzIG9mIHRoZSBcInJlYWN0XCIgcGFja2FnZSBpcyB1c2VkLlxcbi0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuLSBBIGNvbXBpbGVyIHRyaWVzIHRvIFwiaW5saW5lXCIgSlNYIGluc3RlYWQgb2YgdXNpbmcgdGhlIHJ1bnRpbWUuJ1xuICAgICAgICApO1xuICAgICAgcmV0dXJuRmliZXIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgIDogcmV0dXJuRmliZXIpICtcbiAgICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICAgICAgdmFyIGRlYnVnVGFzayA9IGdldEN1cnJlbnREZWJ1Z1Rhc2soKTtcbiAgICAgIG51bGwgIT09IGRlYnVnVGFza1xuICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGVJbXBsLmJpbmQobnVsbCwgcmV0dXJuRmliZXIsIG5ld0NoaWxkKVxuICAgICAgICAgIClcbiAgICAgICAgOiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGVJbXBsKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZUltcGwocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdIHx8XG4gICAgICAgICgob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gITApLFxuICAgICAgICAoaW52YWxpZENoaWxkID1cbiAgICAgICAgICBpbnZhbGlkQ2hpbGQuZGlzcGxheU5hbWUgfHwgaW52YWxpZENoaWxkLm5hbWUgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuICByb290LnJlbmRlciglcylcIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuICA8JXM+eyVzfTwvJXM+XCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIGRlYnVnVGFzayA9IGdldEN1cnJlbnREZWJ1Z1Rhc2soKTtcbiAgICAgIG51bGwgIT09IGRlYnVnVGFza1xuICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGVJbXBsLmJpbmQobnVsbCwgcmV0dXJuRmliZXIsIGludmFsaWRDaGlsZClcbiAgICAgICAgICApXG4gICAgICAgIDogd2Fybk9uRnVuY3Rpb25UeXBlSW1wbChyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uU3ltYm9sVHlwZUltcGwocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPSBTdHJpbmcoaW52YWxpZENoaWxkKSksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICA8JXM+JXM8LyVzPlwiLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAgICAgIHZhciBkZWJ1Z1Rhc2sgPSBnZXRDdXJyZW50RGVidWdUYXNrKCk7XG4gICAgICBudWxsICE9PSBkZWJ1Z1Rhc2tcbiAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgd2Fybk9uU3ltYm9sVHlwZUltcGwuYmluZChudWxsLCByZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKVxuICAgICAgICAgIClcbiAgICAgICAgOiB3YXJuT25TeW1ib2xUeXBlSW1wbChyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcbiAgICAgICAgICBudWxsID09PSBkZWxldGlvbnNcbiAgICAgICAgICAgID8gKChyZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV0pLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgICAgOiBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgICAgICBmb3IgKHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkLmtleVxuICAgICAgICAgICAgPyBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5rZXksIGN1cnJlbnRGaXJzdENoaWxkKVxuICAgICAgICAgICAgOiBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5pbmRleCwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgICAgICBmaWJlciA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgICAgICBmaWJlci5pbmRleCA9IDA7XG4gICAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cylcbiAgICAgICAgICByZXR1cm4gKG5ld0ZpYmVyLmZsYWdzIHw9IDEwNDg1NzYpLCBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICAgIG5ld0luZGV4ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV3SW5kZXgpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdJbmRleCA9IG5ld0luZGV4LmluZGV4KSxcbiAgICAgICAgICAgIG5ld0luZGV4IDwgbGFzdFBsYWNlZEluZGV4XG4gICAgICAgICAgICAgID8gKChuZXdGaWJlci5mbGFncyB8PSA2NzEwODg2NiksIGxhc3RQbGFjZWRJbmRleClcbiAgICAgICAgICAgICAgOiBuZXdJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IDY3MTA4ODY2O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgKG5ld0ZpYmVyLmZsYWdzIHw9IDY3MTA4ODY2KTtcbiAgICAgICAgcmV0dXJuIG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA2ICE9PSBjdXJyZW50LnRhZylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdUYXNrID0gcmV0dXJuRmliZXIuX2RlYnVnVGFzayksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBlbGVtZW50LmtleVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgY3VycmVudCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8XG4gICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY3VycmVudCwgZWxlbWVudCkgfHxcbiAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKSksXG4gICAgICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICA0ICE9PSBjdXJyZW50LnRhZyB8fFxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8XG4gICAgICAgICAgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNyAhPT0gY3VycmVudC50YWcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICBcIlwiICsgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gcmVzb2x2ZUxhenkobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKF9wcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGtleSA9IG51bGwgIT09IG9sZEZpYmVyID8gb2xkRmliZXIua2V5IDogbnVsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/IHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gcmVzb2x2ZUxhenkobmV3Q2hpbGQpKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGtleSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIFwiXCIgKyBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuZXdJZHggPVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIF9wcmV2RGVidWdJbmZvNyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gcmVzb2x2ZUxhenkobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKG5ld0lkeCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm83KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCwga25vd25LZXlzKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQgfHwgbnVsbCA9PT0gY2hpbGQpIHJldHVybiBrbm93bktleXM7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBrZXkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGtub3duS2V5cykge1xuICAgICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSBhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSBkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIFxcdTIwMTQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCBjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIixcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAoY2hpbGQgPSByZXNvbHZlTGF6eShjaGlsZCkpLFxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0ZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIG5ld0lkeCsrXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dE9sZEZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5leHRPbGRGaWJlcilcbiAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIik7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsLFxuICAgICAgICAgICAga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICBudWxsICE9PSBuZXdDaGlsZCAmJlxuICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgJiZcbiAgICAgICAgICAodmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBudWxsLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgPSBuZXdDaGlsZC5rZXk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXdDaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTGF6eShrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z093bmVyID0gbmV3Q2hpbGQuX293bmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIGxhbmVzLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gcHJldkRlYnVnSW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0gbmV3Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICA0ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY2hpbGRyZW4gfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IHJlc29sdmVMYXp5KG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Yga2V5KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGtleS5jYWxsKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZHJlbiA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgIT09IHJldHVybkZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5GaWJlci50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGRyZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBuZXdDaGlsZC5lbnRyaWVzICE9PSBrZXkgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gXCJcIiArIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkICYmIDYgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHByZXZEZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdUYXNrID0gcmV0dXJuRmliZXIuX2RlYnVnVGFzayksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpLFxuICAgICAgICAgICAgcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIHByZXZEZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgICAgICB2YXIgZmlyc3RDaGlsZEZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGRGaWJlcjtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCB4ID09PSBTdXNwZW5zZUFjdGlvbkV4Y2VwdGlvbikgdGhyb3cgeDtcbiAgICAgICAgICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcigyOSwgeCwgbnVsbCwgcmV0dXJuRmliZXIubW9kZSk7XG4gICAgICAgICAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgICAgICAgICBmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gKGZpYmVyLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKTtcbiAgICAgICAgICBmaWJlci5fZGVidWdPd25lciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgICAgIGZpYmVyLl9kZWJ1Z1Rhc2sgPSByZXR1cm5GaWJlci5fZGVidWdUYXNrO1xuICAgICAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWJ1Z0luZm8ubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGVidWdJbmZvW2ldLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgICAgZmliZXIuX2RlYnVnVGFzayA9IGRlYnVnSW5mb1tpXS5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICAgICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXlJbXBsKGNoaWxkU2xvdCk7XG4gICAgICBjaGlsZFNsb3QgPSAhaXNBbkFycmF5ICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KTtcbiAgICAgIHJldHVybiBpc0FuQXJyYXkgfHwgY2hpbGRTbG90XG4gICAgICAgID8gKChpc0FuQXJyYXkgPSBpc0FuQXJyYXkgPyBcImFycmF5XCIgOiBcIml0ZXJhYmxlXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkEgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluIGFuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6IDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gPC9TdXNwZW5zZUxpc3Q+XCIsXG4gICAgICAgICAgICBpc0FuQXJyYXksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQW5BcnJheVxuICAgICAgICAgICksXG4gICAgICAgICAgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXgsXG4gICAgICAgICAgaSA9IChjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwKTtcbiAgICAgICAgaSA8IGVuZEluZGV4O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBsYW5lID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlICYmIG51bGwgIT09IHVwZGF0ZSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgICAgICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICAgICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIDAgIT09IGxhbmUgJiYgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyB8PSBsYW5lO1xuICAgICAgZmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLmxhbmVzIHw9IGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBudWxsLCBudWxsLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSBsYW5lKTtcbiAgICAgIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAoYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAyMiA9PT0gcGFyZW50LnRhZyAmJlxuICAgICAgICAgICAgKChzb3VyY2VGaWJlciA9IHBhcmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHxcbiAgICAgICAgICAgICAgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5WaXNpYmxlIHx8XG4gICAgICAgICAgICAgIChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnJldHVybik7XG4gICAgICByZXR1cm4gMyA9PT0gc291cmNlRmliZXIudGFnXG4gICAgICAgID8gKChwYXJlbnQgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAgICAgICAgICgoaXNIaWRkZW4gPSAzMSAtIGNsejMyKGxhbmUpKSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudC5oaWRkZW5VcGRhdGVzKSxcbiAgICAgICAgICAgIChhbHRlcm5hdGUgPSBzb3VyY2VGaWJlcltpc0hpZGRlbl0pLFxuICAgICAgICAgICAgbnVsbCA9PT0gYWx0ZXJuYXRlXG4gICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyW2lzSGlkZGVuXSA9IFt1cGRhdGVdKVxuICAgICAgICAgICAgICA6IGFsdGVybmF0ZS5wdXNoKHVwZGF0ZSksXG4gICAgICAgICAgICAodXBkYXRlLmxhbmUgPSBsYW5lIHwgNTM2ODcwOTEyKSksXG4gICAgICAgICAgcGFyZW50KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpIHtcbiAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiXG4gICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCAmJlxuICAgICAgICAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGwpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IGNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gZXZlcnkgcmVuZGVyLlwiXG4gICAgICAgICkpO1xuICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgIDAgIT09IChzb3VyY2VGaWJlci5mbGFncyAmIDQwOTgpICYmXG4gICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgICAgZm9yICh2YXIgbm9kZSA9IHNvdXJjZUZpYmVyLCBwYXJlbnQgPSBub2RlLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIG51bGwgPT09IG5vZGUuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJlxuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpLFxuICAgICAgICAgIChub2RlID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gbm9kZS5yZXR1cm4pO1xuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbm9kZS5zdGF0ZU5vZGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIHNoYXJlZDogeyBwZW5kaW5nOiBudWxsLCBsYW5lczogMCwgaGlkZGVuQ2FsbGJhY2tzOiBudWxsIH0sXG4gICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9PT0gY3VycmVudCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gdXBkYXRlUXVldWUpIHJldHVybiBudWxsO1xuICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGVcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsIHdpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhIGNhbGxiYWNrLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQ6ICVzXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChjb21wb25lbnROYW1lID0gdXBkYXRlUXVldWUucGVuZGluZyksXG4gICAgICAgICAgbnVsbCA9PT0gY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBjb21wb25lbnROYW1lLm5leHQpLFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZS5uZXh0ID0gdXBkYXRlKSksXG4gICAgICAgICAgKHVwZGF0ZVF1ZXVlLnBlbmRpbmcgPSB1cGRhdGUpLFxuICAgICAgICAgICh1cGRhdGUgPSBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKSksXG4gICAgICAgICAgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIG51bGwsIGxhbmUpLFxuICAgICAgICAgIHVwZGF0ZVxuICAgICAgICApO1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCB1cGRhdGVRdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSkge1xuICAgICAgZmliZXIgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiAoKGZpYmVyID0gZmliZXIuc2hhcmVkKSwgMCAhPT0gKGxhbmUgJiA0MTk0MDQ4KSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlTGFuZXMgPSBmaWJlci5sYW5lcztcbiAgICAgICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgbGFuZSB8PSBxdWV1ZUxhbmVzO1xuICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmU7XG4gICAgICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSxcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSwgcXVldWUgPT09IGN1cnJlbnQpXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbCxcbiAgICAgICAgICBuZXdMYXN0ID0gbnVsbDtcbiAgICAgICAgcXVldWUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogcXVldWUubGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBxdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHF1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZSlcbiAgICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNsb25lKTtcbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlIChudWxsICE9PSBxdWV1ZSk7XG4gICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgICAgICA6IChuZXdMYXN0ID0gbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgICB9IGVsc2UgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIHF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogY3VycmVudC5jYWxsYmFja3NcbiAgICAgICAgfTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgICAgIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgICAgaWYgKG51bGwgIT09IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBwcm9wcyxcbiAgICAgIGluc3RhbmNlJGpzY29tcCQwLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGUsXG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZSxcbiAgICAgICAgICBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbnVsbCA9PT0gbGFzdEJhc2VVcGRhdGVcbiAgICAgICAgICA/IChmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgOiAobGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSk7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUpLFxuICAgICAgICAgIHBlbmRpbmdRdWV1ZSAhPT0gbGFzdEJhc2VVcGRhdGUgJiZcbiAgICAgICAgICAgIChudWxsID09PSBwZW5kaW5nUXVldWVcbiAgICAgICAgICAgICAgPyAoY3VycmVudC5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgICAgIDogKHBlbmRpbmdRdWV1ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKSxcbiAgICAgICAgICAgIChjdXJyZW50Lmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUpKSk7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gZmlyc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSAwO1xuICAgICAgICBjdXJyZW50ID0gZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICBwZW5kaW5nUXVldWUgPSBmaXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5sYW5lICYgLTUzNjg3MDkxMyxcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gcGVuZGluZ1F1ZXVlLmxhbmU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAwICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UkanNjb21wJDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFydGlhbFN0YXRlLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgdXBkYXRlTGFuZS5mbGFncyA9ICh1cGRhdGVMYW5lLmZsYWdzICYgLTY1NTM3KSB8IDEyODtcbiAgICAgICAgICAgICAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gbmV4dFN0YXRlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVMYW5lLm1vZGUgJiA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGUpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IGFzc2lnbih7fSwgbmV3U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmNhbGxiYWNrO1xuICAgICAgICAgICAgbnVsbCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY0KSxcbiAgICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSBxdWV1ZS5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgICAgID8gKHF1ZXVlLmNhbGxiYWNrcyA9IFt1cGRhdGVMYW5lXSlcbiAgICAgICAgICAgICAgICA6IGlzSGlkZGVuVXBkYXRlLnB1c2godXBkYXRlTGFuZSkpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogcGVuZGluZ1F1ZXVlLmNhbGxiYWNrLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKChmaXJzdFBlbmRpbmdVcGRhdGUgPSBjdXJyZW50ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgICAgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpKVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgIChsYXN0QmFzZVVwZGF0ZSB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgICAgaWYgKCgocGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmcpLCBudWxsID09PSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcGVuZGluZ1F1ZXVlKSxcbiAgICAgICAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gaXNIaWRkZW5VcGRhdGUubmV4dCksXG4gICAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlLm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocXVldWUubGFzdEJhc2VVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbCk7XG4gICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50O1xuICAgICAgICBudWxsID09PSBmaXJzdEJhc2VVcGRhdGUgJiYgKHF1ZXVlLnNoYXJlZC5sYW5lcyA9IDApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiBcIiArXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICApO1xuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcbiAgICAgIGlmIChudWxsICE9PSBoaWRkZW5DYWxsYmFja3MpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGhpZGRlbkNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGhpZGRlbkNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSGlkZGVuQ29udGV4dChmaWJlciwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGVudGFuZ2xlZFJlbmRlckxhbmVzO1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICAgICAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyB8IGNvbnRleHQuYmFzZUxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgZmliZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoZmliZXIpIHtcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBwb3AoY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrLFxuICAgICAgICBoYW5kbGVyXG4gICAgICApO1xuICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlciwgaGFuZGxlcik7XG4gICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5ICYmXG4gICAgICAgIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgID8gKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKVxuICAgICAgICAgIDogbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmIChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRGVoeWRyYXRlZEFjdGl2aXR5U3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpO1xuICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkgJiYgKHNoZWxsQm91bmRhcnkgPSBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIDIyID09PSBmaWJlci50YWdcbiAgICAgICAgPyAocHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKSxcbiAgICAgICAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpLFxuICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkgJiYgKHNoZWxsQm91bmRhcnkgPSBmaWJlcikpXG4gICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpO1xuICAgICAgcHVzaChcbiAgICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIHBvcChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIgJiYgKHNoZWxsQm91bmRhcnkgPSBudWxsKTtcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSByb3c7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICBpZiAoMTMgPT09IG5vZGUudGFnKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IHN0YXRlICYmXG4gICAgICAgICAgICAoKHN0YXRlID0gc3RhdGUuZGVoeWRyYXRlZCksXG4gICAgICAgICAgICBudWxsID09PSBzdGF0ZSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN0YXRlKSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdGF0ZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgMTkgPT09IG5vZGUudGFnICYmXG4gICAgICAgICAgKFwiZm9yd2FyZHNcIiA9PT0gbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyIHx8XG4gICAgICAgICAgICBcImJhY2t3YXJkc1wiID09PSBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIgfHxcbiAgICAgICAgICAgIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiID09PSBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIgfHxcbiAgICAgICAgICAgIFwidG9nZXRoZXJcIiA9PT0gbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoMCAhPT0gKG5vZGUuZmxhZ3MgJiAxMjgpKSByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSByb3cpIGJyZWFrO1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IHJvdykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuICAgICAgbnVsbCA9PT0gaG9va1R5cGVzRGV2XG4gICAgICAgID8gKGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV0pXG4gICAgICAgIDogaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gICAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gaG9va1R5cGVzRGV2ICYmXG4gICAgICAgIChob29rVHlwZXNVcGRhdGVJbmRleERldisrLFxuICAgICAgICBob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSlcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgICBudWxsICE9PSBob29rVHlwZXNEZXYpXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAodmFyIHRhYmxlID0gXCJcIiwgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldLFxuICAgICAgICAgICAgICBuZXdIb29rTmFtZSA9XG4gICAgICAgICAgICAgICAgaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBob29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgb2xkSG9va05hbWUgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lO1xuICAgICAgICAgICAgICAzMCA+IG9sZEhvb2tOYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBvbGRIb29rTmFtZSArPSBcIiBcIjtcbiAgICAgICAgICAgIG9sZEhvb2tOYW1lICs9IG5ld0hvb2tOYW1lICsgXCJcXG5cIjtcbiAgICAgICAgICAgIHRhYmxlICs9IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4lcyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcblwiLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gICAgICB2b2lkIDAgPT09IGRlcHMgfHxcbiAgICAgICAgbnVsbCA9PT0gZGVwcyB8fFxuICAgICAgICBpc0FycmF5SW1wbChkZXBzKSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS5cIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICB0eXBlb2YgZGVwc1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlcik7XG4gICAgICBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgIChkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00udXNlRm9ybVN0YXRlIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVhY3QudXNlQWN0aW9uU3RhdGUuIFBsZWFzZSB1cGRhdGUgJXMgdG8gdXNlIFJlYWN0LnVzZUFjdGlvblN0YXRlLlwiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICAgICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSByZXR1cm4gITE7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldkRlcHMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuXCIsXG4gICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldlxuICAgICAgICAgICksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSBvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcblByZXZpb3VzOiAlc1xcbkluY29taW5nOiAlc1wiLFxuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgIFwiW1wiICsgcHJldkRlcHMuam9pbihcIiwgXCIpICsgXCJdXCIsXG4gICAgICAgICAgXCJbXCIgKyBuZXh0RGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIlxuICAgICAgICApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmcsXG4gICAgICBuZXh0UmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgfHxcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudClcbiAgICAgIClcbiAgICAgICAgKG5leHRSZW5kZXJMYW5lcyA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIpKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMobmV4dFJlbmRlckxhbmVzKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmFkZChuZXh0UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBpcyBhbiBhc3luYyBDbGllbnQgQ29tcG9uZW50LiBPbmx5IFNlcnZlciBDb21wb25lbnRzIGNhbiBiZSBhc3luYyBhdCB0aGUgbW9tZW50LiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIixcbiAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgPyBcIkFuIHVua25vd24gQ29tcG9uZW50XCJcbiAgICAgICAgICAgICAgICA6IFwiPFwiICsgbmV4dFJlbmRlckxhbmVzICsgXCI+XCJcbiAgICAgICAgICAgICkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDA7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICA6IG51bGwgIT09IGhvb2tUeXBlc0RldlxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gbmV4dFJlbmRlckxhbmVzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSAhPT0gTm9Nb2RlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmXG4gICAgICAgIChjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgKSk7XG4gICAgICBpZiAobmV4dFJlbmRlckxhbmVzKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHNlY29uZEFyZ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgPyBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgICAgZmlyc3RDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgICAgIH0pXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcy5fZGVidWdUaGVuYWJsZVN0YXRlID0gdGhlbmFibGVTdGF0ZSk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiYgbnVsbCAhPT0gY3VycmVudEhvb2submV4dDtcbiAgICAgIHJlbmRlckxhbmVzID0gMDtcbiAgICAgIGhvb2tUeXBlc0RldiA9XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIChjdXJyZW50LmZsYWdzICYgNjUwMTE3MTIpICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiA2NTAxMTcxMikgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCBzdGF0aWMgZmxhZyB3YXMgbWlzc2luZy4gUGxlYXNlIG5vdGlmeSB0aGUgUmVhY3QgdGVhbS5cIlxuICAgICAgICApO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgZWFybHkgcmV0dXJuIHN0YXRlbWVudC5cIlxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSAmJlxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITApKTtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWXG4gICAgICAgID8gKChuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExKSwgKGN1cnJlbnQgPSAhMCkpXG4gICAgICAgIDogKGN1cnJlbnQgPSAhMSk7XG4gICAgICBjdXJyZW50ICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guYWRkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJgdXNlYCB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgdHJ5L2NhdGNoIGJsb2NrLiBUaGlzIGlzIG5vdCBhbGxvd2VkIGFuZCBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLiBUbyBoYW5kbGUgZXJyb3JzIHRyaWdnZXJlZCBieSBgdXNlYCwgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhIGVycm9yIGJvdW5kYXJ5LlwiXG4gICAgICAgICAgKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmICh0aGVuYWJsZVN0YXRlID0gbnVsbCk7XG4gICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcbiAgICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGNoaWxkcmVuLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLmV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgY2hpbGRyZW4uc3RvcmVzID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9IGNoaWxkcmVuLm1lbW9DYWNoZSAmJiAoY2hpbGRyZW4ubWVtb0NhY2hlLmluZGV4ID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgY2hpbGRyZW4gPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgsXG4gICAgICAgIG1heWJlVGhlbmFibGUgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gICAgICBtYXliZVRoZW5hYmxlID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVUaGVuYWJsZS50aGVuXG4gICAgICAgICAgPyB1c2VUaGVuYWJsZShtYXliZVRoZW5hYmxlKVxuICAgICAgICAgIDogbWF5YmVUaGVuYWJsZTtcbiAgICAgIGRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gICAgICAobnVsbCAhPT0gY3VycmVudEhvb2sgPyBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbCkgIT09XG4gICAgICAgIGRpc3BhdGNoZXIgJiYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmZsYWdzIHw9IDEwMjQpO1xuICAgICAgcmV0dXJuIG1heWJlVGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAgICAgdmFyIGRpZFJlbmRlcklkSG9vayA9IDAgIT09IGxvY2FsSWRDb3VudGVyO1xuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPVxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlXG4gICAgICAgICAgPyB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC00MDI2NTUyMzdcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTIwNTM7XG4gICAgICBjdXJyZW50LmxhbmVzICY9IH5sYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy5xdWV1ZTtcbiAgICAgICAgICBudWxsICE9PSBxdWV1ZSAmJiAocXVldWUucGVuZGluZyA9IG51bGwpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB9XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBjdXJyZW50SG9vayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID1cbiAgICAgICAgICBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICB2YXIgaG9vayA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICAgICAgYmFzZVN0YXRlOiBudWxsLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2spO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRIb29rKSB7XG4gICAgICAgIHZhciBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9XG4gICAgICAgICAgbnVsbCAhPT0gbmV4dEN1cnJlbnRIb29rID8gbmV4dEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgfSBlbHNlIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gY3VycmVudGx5UmVuZGVyaW5nRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgICBpZiAobnVsbCAhPT0gbmV4dFdvcmtJblByb2dyZXNzSG9vaylcbiAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2spLFxuICAgICAgICAgIChjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vayk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT09IG5leHRDdXJyZW50SG9vaykge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5hbHRlcm5hdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJVcGRhdGUgaG9vayBjYWxsZWQgb24gaW5pdGlhbCByZW5kZXIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9IHtcbiAgICAgICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICAgICAgICBuZXh0Q3VycmVudEhvb2spXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpIHtcbiAgICAgIHJldHVybiB7IGxhc3RFZmZlY3Q6IG51bGwsIGV2ZW50czogbnVsbCwgc3RvcmVzOiBudWxsLCBtZW1vQ2FjaGU6IG51bGwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgdGhlbmFibGUgPSB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgICAgaW5kZXggPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcjtcbiAgICAgIG51bGwgPT09XG4gICAgICAgIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSAmJlxuICAgICAgICAoKGluZGV4ID0gaW5kZXguYWx0ZXJuYXRlKSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPVxuICAgICAgICAgIG51bGwgIT09IGluZGV4ICYmIG51bGwgIT09IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVlxuICAgICAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYpKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICAgICAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1c2FibGUudGhlbikgcmV0dXJuIHVzZVRoZW5hYmxlKHVzYWJsZSk7XG4gICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgcmV0dXJuIHJlYWRDb250ZXh0KHVzYWJsZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU1lbW9DYWNoZShzaXplKSB7XG4gICAgICB2YXIgbWVtb0NhY2hlID0gbnVsbCxcbiAgICAgICAgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgIT09IHVwZGF0ZVF1ZXVlICYmIChtZW1vQ2FjaGUgPSB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUpO1xuICAgICAgaWYgKG51bGwgPT0gbWVtb0NhY2hlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vQ2FjaGUpLFxuICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIChtZW1vQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY3VycmVudC5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICBudWxsID09IG1lbW9DYWNoZSAmJiAobWVtb0NhY2hlID0geyBkYXRhOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgICBudWxsID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICAgICAoKHVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUpKTtcbiAgICAgIHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSA9IG1lbW9DYWNoZTtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHVwZGF0ZVF1ZXVlIHx8IGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XSA9IEFycmF5KHNpemUpLFxuICAgICAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICAgICAgY3VycmVudCA8IHNpemU7XG4gICAgICAgICAgY3VycmVudCsrXG4gICAgICAgIClcbiAgICAgICAgICB1cGRhdGVRdWV1ZVtjdXJyZW50XSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICBlbHNlXG4gICAgICAgIHVwZGF0ZVF1ZXVlLmxlbmd0aCAhPT0gc2l6ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgY29uc3RhbnQgc2l6ZSBhcmd1bWVudCBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mIHVzZU1lbW9DYWNoZS4gVGhlIHByZXZpb3VzIGNhY2hlIHdhcyBhbGxvY2F0ZWQgd2l0aCBzaXplICVzIGJ1dCBzaXplICVzIHdhcyByZXF1ZXN0ZWQuXCIsXG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICBzaXplXG4gICAgICAgICAgKTtcbiAgICAgIG1lbW9DYWNoZS5pbmRleCsrO1xuICAgICAgcmV0dXJuIHVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGluaXQpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIHJlZHVjZXIgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIGhvb2sucXVldWUgPSByZWR1Y2VyO1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50SG9vaywgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnQsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gcXVldWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpXCJcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgdmFyIGJhc2VRdWV1ZSA9IGhvb2suYmFzZVF1ZXVlLFxuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICBwZW5kaW5nUXVldWUgPSBob29rLmJhc2VTdGF0ZTtcbiAgICAgIGlmIChudWxsID09PSBiYXNlUXVldWUpIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IChiYXNlRmlyc3QgPSBudWxsKSxcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbCxcbiAgICAgICAgICB1cGRhdGUgPSBjdXJyZW50LFxuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmUgJiAtNTM2ODcwOTEzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgIT09IHVwZGF0ZS5sYW5lXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJldmVydExhbmUgPSB1cGRhdGUucmV2ZXJ0TGFuZTtcbiAgICAgICAgICAgIGlmICgwID09PSByZXZlcnRMYW5lKVxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdCYXNlUXVldWVMYXN0ICYmXG4gICAgICAgICAgICAgICAgKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICBnZXN0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgZWxzZSBpZiAoKHJlbmRlckxhbmVzICYgcmV2ZXJ0TGFuZSkgPT09IHJldmVydExhbmUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgICAgICAgIHJldmVydExhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICh1cGRhdGVMYW5lID0ge1xuICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICAgICAgZ2VzdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5sYW5lcyB8PSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHJldmVydExhbmUpO1xuICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViAmJlxuICAgICAgICAgICAgICByZWR1Y2VyKHBlbmRpbmdRdWV1ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgICBwZW5kaW5nUXVldWUgPSB1cGRhdGUuaGFzRWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA/IHVwZGF0ZS5lYWdlclN0YXRlXG4gICAgICAgICAgICAgIDogcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKHJldmVydExhbmUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICBnZXN0dXJlOiB1cGRhdGUuZ2VzdHVyZSxcbiAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIubGFuZXMgfD0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gdXBkYXRlTGFuZSk7XG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKG51bGwgIT09IHVwZGF0ZSAmJiB1cGRhdGUgIT09IGN1cnJlbnQpO1xuICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgPyAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvYmplY3RJcyhwZW5kaW5nUXVldWUsIGhvb2subWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiAmJlxuICAgICAgICAgICAgKChyZWR1Y2VyID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSwgbnVsbCAhPT0gcmVkdWNlcikpXG4gICAgICAgIClcbiAgICAgICAgICB0aHJvdyByZWR1Y2VyO1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIGhvb2suYmFzZVN0YXRlID0gYmFzZUZpcnN0O1xuICAgICAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG4gICAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgfVxuICAgICAgbnVsbCA9PT0gYmFzZVF1ZXVlICYmIChxdWV1ZS5sYW5lcyA9IDApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSBxdWV1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBZb3UgYXJlIGxpa2VseSBjYWxsaW5nIEhvb2tzIGNvbmRpdGlvbmFsbHksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbClcIlxuICAgICAgICApO1xuICAgICAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCxcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZyxcbiAgICAgICAgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgdXBkYXRlID0gKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0KTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCB1cGRhdGUuYWN0aW9uKSksICh1cGRhdGUgPSB1cGRhdGUubmV4dCk7XG4gICAgICAgIHdoaWxlICh1cGRhdGUgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgIG9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgbnVsbCA9PT0gaG9vay5iYXNlUXVldWUgJiYgKGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGUpO1xuICAgICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk1pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCB8fFxuICAgICAgICAgIG5leHRTbmFwc2hvdCA9PT0gZ2V0U2VydmVyU25hcHNob3QoKSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICAoKGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKSksXG4gICAgICAgICAgb2JqZWN0SXMobmV4dFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgMTI3KSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSB7IHZhbHVlOiBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9O1xuICAgICAgaG9vay5xdWV1ZSA9IGdldFNlcnZlclNuYXBzaG90O1xuICAgICAgbW91bnRFZmZlY3QoXG4gICAgICAgIHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgZ2V0U2VydmVyU25hcHNob3QsIHN1YnNjcmliZSksXG4gICAgICAgIFtzdWJzY3JpYmVdXG4gICAgICApO1xuICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgIHB1c2hTaW1wbGVFZmZlY3QoXG4gICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgIG5leHRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgICApLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCA9IGlzSHlkcmF0aW5nO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nJGpzY29tcCQwKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoKGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKSksICFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdClcbiAgICAgICkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBvYmplY3RJcyhnZXRTZXJ2ZXJTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChjYWNoZWRTbmFwc2hvdCA9ICFvYmplY3RJcyhcbiAgICAgICAgICAoY3VycmVudEhvb2sgfHwgaG9vaykubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApKVxuICAgICAgKVxuICAgICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gZ2V0U2VydmVyU25hcHNob3QpLCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgIGhvb2sgPSBob29rLnF1ZXVlO1xuICAgICAgdmFyIGNyZWF0ZSA9IHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaG9vaywgc3Vic2NyaWJlKTtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBbc3Vic2NyaWJlXSk7XG4gICAgICBpZiAoXG4gICAgICAgIGhvb2suZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8XG4gICAgICAgIGNhY2hlZFNuYXBzaG90IHx8XG4gICAgICAgIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2sgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiBIYXNFZmZlY3QpXG4gICAgICApIHtcbiAgICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgICAgcHVzaFNpbXBsZUVmZmVjdChcbiAgICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgaG9vayxcbiAgICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgICApLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaXNIeWRyYXRpbmckanNjb21wJDAgfHxcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiAxMjcpIHx8XG4gICAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgICAgIGZpYmVyLmZsYWdzIHw9IDE2Mzg0O1xuICAgICAgZmliZXIgPSB7IGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCwgdmFsdWU6IHJlbmRlcmVkU25hcHNob3QgfTtcbiAgICAgIGdldFNuYXBzaG90ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBnZXRTbmFwc2hvdFxuICAgICAgICA/ICgoZ2V0U25hcHNob3QgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci51cGRhdGVRdWV1ZSA9IGdldFNuYXBzaG90KSxcbiAgICAgICAgICAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSkpXG4gICAgICAgIDogKChyZW5kZXJlZFNuYXBzaG90ID0gZ2V0U25hcHNob3Quc3RvcmVzKSxcbiAgICAgICAgICBudWxsID09PSByZW5kZXJlZFNuYXBzaG90XG4gICAgICAgICAgICA/IChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKVxuICAgICAgICAgICAgOiByZW5kZXJlZFNuYXBzaG90LnB1c2goZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCkge1xuICAgICAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcbiAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJlxuICAgICAgICAgIChzdGFydFVwZGF0ZVRpbWVyQnlMYW5lKDIsIFwidXBkYXRlU3luY0V4dGVybmFsU3RvcmUoKVwiLCBmaWJlciksXG4gICAgICAgICAgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICAgICAgaW5zdCA9IGluc3QudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIGhvb2sucXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSk7XG4gICAgICB2YXIgcXVldWUgPSBpbml0aWFsU3RhdGUucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLCBxdWV1ZSk7XG4gICAgICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGUubWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICB2YXIgcXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IG51bGxcbiAgICAgIH07XG4gICAgICBob29rLnF1ZXVlID0gcXVldWU7XG4gICAgICBob29rID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgICEwLFxuICAgICAgICBxdWV1ZVxuICAgICAgKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gaG9vaztcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnQsIHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vayxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVkdWNlciA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRIb29rKVxuICAgICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rLnF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHBheWxvYWRcbiAgICApIHtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGZvcm0gc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgIGZpYmVyID0gYWN0aW9uUXVldWUuYWN0aW9uO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgIHZhciBhY3Rpb25Ob2RlID0ge1xuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgYWN0aW9uOiBmaWJlcixcbiAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgIGlzVHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGFjdGlvbk5vZGUubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVFxuICAgICAgICAgID8gc2V0UGVuZGluZ1N0YXRlKCEwKVxuICAgICAgICAgIDogKGFjdGlvbk5vZGUuaXNUcmFuc2l0aW9uID0gITEpO1xuICAgICAgICBzZXRTdGF0ZShhY3Rpb25Ob2RlKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgICAgbnVsbCA9PT0gc2V0UGVuZGluZ1N0YXRlXG4gICAgICAgICAgPyAoKGFjdGlvbk5vZGUubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKSlcbiAgICAgICAgICA6ICgoYWN0aW9uTm9kZS5uZXh0ID0gc2V0UGVuZGluZ1N0YXRlLm5leHQpLFxuICAgICAgICAgICAgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCA9IGFjdGlvbk5vZGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5vZGUpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbixcbiAgICAgICAgcGF5bG9hZCA9IG5vZGUucGF5bG9hZCxcbiAgICAgICAgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGU7XG4gICAgICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpLFxuICAgICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIG51bGwgIT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcyAmJlxuICAgICAgICAgICAgKG51bGwgIT09IHByZXZUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uLnR5cGVzICE9PSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcyAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiV2UgZXhwZWN0ZWQgaW5uZXIgVHJhbnNpdGlvbnMgdG8gaGF2ZSB0cmFuc2ZlcnJlZCB0aGUgb3V0ZXIgdHlwZXMgc2V0IGFuZCB0aGF0IHlvdSBjYW5ub3QgYWRkIHRvIHRoZSBvdXRlciBUcmFuc2l0aW9uIHdoaWxlIGluc2lkZSB0aGUgaW5uZXIuVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHByZXZUcmFuc2l0aW9uLnR5cGVzID0gY3VycmVudFRyYW5zaXRpb24udHlwZXMpKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAgICAgKChhY3Rpb25RdWV1ZSA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgICAgICAxMCA8IGFjdGlvblF1ZXVlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAoY3VycmVudFRyYW5zaXRpb24gPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKSksXG4gICAgICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgY3VycmVudFRyYW5zaXRpb24pO1xuICAgICAgICB9IGNhdGNoIChlcnJvciQyKSB7XG4gICAgICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IkMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKSB7XG4gICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICAgID8gKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFzeW5jVHJhbnNpdGlvbnMrKyxcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKHJlbGVhc2VBc3luY1RyYW5zaXRpb24sIHJlbGVhc2VBc3luY1RyYW5zaXRpb24pLFxuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGUuaXNUcmFuc2l0aW9uIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkFuIGFzeW5jIGZ1bmN0aW9uIHdpdGggdXNlQWN0aW9uU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIGEgdHJhbnNpdGlvbi4gVGhpcyBpcyBsaWtlbHkgbm90IHdoYXQgeW91IGludGVuZGVkIChmb3IgZXhhbXBsZSwgaXNQZW5kaW5nIHdpbGwgbm90IHVwZGF0ZSBjb3JyZWN0bHkpLiBFaXRoZXIgY2FsbCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbiwgb3IgcGFzcyBpdCB0byBhbiBgYWN0aW9uYCBvciBgZm9ybUFjdGlvbmAgcHJvcC5cIlxuICAgICAgICAgICAgKSlcbiAgICAgICAgOiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlLCBuZXh0U3RhdGUpIHtcbiAgICAgIGFjdGlvbk5vZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIGFjdGlvbk5vZGUudmFsdWUgPSBuZXh0U3RhdGU7XG4gICAgICBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSk7XG4gICAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGFjdGlvbk5vZGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCAhPT0gYWN0aW9uTm9kZSAmJlxuICAgICAgICAoKG5leHRTdGF0ZSA9IGFjdGlvbk5vZGUubmV4dCksXG4gICAgICAgIG5leHRTdGF0ZSA9PT0gYWN0aW9uTm9kZVxuICAgICAgICAgID8gKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsKVxuICAgICAgICAgIDogKChuZXh0U3RhdGUgPSBuZXh0U3RhdGUubmV4dCksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZS5uZXh0ID0gbmV4dFN0YXRlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBuZXh0U3RhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIGVycm9yKSB7XG4gICAgICB2YXIgbGFzdCA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9PSBsYXN0KSB7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgICAgIGRvXG4gICAgICAgICAgKGFjdGlvbk5vZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLnJlYXNvbiA9IGVycm9yKSxcbiAgICAgICAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlID0gYWN0aW9uTm9kZS5uZXh0KTtcbiAgICAgICAgd2hpbGUgKGFjdGlvbk5vZGUgIT09IGxhc3QpO1xuICAgICAgfVxuICAgICAgYWN0aW9uUXVldWUuYWN0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpIHtcbiAgICAgIGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLmxpc3RlbmVycztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uTm9kZS5sZW5ndGg7IGkrKykgKDAsIGFjdGlvbk5vZGVbaV0pKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlUmVkdWNlcihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZVByb3ApIHtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgc3NyRm9ybVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290LmZvcm1TdGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHNzckZvcm1TdGF0ZSkge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciBpc01hdGNoaW5nID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXI7XG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VySW5zdGFuY2UgPSBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyKFxuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBpc01hdGNoaW5nID0gaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goaXNNYXRjaGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc01hdGNoaW5nID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTWF0Y2hpbmcgJiYgKGluaXRpYWxTdGF0ZVByb3AgPSBzc3JGb3JtU3RhdGVbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzc3JGb3JtU3RhdGUgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgc3NyRm9ybVN0YXRlLm1lbW9pemVkU3RhdGUgPSBzc3JGb3JtU3RhdGUuYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlUHJvcDtcbiAgICAgIGlzTWF0Y2hpbmcgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYWN0aW9uU3RhdGVSZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlUHJvcFxuICAgICAgfTtcbiAgICAgIHNzckZvcm1TdGF0ZS5xdWV1ZSA9IGlzTWF0Y2hpbmc7XG4gICAgICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLFxuICAgICAgICBpc01hdGNoaW5nXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZy5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICB2YXIgc2V0UGVuZGluZ1N0YXRlID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgICExLFxuICAgICAgICBpc01hdGNoaW5nLnF1ZXVlXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZyA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBtYXJrZXJJbnN0YW5jZSA9IHtcbiAgICAgICAgc3RhdGU6IGluaXRpYWxTdGF0ZVByb3AsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgcGVuZGluZzogbnVsbFxuICAgICAgfTtcbiAgICAgIGlzTWF0Y2hpbmcucXVldWUgPSBtYXJrZXJJbnN0YW5jZTtcbiAgICAgIHNzckZvcm1TdGF0ZSA9IGRpc3BhdGNoQWN0aW9uU3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgIG1hcmtlckluc3RhbmNlLFxuICAgICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICAgIHNzckZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIG1hcmtlckluc3RhbmNlLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICAgICAgaXNNYXRjaGluZy5tZW1vaXplZFN0YXRlID0gYWN0aW9uO1xuICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGVQcm9wLCBzc3JGb3JtU3RhdGUsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKSB7XG4gICAgICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudEhvb2ssIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbikge1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBzdGF0ZUhvb2ssXG4gICAgICAgIGN1cnJlbnRTdGF0ZUhvb2ssXG4gICAgICAgIGFjdGlvblN0YXRlUmVkdWNlclxuICAgICAgKVswXTtcbiAgICAgIHN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sudGhlblxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHVzZVRoZW5hYmxlKGN1cnJlbnRTdGF0ZUhvb2spO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgaWYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB0aHJvdyBTdXNwZW5zZUFjdGlvbkV4Y2VwdGlvbjtcbiAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICB9XG4gICAgICBlbHNlIHN0YXRlID0gY3VycmVudFN0YXRlSG9vaztcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHZhciBhY3Rpb25RdWV1ZSA9IGN1cnJlbnRTdGF0ZUhvb2sucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7XG4gICAgICBhY3Rpb24gIT09IGN1cnJlbnRTdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICBwdXNoU2ltcGxlRWZmZWN0KFxuICAgICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSk7XG4gICAgICByZXR1cm4gW3N0YXRlLCBkaXNwYXRjaCwgc3RhdGVIb29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QoYWN0aW9uUXVldWUsIGFjdGlvbikge1xuICAgICAgYWN0aW9uUXVldWUuYWN0aW9uID0gYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rID0gY3VycmVudEhvb2s7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gICAgICB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXRlSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgdmFyIGRpc3BhdGNoID0gY3VycmVudFN0YXRlSG9vay5xdWV1ZS5kaXNwYXRjaDtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbc3RhdGVIb29rLCBkaXNwYXRjaCwgITFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2ltcGxlRWZmZWN0KHRhZywgaW5zdCwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB0YWcgPSB7IHRhZzogdGFnLCBjcmVhdGU6IGNyZWF0ZSwgZGVwczogZGVwcywgaW5zdDogaW5zdCwgbmV4dDogbnVsbCB9O1xuICAgICAgaW5zdCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCA9PT0gaW5zdCAmJlxuICAgICAgICAoKGluc3QgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIudXBkYXRlUXVldWUgPSBpbnN0KSk7XG4gICAgICBjcmVhdGUgPSBpbnN0Lmxhc3RFZmZlY3Q7XG4gICAgICBudWxsID09PSBjcmVhdGVcbiAgICAgICAgPyAoaW5zdC5sYXN0RWZmZWN0ID0gdGFnLm5leHQgPSB0YWcpXG4gICAgICAgIDogKChkZXBzID0gY3JlYXRlLm5leHQpLFxuICAgICAgICAgIChjcmVhdGUubmV4dCA9IHRhZyksXG4gICAgICAgICAgKHRhZy5uZXh0ID0gZGVwcyksXG4gICAgICAgICAgKGluc3QubGFzdEVmZmVjdCA9IHRhZykpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpbml0aWFsVmFsdWUgPSB7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9O1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoU2ltcGxlRWZmZWN0KFxuICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgaW5zdCA9IGhvb2subWVtb2l6ZWRTdGF0ZS5pbnN0O1xuICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiZcbiAgICAgIG51bGwgIT09IGRlcHMgJiZcbiAgICAgIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLmRlcHMpXG4gICAgICAgID8gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hTaW1wbGVFZmZlY3QoaG9va0ZsYWdzLCBpbnN0LCBjcmVhdGUsIGRlcHMpKVxuICAgICAgICA6ICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hTaW1wbGVFZmZlY3QoXG4gICAgICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY3JlYXRlLFxuICAgICAgICAgICAgZGVwc1xuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIubW9kZSAmIDE2KSAhPT0gTm9Nb2RlXG4gICAgICAgID8gbW91bnRFZmZlY3RJbXBsKDI3NjgyNjExMiwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKVxuICAgICAgICA6IG1vdW50RWZmZWN0SW1wbCg4MzkwNjU2LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VFZmZlY3RFdmVudEltcGwocGF5bG9hZCkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZmxhZ3MgfD0gNDtcbiAgICAgIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IGNvbXBvbmVudFVwZGF0ZVF1ZXVlKVxuICAgICAgICAoY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAoY29tcG9uZW50VXBkYXRlUXVldWUuZXZlbnRzID0gW3BheWxvYWRdKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZXZlbnRzID0gY29tcG9uZW50VXBkYXRlUXVldWUuZXZlbnRzO1xuICAgICAgICBudWxsID09PSBldmVudHNcbiAgICAgICAgICA/IChjb21wb25lbnRVcGRhdGVRdWV1ZS5ldmVudHMgPSBbcGF5bG9hZF0pXG4gICAgICAgICAgOiBldmVudHMucHVzaChwYXlsb2FkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFdmVudChjYWxsYmFjaykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICByZWYgPSB7IGltcGw6IGNhbGxiYWNrIH07XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBIGZ1bmN0aW9uIHdyYXBwZWQgaW4gdXNlRWZmZWN0RXZlbnQgY2FuJ3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVmLmltcGwuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgIHZhciByZWYgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgdXNlRWZmZWN0RXZlbnRJbXBsKHsgcmVmOiByZWYsIG5leHRJbXBsOiBjYWxsYmFjayB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkEgZnVuY3Rpb24gd3JhcHBlZCBpbiB1c2VFZmZlY3RFdmVudCBjYW4ndCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiByZWYuaW1wbC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gNDE5NDMwODtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gMTM0MjE3NzI4KTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgICB2YXIgcmVmQ2xlYW51cCA9IHJlZihjcmVhdGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXAgPyByZWZDbGVhbnVwKCkgOiByZWYobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gcmVmICYmIHZvaWQgMCAhPT0gcmVmKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlZi5oYXNPd25Qcm9wZXJ0eShcImN1cnJlbnRcIikgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhIHJlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgICBcImFuIG9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMocmVmKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY3JlYXRlID0gY3JlYXRlKCkpLFxuICAgICAgICAgIChyZWYuY3VycmVudCA9IGNyZWF0ZSksXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gNDE5NDMwODtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gMTM0MjE3NzI4KTtcbiAgICAgIG1vdW50RWZmZWN0SW1wbChcbiAgICAgICAgZmliZXJGbGFncyxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoXG4gICAgICAgIDQsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgIF07XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBkZXBzXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgcHJldlN0YXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbcHJldlN0YXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50SG9va1xuICAgICAgICA/IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSlcbiAgICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdm9pZCAwID09PSBpbml0aWFsVmFsdWUgfHxcbiAgICAgICAgKDAgIT09IChyZW5kZXJMYW5lcyAmIDEwNzM3NDE4MjQpICYmXG4gICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgMjYxOTMwKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBpZiAob2JqZWN0SXModmFsdWUsIHByZXZWYWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGhvb2sgPSBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpKSxcbiAgICAgICAgICBvYmplY3RJcyhob29rLCBwcmV2VmFsdWUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApLFxuICAgICAgICAgIGhvb2tcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKHJlbmRlckxhbmVzICYgNDIpIHx8XG4gICAgICAgICgwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSAmJlxuICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDI2MTkzMCkpXG4gICAgICApXG4gICAgICAgIHJldHVybiAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSwgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgICAgIGhvb2sgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQXN5bmNUcmFuc2l0aW9uKCkge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYXN5bmNUcmFuc2l0aW9ucy0tO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KFxuICAgICAgICAwICE9PSBwcmV2aW91c1ByaW9yaXR5ICYmIDggPiBwcmV2aW91c1ByaW9yaXR5ID8gcHJldmlvdXNQcmlvcml0eSA6IDhcbiAgICAgICk7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgITEsIHF1ZXVlLCBwZW5kaW5nU3RhdGUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gY2FsbGJhY2soKSxcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICAgICApIHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5hc3luY1RyYW5zaXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihyZWxlYXNlQXN5bmNUcmFuc2l0aW9uLCByZWxlYXNlQXN5bmNUcmFuc2l0aW9uKTtcbiAgICAgICAgICB2YXIgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlID0gY2hhaW5UaGVuYWJsZVZhbHVlKFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICBmaW5pc2hlZFN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIHsgdGhlbjogZnVuY3Rpb24gKCkge30sIHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb246IGVycm9yIH0sXG4gICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgbnVsbCAhPT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gcHJldlRyYW5zaXRpb24udHlwZXMgJiZcbiAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb24udHlwZXMgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBleHBlY3RlZCBpbm5lciBUcmFuc2l0aW9ucyB0byBoYXZlIHRyYW5zZmVycmVkIHRoZSBvdXRlciB0eXBlcyBzZXQgYW5kIHRoYXQgeW91IGNhbm5vdCBhZGQgdG8gdGhlIG91dGVyIFRyYW5zaXRpb24gd2hpbGUgaW5zaWRlIHRoZSBpbm5lci5UaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocHJldlRyYW5zaXRpb24udHlwZXMgPSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgIDEwIDwgZmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikge1xuICAgICAgdmFyIGV4aXN0aW5nU3RhdGVIb29rID0gZm9ybUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZXhpc3RpbmdTdGF0ZUhvb2spIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICB2YXIgaW5pdGlhbFJlc2V0U3RhdGUgPSB7fTtcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rLm5leHQgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgICBmb3JtRmliZXIgPSBmb3JtRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZm9ybUZpYmVyICYmIChmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rKTtcbiAgICAgIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgc3RhdGVIb29rLnF1ZXVlLFxuICAgICAgICAhMCxcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2s7XG4gICAgICByZXR1cm4gWyExLCBzdGF0ZUhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGJvb2xlYW5PclRoZW5hYmxlID0gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF0sXG4gICAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICAgIHN0YXJ0XG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgICBzdGFydCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgPyBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgICBzdGFydFxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoSG9zdFRyYW5zaXRpb25Db250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRJZCgpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCA9IHdvcmtJblByb2dyZXNzUm9vdC5pZGVudGlmaWVyUHJlZml4O1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciB0cmVlSWQgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICAgIHRyZWVJZCA9XG4gICAgICAgICAgKFxuICAgICAgICAgICAgaWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCAoMzIgLSBjbHozMihpZFdpdGhMZWFkaW5nQml0KSAtIDEpKVxuICAgICAgICAgICkudG9TdHJpbmcoMzIpICsgdHJlZUlkO1xuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gXCJfXCIgKyBpZGVudGlmaWVyUHJlZml4ICsgXCJSX1wiICsgdHJlZUlkO1xuICAgICAgICB0cmVlSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICAgICAgICAwIDwgdHJlZUlkICYmIChpZGVudGlmaWVyUHJlZml4ICs9IFwiSFwiICsgdHJlZUlkLnRvU3RyaW5nKDMyKSk7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggKz0gXCJfXCI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRyZWVJZCA9IGdsb2JhbENsaWVudElkQ291bnRlcisrKSxcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgICAgICBcIl9cIiArIGlkZW50aWZpZXJQcmVmaXggKyBcInJfXCIgKyB0cmVlSWQudG9TdHJpbmcoMzIpICsgXCJfXCIpO1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWZyZXNoKCkge1xuICAgICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXJcbiAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWZyZXNoQ2FjaGUoZmliZXIsIHNlZWRLZXkpIHtcbiAgICAgIGZvciAodmFyIHByb3ZpZGVyID0gZmliZXIucmV0dXJuOyBudWxsICE9PSBwcm92aWRlcjsgKSB7XG4gICAgICAgIHN3aXRjaCAocHJvdmlkZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKHByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgcmVmcmVzaFVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKSxcbiAgICAgICAgICAgICAgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIHJlZnJlc2hVcGRhdGUsIGxhbmUpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoc3RhcnRVcGRhdGVUaW1lckJ5TGFuZShsYW5lLCBcInJlZnJlc2goKVwiLCBmaWJlciksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgICAgIGZpYmVyID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgIG51bGwgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWZyZXNoVXBkYXRlLnBheWxvYWQgPSB7IGNhY2hlOiBmaWJlciB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXJnc1szXSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBhcmdzID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgbGFuZTogYXJncyxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgZ2VzdHVyZTogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcilcbiAgICAgICAgPyBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZSA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgYXJncykpLFxuICAgICAgICAgIG51bGwgIT09IHVwZGF0ZSAmJlxuICAgICAgICAgICAgKHN0YXJ0VXBkYXRlVGltZXJCeUxhbmUoYXJncywgXCJkaXNwYXRjaCgpXCIsIGZpYmVyKSxcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcih1cGRhdGUsIGZpYmVyLCBhcmdzKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZSh1cGRhdGUsIHF1ZXVlLCBhcmdzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFyZ3NbM10gJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS5cIlxuICAgICAgICApO1xuICAgICAgYXJncyA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgYXJncykgJiZcbiAgICAgICAgc3RhcnRVcGRhdGVUaW1lckJ5TGFuZShhcmdzLCBcInNldFN0YXRlKClcIiwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZmliZXIsIHF1ZXVlLCBhY3Rpb24sIGxhbmUpIHtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGxhbmU6IGxhbmUsXG4gICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgIGdlc3R1cmU6IG51bGwsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAwID09PSBmaWJlci5sYW5lcyAmJlxuICAgICAgICAgIChudWxsID09PSBhbHRlcm5hdGUgfHwgMCA9PT0gYWx0ZXJuYXRlLmxhbmVzKSAmJlxuICAgICAgICAgICgoYWx0ZXJuYXRlID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciksIG51bGwgIT09IGFsdGVybmF0ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZSA9IGFsdGVybmF0ZShjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB1cGRhdGUuaGFzRWFnZXJTdGF0ZSA9ICEwO1xuICAgICAgICAgICAgdXBkYXRlLmVhZ2VyU3RhdGUgPSBlYWdlclN0YXRlO1xuICAgICAgICAgICAgaWYgKG9iamVjdElzKGVhZ2VyU3RhdGUsIGN1cnJlbnRTdGF0ZSkpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCAwKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgaWYgKG51bGwgIT09IGFjdGlvbilcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFjdGlvbiwgZmliZXIsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKGFjdGlvbiwgcXVldWUsIGxhbmUpLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgdGhyb3dJZkR1cmluZ1JlbmRlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgIDAgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBbiBvcHRpbWlzdGljIHN0YXRlIHVwZGF0ZSBvY2N1cnJlZCBvdXRzaWRlIGEgdHJhbnNpdGlvbiBvciBhY3Rpb24uIFRvIGZpeCwgbW92ZSB0aGUgdXBkYXRlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgYWN0aW9uID0ge1xuICAgICAgICBsYW5lOiAyLFxuICAgICAgICByZXZlcnRMYW5lOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSxcbiAgICAgICAgZ2VzdHVyZTogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgICAgIGlmICh0aHJvd0lmRHVyaW5nUmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgY2FsbCBzdGFydFRyYW5zaXRpb24gd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodGhyb3dJZkR1cmluZ1JlbmRlciA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgMlxuICAgICAgICApKSxcbiAgICAgICAgICBudWxsICE9PSB0aHJvd0lmRHVyaW5nUmVuZGVyICYmXG4gICAgICAgICAgICAoc3RhcnRVcGRhdGVUaW1lckJ5TGFuZSgyLCBcInNldE9wdGltaXN0aWMoKVwiLCBmaWJlciksXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIodGhyb3dJZkR1cmluZ1JlbmRlciwgZmliZXIsIDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciB8fFxuICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwO1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gICAgICBpZiAoMCAhPT0gKGxhbmUgJiA0MTk0MDQ4KSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIHF1ZXVlLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuICAgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkgfHxcbiAgICAgICAgICAoZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgIG5leHRQcm9wc1xuICAgICkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICAoKGN0b3IgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY3RvcikgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjdG9yKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICApKSk7XG4gICAgICBwcmV2U3RhdGUgPVxuICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICA/IHByZXZTdGF0ZVxuICAgICAgICAgIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBvbGRQcm9wcyA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICBuZXh0Q29udGV4dFxuICAgICAgICApO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZvaWQgMCA9PT0gb2xkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBvbGRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudFxuICAgICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkpLFxuICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuICAgICAgaWYgKFwicmVmXCIgaW4gYmFzZVByb3BzKSB7XG4gICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoKENvbXBvbmVudCA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHMpKSB7XG4gICAgICAgIG5ld1Byb3BzID09PSBiYXNlUHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcykpO1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gQ29tcG9uZW50KVxuICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBDb21wb25lbnRbX3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICAgICAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2VcbiAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSk7XG4gICAgICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgICAgICBvbkNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgICAgZXJyb3JCb3VuZGFyeTogMSA9PT0gYm91bmRhcnkudGFnID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgICAgIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBsYW5lLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gICAgICBsYW5lLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgICAgIGxhbmUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UsIGxvZ1VuY2F1Z2h0RXJyb3IsIHJvb3QsIGVycm9ySW5mbyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGluc3QgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAodXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWRcbiAgICAgICAgICAgICAgPyAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFt0aGlzXSkpXG4gICAgICAgICAgICAgIDogbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKHRoaXMpKTtcbiAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFVih0aGlzLCBlcnJvckluZm8pO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgKDAgPT09IChmaWJlci5sYW5lcyAmIDIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiBJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKFxuICAgICAgcm9vdCxcbiAgICAgIHJldHVybkZpYmVyLFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gMzI3Njg7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCk7XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgaWYgKG51bGwgIT09IHNvdXJjZUZpYmVyKSB7XG4gICAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgICAgICAgID8gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpXG4gICAgICAgICAgICAgICAgICA6IG51bGwgPT09IHNvdXJjZUZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgIDogcmV0dXJuRmliZXIuYWRkKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKChyZXR1cm5GaWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlRdWV1ZTogbmV3IFNldChbdmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoKHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXIucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlci5yZXRyeVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzb3VyY2VGaWJlci5hZGQodmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgK1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgK1xuICAgICAgICAgICAgICBcIikuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITApLFxuICAgICAgICAgIChyZXR1cm5GaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/ICgwID09PSAocmV0dXJuRmliZXIuZmxhZ3MgJiA2NTUzNikgJiYgKHJldHVybkZpYmVyLmZsYWdzIHw9IDI1NiksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgY2xpZW50IHJlbmRlcmluZyBmcm9tIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKHJvb3QgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgKHJvb3QuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocm9vdC5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAodmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpKSxcbiAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICByb290LnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShyb290LCByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZCkpLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICB2YXIgZXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgRXJyb3IoXG4gICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgc3luY2hyb25vdXNseSByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LlwiLFxuICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgKSxcbiAgICAgICAgc291cmNlRmliZXJcbiAgICAgICk7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdKVxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQpO1xuICAgICAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKSByZXR1cm4gITA7XG4gICAgICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IHJldHVybkZpYmVyO1xuICAgICAgZG8ge1xuICAgICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyb290ID0gcm9vdFJlbmRlckxhbmVzICYgLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290KSxcbiAgICAgICAgICAgICAgKHJvb3QgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgc291cmNlRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdCksXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnR5cGUpLFxuICAgICAgICAgICAgICAoZXJyb3IgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAwID09PSAoc291cmNlRmliZXIuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVybkZpYmVyLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAgICAgKG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVycm9yLmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoZXJyb3IpKSkpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShyb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHNvdXJjZUZpYmVyKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPVxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKVxuICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5yZW5kZXI7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKFwicmVmXCIgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5leHRQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gbmV4dFByb3BzW2tleV0pO1xuICAgICAgfSBlbHNlIHByb3BzV2l0aG91dFJlZiA9IG5leHRQcm9wcztcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcHJvcHNXaXRob3V0UmVmLFxuICAgICAgICByZWYsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAga2V5ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYga2V5ICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gQ29tcG9uZW50LmNvbXBhcmVcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoQ29tcG9uZW50ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCksXG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHR5cGUpLFxuICAgICAgICAgICAgdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgQ29tcG9uZW50LnR5cGUsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBpZiAoIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSkge1xuICAgICAgICB2YXIgcHJldlByb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgICAgICBDb21wb25lbnQgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICAgICAgQ29tcG9uZW50ID0gbnVsbCAhPT0gQ29tcG9uZW50ID8gQ29tcG9uZW50IDogc2hhbGxvd0VxdWFsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgQ29tcG9uZW50KHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWZcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIGN1cnJlbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyh0eXBlLCBuZXh0UHJvcHMpO1xuICAgICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZVxuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcyksXG4gICAgICAgICAgICBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzEwNzIpICYmIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgbmV4dFByb3BzXG4gICAgKSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgICBwcmV2U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSB7XG4gICAgICAgICAgX3Zpc2liaWxpdHk6IE9mZnNjcmVlblZpc2libGUsXG4gICAgICAgICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgICAgICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgICAgICAgIF90cmFuc2l0aW9uczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIGlmIChcImhpZGRlblwiID09PSBuZXh0UHJvcHMubW9kZSkge1xuICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSkge1xuICAgICAgICAgIHByZXZTdGF0ZSA9XG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgZm9yIChuZXh0Q2hpbGRyZW4gPSAwOyBudWxsICE9PSBuZXh0UHJvcHM7IClcbiAgICAgICAgICAgICAgKG5leHRDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgbmV4dENoaWxkcmVuIHwgbmV4dFByb3BzLmxhbmVzIHwgbmV4dFByb3BzLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBuZXh0UHJvcHMuc2libGluZyk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSBuZXh0Q2hpbGRyZW4gJiB+cHJldlN0YXRlO1xuICAgICAgICAgIH0gZWxzZSAobmV4dFByb3BzID0gMCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpO1xuICAgICAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHByZXZTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSlcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHsgYmFzZUxhbmVzOiAwLCBjYWNoZVBvb2w6IG51bGwgfSksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIHB1c2hUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5jYWNoZVBvb2wgOiBudWxsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKVxuICAgICAgICAgICAgICA6IHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmxhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgICAgIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICA/IChwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlLmNhY2hlUG9vbCksXG4gICAgICAgICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKSxcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpKVxuICAgICAgICAgIDogKG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dE9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgMjIgPT09IGN1cnJlbnQudGFnKSB8fFxuICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHtcbiAgICAgICAgICBfdmlzaWJpbGl0eTogT2Zmc2NyZWVuVmlzaWJsZSxcbiAgICAgICAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgICAgICAgX3JldHJ5Q2FjaGU6IG51bGwsXG4gICAgICAgICAgX3RyYW5zaXRpb25zOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dEJhc2VMYW5lcyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgcmVtYWluaW5nQ2hpbGRMYW5lc1xuICAgICkge1xuICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgICAgcG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgfTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAhMCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gcmVtYWluaW5nQ2hpbGRMYW5lcztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEFjdGl2aXR5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgICAgdmFyIGhpZGRlblByb3AgPSBuZXh0UHJvcHMuaGlkZGVuO1xuICAgICAgdm9pZCAwICE9PSBoaWRkZW5Qcm9wICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJzxBY3Rpdml0eT4gZG9lc25cXCd0IGFjY2VwdCBhIGhpZGRlbiBwcm9wLiBVc2UgbW9kZT1cImhpZGRlblwiIGluc3RlYWQuXFxuLSA8QWN0aXZpdHkgJXM+XFxuKyA8QWN0aXZpdHkgJXM+JyxcbiAgICAgICAgICAhMCA9PT0gaGlkZGVuUHJvcFxuICAgICAgICAgICAgPyBcImhpZGRlblwiXG4gICAgICAgICAgICA6ICExID09PSBoaWRkZW5Qcm9wXG4gICAgICAgICAgICAgID8gXCJoaWRkZW49e2ZhbHNlfVwiXG4gICAgICAgICAgICAgIDogXCJoaWRkZW49ey4uLn1cIixcbiAgICAgICAgICBoaWRkZW5Qcm9wID8gJ21vZGU9XCJoaWRkZW5cIicgOiAnbW9kZT1cInZpc2libGVcIidcbiAgICAgICAgKTtcbiAgICAgIG5leHRQcm9wcyA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgeyBtb2RlOiBuZXh0UHJvcHMubW9kZSwgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbiB9LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlXG4gICAgICApO1xuICAgICAgbmV4dFByb3BzLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzO1xuICAgICAgbmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuIG5leHRQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlBY3Rpdml0eUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgIGN1cnJlbnQgPSBtb3VudEFjdGl2aXR5Q2hpbGRyZW4oXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICk7XG4gICAgICBjdXJyZW50LmZsYWdzIHw9IDI7XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aXZpdHlDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICBkaWRTdXNwZW5kID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xMjk7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBpZiAoXCJoaWRkZW5cIiA9PT0gbmV4dFByb3BzLm1vZGUpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoY3VycmVudCA9IG1vdW50QWN0aXZpdHlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgICAgIGJhaWxvdXRPZmZzY3JlZW5Db21wb25lbnQobnVsbCwgY3VycmVudClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcHVzaERlaHlkcmF0ZWRBY3Rpdml0eVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgKGN1cnJlbnQgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKVxuICAgICAgICAgICAgPyAoKHJlbmRlckxhbmVzID0gY2FuSHlkcmF0ZUFjdGl2aXR5SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAgICgobmV4dFByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZDogcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB0cmVlQ29udGV4dDogZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSxcbiAgICAgICAgICAgICAgICAgIHJldHJ5TGFuZTogNTM2ODcwOTEyLFxuICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uRXJyb3JzOiBudWxsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpKSlcbiAgICAgICAgICAgIDogKHJlbmRlckxhbmVzID0gbnVsbCk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAod2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDUzNjg3MDkxMjtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW91bnRBY3Rpdml0eUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIGFjdGl2aXR5SW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcbiAgICAgICAgcHVzaERlaHlkcmF0ZWRBY3Rpdml0eVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmIChkaWRTdXNwZW5kKVxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlBY3Rpdml0eUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJDbGllbnQgcmVuZGVyaW5nIGFuIEFjdGl2aXR5IHN1c3BlbmRlZCBpdCBhZ2Fpbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKHdhcm5JZkh5ZHJhdGluZygpLFxuICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgJiZcbiAgICAgICAgICAgIG1hcmtSZW5kZXJEZXJpdmVkQ2F1c2Uod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChkaWRTdXNwZW5kID0gMCAhPT0gKHJlbmRlckxhbmVzICYgY3VycmVudC5jaGlsZExhbmVzKSksXG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fCBkaWRTdXNwZW5kKVxuICAgICAgICApIHtcbiAgICAgICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAoKGFjdGl2aXR5SW5zdGFuY2UgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIDAgIT09IGFjdGl2aXR5SW5zdGFuY2UgJiYgYWN0aXZpdHlJbnN0YW5jZSAhPT0gcHJldlN0YXRlLnJldHJ5TGFuZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgocHJldlN0YXRlLnJldHJ5TGFuZSA9IGFjdGl2aXR5SW5zdGFuY2UpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCwgYWN0aXZpdHlJbnN0YW5jZSksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihuZXh0UHJvcHMsIGN1cnJlbnQsIGFjdGl2aXR5SW5zdGFuY2UpLFxuICAgICAgICAgICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5QWN0aXZpdHlDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAoY3VycmVudCA9IHByZXZTdGF0ZS50cmVlQ29udGV4dCksXG4gICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQWN0aXZpdHlJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIGFjdGl2aXR5SW5zdGFuY2VcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSxcbiAgICAgICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITEpLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG1vdW50QWN0aXZpdHlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5Nik7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIHByZXZTdGF0ZSA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBuZXh0UHJvcHMgPSB7IG1vZGU6IG5leHRQcm9wcy5tb2RlLCBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuIH07XG4gICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpICYmXG4gICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIGN1cnJlbnQubGFuZXMpICYmXG4gICAgICAgIG1hcmtSZW5kZXJEZXJpdmVkQ2F1c2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY3VycmVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50O1xuICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKG51bGwgPT09IHJlZilcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQucmVmICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQ4MTYpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZWYgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgdW5kZWZpbmVkL251bGwuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQ4MTY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIDggJiZcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAodmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKSkpKTtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgbmV4dFByb3BzICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBzZWNvbmRBcmcsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICBzZWNvbmRBcmdcbiAgICAgICk7XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBDb21wb25lbnQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBDb21wb25lbnQgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHNob3VsZEVycm9ySW1wbCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgICB2YXIgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLFxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgd29ya0luUHJvZ3Jlc3MudHlwZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbnRleHRcbiAgICAgICAgICAgICkuc3RhdGU7XG4gICAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKF9pbnN0YW5jZSwgc3RhdGUsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICEwOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NTUzNjtcbiAgICAgICAgICBfaW5zdGFuY2UgPSBFcnJvcihcIlNpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29sc1wiKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlbmRlckxhbmVzICYgLXJlbmRlckxhbmVzO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IGxhbmU7XG4gICAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHN0YXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxhbmUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgbGFuZSxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBsYW5lKTtcbiAgICAgIH1cbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpIHtcbiAgICAgICAgc3RhdGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIF9pbnN0YW5jZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIENvbXBvbmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZSAmJlxuICAgICAgICAgICh2b2lkIDAgPT09IF9pbnN0YW5jZSB8fCBfaW5zdGFuY2UuJCR0eXBlb2YgIT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICAobGFuZSA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IF9pbnN0YW5jZVxuICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuIFRoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvIHRyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS5cIlxuICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhIFwiICsgdHlwZW9mIF9pbnN0YW5jZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgOiBfaW5zdGFuY2UuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEVcbiAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICA6IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbnN0YW5jZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJ9LlwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuIGNvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICkpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX2luc3RhbmNlICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHN0YXRlID0gcmVhZENvbnRleHQoX2luc3RhbmNlKSk7XG4gICAgICAgIF9pbnN0YW5jZSA9IG5ldyBDb21wb25lbnQobmV4dFByb3BzLCBzdGF0ZSk7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJiB2b2lkIDAgIT09IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgPyBfaW5zdGFuY2Uuc3RhdGVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgX2luc3RhbmNlLl9yZWFjdEludGVybmFscyA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gc3RhdGUgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhzdGF0ZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKHN0YXRlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAlcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLlwiLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gX2luc3RhbmNlLnN0YXRlID8gXCJudWxsXCIgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IChsYW5lID0gc3RhdGUgPSBudWxsKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoc3RhdGUgPSBcImNvbXBvbmVudFdpbGxNb3VudFwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAoc3RhdGUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKGxhbmUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICAgKGxhbmUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgITAgIT09IF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcImNvbXBvbmVudFdpbGxVcGRhdGVcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUgfHwgbnVsbCAhPT0gbGFuZSB8fCBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lKSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgdmFyIG5ld0FwaU5hbWUgPVxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgPyBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpXCJcbiAgICAgICAgICAgICAgICA6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKVwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2luc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2luc3RhbmNlKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbiVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG5UaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG5odHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlc1wiLFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHN0YXRlID8gXCJcXG4gIFwiICsgc3RhdGUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGxhbmUgPyBcIlxcbiAgXCIgKyBsYW5lIDogXCJcIixcbiAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6IFwiXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICBfaW5zdGFuY2UucmVuZGVyIHx8XG4gICAgICAgICAgKENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgIV9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHxcbiAgICAgICAgICBfaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICAgICAgX2luc3RhbmNlLnN0YXRlIHx8XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAhX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImdldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImNvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/IFRoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiZcbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX2luc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkEgcHVyZSBjb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsIHVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIHJ1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBsYW5lID0gX2luc3RhbmNlLnByb3BzICE9PSBuZXh0UHJvcHM7XG4gICAgICAgIHZvaWQgMCAhPT0gX2luc3RhbmNlLnByb3BzICYmXG4gICAgICAgICAgbGFuZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIldoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIHVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLlwiLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKENvbXBvbmVudCkgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuIFRoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudClcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIChsYW5lID0gX2luc3RhbmNlLnN0YXRlKSAmJlxuICAgICAgICAgIChcIm9iamVjdFwiICE9PSB0eXBlb2YgbGFuZSB8fCBpc0FycmF5SW1wbChsYW5lKSkgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsXCIsIHN0YXRlKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldENoaWxkQ29udGV4dCAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5yZWZzID0ge307XG4gICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHN0YXRlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBfaW5zdGFuY2UuY29udGV4dCA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHN0YXRlICYmIG51bGwgIT09IHN0YXRlXG4gICAgICAgICAgICA/IHJlYWRDb250ZXh0KHN0YXRlKVxuICAgICAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9PT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgKChzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhzdGF0ZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSBiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LlwiLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCAmJlxuICAgICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzdGF0ZSAmJlxuICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgKChzdGF0ZSA9IF9pbnN0YW5jZS5zdGF0ZSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgIHN0YXRlICE9PSBfaW5zdGFuY2Uuc3RhdGUgJiZcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSxcbiAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCk7XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTM0MjE3NzI4KTtcbiAgICAgICAgX2luc3RhbmNlID0gITA7XG4gICAgICB9IGVsc2UgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgbGFuZSA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gbGFuZTtcbiAgICAgICAgdmFyIG9sZENvbnRleHQgPSBfaW5zdGFuY2UuY29udGV4dDtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgc3RhdGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBmb3VuZFdpbGxVcGRhdGVOYW1lICYmXG4gICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSAmJlxuICAgICAgICAgIChzdGF0ZSA9IHJlYWRDb250ZXh0KGZvdW5kV2lsbFVwZGF0ZU5hbWUpKTtcbiAgICAgICAgbmV3QXBpTmFtZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPVxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0FwaU5hbWUgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyAhPT0gdW5yZXNvbHZlZE9sZFByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAgICAgKCh1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gc3RhdGUpICYmXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgb2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkQ29udGV4dCB8fCBoYXNGb3JjZVVwZGF0ZVxuICAgICAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0FwaU5hbWUgJiZcbiAgICAgICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAob2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGxhbmUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRleHQsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTM0MjE3NzI4KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEzNDIxNzcyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gb2xkQ29udGV4dCkpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gb2xkQ29udGV4dCksXG4gICAgICAgICAgICAoX2luc3RhbmNlLmNvbnRleHQgPSBzdGF0ZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gbGFuZSkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEzNDIxNzcyOCksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gITEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgc3RhdGUpO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBmb3VuZFdpbGxVcGRhdGVOYW1lO1xuICAgICAgICBuZXdBcGlOYW1lID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICBvbGRTdGF0ZSA9IF9pbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICBvbGRDb250ZXh0ID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBsYW5lID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2xkQ29udGV4dCAmJlxuICAgICAgICAgIG51bGwgIT09IG9sZENvbnRleHQgJiZcbiAgICAgICAgICAobGFuZSA9IHJlYWRDb250ZXh0KG9sZENvbnRleHQpKTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgKG9sZENvbnRleHQgPVxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSkgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICAgICAoKHN0YXRlICE9PSBuZXdBcGlOYW1lIHx8IG9sZFN0YXRlICE9PSBsYW5lKSAmJlxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICAgIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSAhPT0gbmV3QXBpTmFtZSB8fFxuICAgICAgICBvbGRTdGF0ZSAhPT0gbmV3U3RhdGUgfHxcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50LmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50LmRlcGVuZGVuY2llcykpXG4gICAgICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdW5yZXNvbHZlZE9sZFByb3BzICYmXG4gICAgICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAobmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50LmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50LmRlcGVuZGVuY2llcykpKVxuICAgICAgICAgICAgICA/IChvbGRDb250ZXh0IHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV3U3RhdGUsIGxhbmUpLFxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCkpXG4gICAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlKSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLmNvbnRleHQgPSBsYW5lKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBmb3VuZFdpbGxVcGRhdGVOYW1lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9ICExKSk7XG4gICAgICB9XG4gICAgICBsYW5lID0gX2luc3RhbmNlO1xuICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzdGF0ZSA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICBpZiAobGFuZSB8fCBzdGF0ZSkge1xuICAgICAgICBsYW5lID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBzZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoc3RhdGUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcilcbiAgICAgICAgICAoQ29tcG9uZW50ID0gbnVsbCksIChwcm9maWxlclN0YXJ0VGltZSA9IC0xKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKChDb21wb25lbnQgPSBjYWxsUmVuZGVySW5ERVYobGFuZSkpLCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOClcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsUmVuZGVySW5ERVYobGFuZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBzdGF0ZVxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSlcbiAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGxhbmUuc3RhdGU7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjdXJyZW50ID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIF9pbnN0YW5jZSAmJlxuICAgICAgICByZW5kZXJMYW5lcy5wcm9wcyAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcImEgY29tcG9uZW50XCJcbiAgICAgICAgICApLFxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICEwKSk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjU2O1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ICYmXG4gICAgICAgIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLlwiLFxuICAgICAgICAgIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFt3b3JrSW5Qcm9ncmVzc10gPVxuICAgICAgICAgICAgITApKSk7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlICYmXG4gICAgICAgIG51bGwgIT09IENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICAoKENvbXBvbmVudCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICBDb21wb25lbnRcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbQ29tcG9uZW50XSA9ICEwKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgICAgIHJldHVybiB7IGJhc2VMYW5lczogcmVuZGVyTGFuZXMsIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5jaGlsZExhbmVzICYgfnJlbmRlckxhbmVzIDogMDtcbiAgICAgIHByaW1hcnlUcmVlRGlkRGVmZXIgJiYgKGN1cnJlbnQgfD0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHNob3VsZFN1c3BlbmRJbXBsKHdvcmtJblByb2dyZXNzKSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KTtcbiAgICAgIHZhciBzaG93RmFsbGJhY2sgPSAhMSxcbiAgICAgICAgZGlkU3VzcGVuZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCksXG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSBkaWRTdXNwZW5kKSB8fFxuICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyAhMVxuICAgICAgICAgICAgOiAwICE9PSAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgJiYgKChzaG93RmFsbGJhY2sgPSAhMCksICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTI5KSk7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAzMik7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMzM7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgID8gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIChjdXJyZW50ID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSlcbiAgICAgICAgICAgID8gKChyZW5kZXJMYW5lcyA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCA9IHtcbiAgICAgICAgICAgICAgICAgIGRlaHlkcmF0ZWQ6IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgdHJlZUNvbnRleHQ6IGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgICByZXRyeUxhbmU6IDUzNjg3MDkxMixcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkVycm9yczogbnVsbFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IEpTQ29tcGlsZXJfdGVtcCksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCkpKVxuICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgPSBudWxsKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmVuZGVyTGFuZXMpXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICh3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCksXG4gICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAzMilcbiAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNTM2ODcwOTEyKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgKG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgIHsgbW9kZTogXCJoaWRkZW5cIiwgY2hpbGRyZW46IG5leHRQcmltYXJ5Q2hpbGRyZW4gfSxcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0UHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5leHRQcmltYXJ5Q2hpbGRyZW4uc2libGluZyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0UHJpbWFyeUNoaWxkcmVuKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAobmV4dFByb3BzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgICBiYWlsb3V0T2Zmc2NyZWVuQ29tcG9uZW50KG51bGwsIG5leHRQcm9wcylcbiAgICAgICAgICApO1xuICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBuZXh0UHJpbWFyeUNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBwcmV2U3RhdGUgJiZcbiAgICAgICAgKChuZXh0UHJpbWFyeUNoaWxkcmVuID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQpLFxuICAgICAgICBudWxsICE9PSBuZXh0UHJpbWFyeUNoaWxkcmVuKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChkaWRTdXNwZW5kKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2XG4gICAgICAgICAgICA/IChwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAocmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgICAgICAgOiAocmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgICAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuIH0sXG4gICAgICAgICAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobmV4dFByaW1hcnlDaGlsZHJlbiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgbmV4dFByaW1hcnlDaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgIHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJpbWFyeUNoaWxkcmVuLmZsYWdzIHw9IDIpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBuZXh0UHJpbWFyeUNoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gYmFpbG91dE9mZnNjcmVlbkNvbXBvbmVudChudWxsLCBuZXh0UHJvcHMpKSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIHdhcm5JZkh5ZHJhdGluZygpLFxuICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgJiZcbiAgICAgICAgICAgIG1hcmtSZW5kZXJEZXJpdmVkQ2F1c2Uod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKG5leHRQcmltYXJ5Q2hpbGRyZW4pKVxuICAgICAgICApXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9XG4gICAgICAgICAgICBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMobmV4dFByaW1hcnlDaGlsZHJlbikpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IHNob3dGYWxsYmFjay5kaWdlc3QpLFxuICAgICAgICAgICAgKG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBzaG93RmFsbGJhY2subWVzc2FnZSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gc2hvd0ZhbGxiYWNrLnN0YWNrKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBzaG93RmFsbGJhY2suY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgKG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJpbWFyeUNoaWxkcmVuXG4gICAgICAgICAgICAgID8gRXJyb3IobmV4dFByaW1hcnlDaGlsZHJlbilcbiAgICAgICAgICAgICAgOiBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSBkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0UHJpbWFyeUNoaWxkcmVuLnN0YWNrID0gbmV4dFByb3BzIHx8IFwiXCIpLFxuICAgICAgICAgICAgKG5leHRQcmltYXJ5Q2hpbGRyZW4uZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSB2b2lkIDAgPT09IHNob3dGYWxsYmFjayA/IG51bGwgOiBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IG5leHRQcmltYXJ5Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgICAgc3RhY2s6IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgSlNDb21waWxlcl90ZW1wICYmXG4gICAgICAgICAgICAgIENhcHR1cmVkU3RhY2tzLnNldChuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHJlbmRlckxhbmVzICYgY3VycmVudC5jaGlsZExhbmVzKSksXG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fCBKU0NvbXBpbGVyX3RlbXApXG4gICAgICAgICkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICgobmV4dFByb3BzID0gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAwICE9PSBuZXh0UHJvcHMgJiYgbmV4dFByb3BzICE9PSBwcmV2U3RhdGUucmV0cnlMYW5lKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgKChwcmV2U3RhdGUucmV0cnlMYW5lID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihKU0NvbXBpbGVyX3RlbXAsIGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0UHJpbWFyeUNoaWxkcmVuKSB8fFxuICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcobmV4dFByaW1hcnlDaGlsZHJlbilcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxOTIpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgoY3VycmVudCA9IHByZXZTdGF0ZS50cmVlQ29udGV4dCksXG4gICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByaW1hcnlDaGlsZHJlblxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITEpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQwOTYpKTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgICAgaWYgKHNob3dGYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgKHByZXZTdGF0ZSA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgIChkaWRTdXNwZW5kID0gcHJldlN0YXRlLnNpYmxpbmcpLFxuICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhwcmV2U3RhdGUsIHtcbiAgICAgICAgICAgIG1vZGU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIChuZXh0UHJvcHMuc3VidHJlZUZsYWdzID0gcHJldlN0YXRlLnN1YnRyZWVGbGFncyAmIDY1MDExNzEyKSxcbiAgICAgICAgICBudWxsICE9PSBkaWRTdXNwZW5kXG4gICAgICAgICAgICA/IChuZXh0UHJpbWFyeUNoaWxkcmVuID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgICAgICAgICAgICAgZGlkU3VzcGVuZCxcbiAgICAgICAgICAgICAgICBuZXh0UHJpbWFyeUNoaWxkcmVuXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6ICgobmV4dFByaW1hcnlDaGlsZHJlbiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIG5leHRQcmltYXJ5Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChuZXh0UHJpbWFyeUNoaWxkcmVuLmZsYWdzIHw9IDIpKSxcbiAgICAgICAgICAobmV4dFByaW1hcnlDaGlsZHJlbi5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKG5leHRQcm9wcy5zaWJsaW5nID0gbmV4dFByaW1hcnlDaGlsZHJlbiksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICBiYWlsb3V0T2Zmc2NyZWVuQ29tcG9uZW50KG51bGwsIG5leHRQcm9wcyksXG4gICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAobmV4dFByaW1hcnlDaGlsZHJlbiA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgbnVsbCA9PT0gbmV4dFByaW1hcnlDaGlsZHJlblxuICAgICAgICAgICAgPyAobmV4dFByaW1hcnlDaGlsZHJlbiA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA6ICgoc2hvd0ZhbGxiYWNrID0gbmV4dFByaW1hcnlDaGlsZHJlbi5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9PSBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgICAgICA/ICgocHJldlN0YXRlID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID1cbiAgICAgICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLnBhcmVudCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgPyB7IHBhcmVudDogcHJldlN0YXRlLCBwb29sOiBwcmV2U3RhdGUgfVxuICAgICAgICAgICAgICAgICAgICAgIDogc2hvd0ZhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICA6IChzaG93RmFsbGJhY2sgPSBnZXRTdXNwZW5kZWRDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKG5leHRQcmltYXJ5Q2hpbGRyZW4gPSB7XG4gICAgICAgICAgICAgICAgYmFzZUxhbmVzOiBuZXh0UHJpbWFyeUNoaWxkcmVuLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIGNhY2hlUG9vbDogc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAobmV4dFByb3BzLm1lbW9pemVkU3RhdGUgPSBuZXh0UHJpbWFyeUNoaWxkcmVuKSxcbiAgICAgICAgICAobmV4dFByb3BzLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgYmFpbG91dE9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LmNoaWxkLCBuZXh0UHJvcHMpXG4gICAgICAgICk7XG4gICAgICBudWxsICE9PSBwcmV2U3RhdGUgJiZcbiAgICAgICAgKHJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiBjdXJyZW50LmxhbmVzKSAmJlxuICAgICAgICBtYXJrUmVuZGVyRGVyaXZlZENhdXNlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBjdXJyZW50ID0gcmVuZGVyTGFuZXMuc2libGluZztcbiAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIHtcbiAgICAgICAgbW9kZTogXCJ2aXNpYmxlXCIsXG4gICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgcmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMpLFxuICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRdKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAucHVzaChjdXJyZW50KSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbikge1xuICAgICAgcHJpbWFyeUNoaWxkcmVuID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuIH0sXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGVcbiAgICAgICk7XG4gICAgICBwcmltYXJ5Q2hpbGRyZW4ucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlKSB7XG4gICAgICBvZmZzY3JlZW5Qcm9wcyA9IGNyZWF0ZUZpYmVyKDIyLCBvZmZzY3JlZW5Qcm9wcywgbnVsbCwgbW9kZSk7XG4gICAgICBvZmZzY3JlZW5Qcm9wcy5sYW5lcyA9IDA7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuUHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBjdXJyZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICAgIGN1cnJlbnQuZmxhZ3MgfD0gMjtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGlzQmFja3dhcmRzLFxuICAgICAgdGFpbCxcbiAgICAgIGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbE1vZGUsXG4gICAgICB0cmVlRm9ya0NvdW50XG4gICAgKSB7XG4gICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGVcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzQmFja3dhcmRzOiBpc0JhY2t3YXJkcyxcbiAgICAgICAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgICAgICAgIGxhc3Q6IGxhc3RDb250ZW50Um93LFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZSxcbiAgICAgICAgICAgIHRyZWVGb3JrQ291bnQ6IHRyZWVGb3JrQ291bnRcbiAgICAgICAgICB9KVxuICAgICAgICA6ICgocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93KSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbCA9IHRhaWwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudHJlZUZvcmtDb3VudCA9IHRyZWVGb3JrQ291bnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXIsXG4gICAgICAgIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWwsXG4gICAgICAgIG5ld0NoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICAobmV4dFByb3BzID0gMCAhPT0gKHN1c3BlbnNlQ29udGV4dCAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpXG4gICAgICAgID8gKChzdXNwZW5zZUNvbnRleHQgPVxuICAgICAgICAgICAgKHN1c3BlbnNlQ29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpKVxuICAgICAgICA6IChzdXNwZW5zZUNvbnRleHQgJj0gU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spO1xuICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN1c3BlbnNlQ29udGV4dCA9IG51bGwgPT0gcmV2ZWFsT3JkZXIgPyBcIm51bGxcIiA6IHJldmVhbE9yZGVyO1xuICAgICAgaWYgKFxuICAgICAgICBcImZvcndhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcInRvZ2V0aGVyXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiaW5kZXBlbmRlbnRcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3N1c3BlbnNlQ29udGV4dF1cbiAgICAgIClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbc3VzcGVuc2VDb250ZXh0XSA9ICEwKSwgbnVsbCA9PSByZXZlYWxPcmRlcilcbiAgICAgICAgKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnVGhlIGRlZmF1bHQgZm9yIHRoZSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiLi4uXCI+IHByb3AgaXMgY2hhbmdpbmcuIFRvIGJlIGZ1dHVyZSBjb21wYXRpYmxlIHlvdSBtdXN0IGV4cGxpY3RseSBzcGVjaWZ5IGVpdGhlciBcImluZGVwZW5kZW50XCIgKHRoZSBjdXJyZW50IGRlZmF1bHQpLCBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImxlZ2FjeV91bnN0YWJsZS1iYWNrd2FyZHNcIi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAoXCJiYWNrd2FyZHNcIiA9PT0gcmV2ZWFsT3JkZXIpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdUaGUgcmVuZGVyaW5nIG9yZGVyIG9mIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCJiYWNrd2FyZHNcIj4gaXMgY2hhbmdpbmcuIFRvIGJlIGZ1dHVyZSBjb21wYXRpYmxlIHlvdSBtdXN0IHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJsZWdhY3lfdW5zdGFibGUtYmFja3dhcmRzXCIgaW5zdGVhZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJldmVhbE9yZGVyKVxuICAgICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcInRvZ2V0aGVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbmRlcGVuZGVudFwiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFVzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZFwiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFJlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJpbmRlcGVuZGVudFwiLCBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwiaW5kZXBlbmRlbnRcIiwgXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLFxuICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICApO1xuICAgICAgc3VzcGVuc2VDb250ZXh0ID0gbnVsbCA9PSB0YWlsTW9kZSA/IFwibnVsbFwiIDogdGFpbE1vZGU7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3N1c3BlbnNlQ29udGV4dF0pXG4gICAgICAgIGlmIChudWxsID09IHRhaWxNb2RlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fFxuICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiA9PT0gcmV2ZWFsT3JkZXIgfHxcbiAgICAgICAgICAgIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlclxuICAgICAgICAgIClcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1tzdXNwZW5zZUNvbnRleHRdID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgZGVmYXVsdCBmb3IgdGhlIDxTdXNwZW5zZUxpc3QgdGFpbD1cIi4uLlwiPiBwcm9wIGlzIGNoYW5naW5nLiBUbyBiZSBmdXR1cmUgY29tcGF0aWJsZSB5b3UgbXVzdCBleHBsaWN0bHkgc3BlY2lmeSBlaXRoZXIgXCJ2aXNpYmxlXCIgKHRoZSBjdXJyZW50IGRlZmF1bHQpLCBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBcInZpc2libGVcIiAhPT0gdGFpbE1vZGUgJiZcbiAgICAgICAgICBcImNvbGxhcHNlZFwiICE9PSB0YWlsTW9kZSAmJlxuICAgICAgICAgIFwiaGlkZGVuXCIgIT09IHRhaWxNb2RlXG4gICAgICAgICAgICA/ICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbc3VzcGVuc2VDb250ZXh0XSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJ2aXNpYmxlXCIsIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLFxuICAgICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICAgXCJ1bnN0YWJsZV9sZWdhY3ktYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICAgICAgICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbc3VzcGVuc2VDb250ZXh0XSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiBEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JyxcbiAgICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgICApKTtcbiAgICAgIGE6IGlmIChcbiAgICAgICAgKFwiZm9yd2FyZHNcIiA9PT0gcmV2ZWFsT3JkZXIgfHxcbiAgICAgICAgICBcImJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fFxuICAgICAgICAgIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlcikgJiZcbiAgICAgICAgdm9pZCAwICE9PSBuZXdDaGlsZHJlbiAmJlxuICAgICAgICBudWxsICE9PSBuZXdDaGlsZHJlbiAmJlxuICAgICAgICAhMSAhPT0gbmV3Q2hpbGRyZW5cbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkcmVuKSlcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gMDtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW3N1c3BlbnNlQ29udGV4dF0sXG4gICAgICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICgoc3VzcGVuc2VDb250ZXh0ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbikpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN1c3BlbnNlQ29udGV4dClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKChzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZUNvbnRleHQuY2FsbChuZXdDaGlsZHJlbikpKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBzdXNwZW5zZUNvbnRleHQubmV4dCgpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICFzdGVwLmRvbmU7XG4gICAgICAgICAgICAgIHN0ZXAgPSBzdXNwZW5zZUNvbnRleHQubmV4dCgpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiBUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgaXNIeWRyYXRpbmdcbiAgICAgICAgPyAod2FybklmTm90SHlkcmF0aW5nKCksIChuZXdDaGlsZHJlbiA9IHRyZWVGb3JrQ291bnQpKVxuICAgICAgICA6IChuZXdDaGlsZHJlbiA9IDApO1xuICAgICAgaWYgKCFuZXh0UHJvcHMgJiYgbnVsbCAhPT0gY3VycmVudCAmJiAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCkpXG4gICAgICAgIGE6IGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGVsc2UgaWYgKDE5ID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQucmV0dXJuID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gY3VycmVudC5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50LnJldHVybiB8fCBjdXJyZW50LnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQuc2libGluZy5yZXR1cm4gPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yIChyZXZlYWxPcmRlciA9IG51bGw7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgICAgICAoY3VycmVudCA9IHJlbmRlckxhbmVzLmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAgICAgICAocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgID8gKChyZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcy5zaWJsaW5nKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsKSk7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMSxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB0YWlsTW9kZSxcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhY2t3YXJkc1wiOlxuICAgICAgICBjYXNlIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gbnVsbDtcbiAgICAgICAgICByZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIGZvciAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsOyBudWxsICE9PSByZXZlYWxPcmRlcjsgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IHJldmVhbE9yZGVyLnNpYmxpbmc7XG4gICAgICAgICAgICByZXZlYWxPcmRlci5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgICAgcmV2ZWFsT3JkZXIgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGFpbE1vZGUsXG4gICAgICAgICAgICBuZXdDaGlsZHJlblxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyk7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIGZvciAocmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7IG51bGwgIT09IGN1cnJlbnQuc2libGluZzsgKVxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcgPVxuICAgICAgICAgICAgICBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykpIHJldHVybiAhMDtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ICYmIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ2FjaGVDb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgcHVzaERlaHlkcmF0ZWRBY3Rpdml0eVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGRMYW5lcykpXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcbiAgICAgICAgICBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkpO1xuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVOb2RlKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlkU3VzcGVuZEJlZm9yZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZEJlZm9yZSAmJlxuICAgICAgICAgICAgKChkaWRTdXNwZW5kQmVmb3JlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUudGFpbCA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUubGFzdEVmZmVjdCA9IG51bGwpKTtcbiAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc3RhdGVOb2RlKSBicmVhaztcbiAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwKSxcbiAgICAgICAgICAgIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ2FjaGVDb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgJiYgbnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICByZW5kZXJMYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmtleSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHwgbnVsbCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIHJlbmRlckxhbmVzLl9kZWJ1Z1N0YWNrID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU3RhY2s7XG4gICAgICAgIHJlbmRlckxhbmVzLl9kZWJ1Z1Rhc2sgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdUYXNrO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgdGhyb3cgRXJyb3IoXCJDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci5cIik7XG4gICAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgcmVuZGVyTGFuZXMuaW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgcmVuZGVyTGFuZXMucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgICByZW5kZXJMYW5lcy5fZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZClcbiAgICAgICAgICByZXR1cm5GaWJlci5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNpYmxpbmcpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuXCIpO1xuICAgICAgICAgIGZvciAoOyBwcmV2U2libGluZy5zaWJsaW5nICE9PSB3b3JrSW5Qcm9ncmVzczsgKVxuICAgICAgICAgICAgaWYgKCgocHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nKSwgbnVsbCA9PT0gcHJldlNpYmxpbmcpKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuXCIpO1xuICAgICAgICAgIHByZXZTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICA/ICgocmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdKSwgKHJldHVybkZpYmVyLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLnB1c2goY3VycmVudCk7XG4gICAgICAgIHJlbmRlckxhbmVzLmZsYWdzIHw9IDI7XG4gICAgICAgIHJldHVybiByZW5kZXJMYW5lcztcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KVxuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgfHxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgICBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSA/ICEwIDogITE7XG4gICAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITE7XG4gICAgICAgIGlmICgocmV0dXJuRmliZXIgPSBpc0h5ZHJhdGluZykpXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMDQ4NTc2KSk7XG4gICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLmluZGV4KSxcbiAgICAgICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0cmVlRm9ya0NvdW50LCByZXR1cm5GaWJlcikpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBhOiBpZiAoXG4gICAgICAgICAgICAoKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gcmVzb2x2ZUxhenkod29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHNob3VsZENvbnN0cnVjdChjdXJyZW50KVxuICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy50YWcgPSAwKSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudCkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gY3VycmVudC4kJHR5cGVvZiksXG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IDExO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTaWJsaW5nID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBcIlwiO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudCAmJlxuICAgICAgICAgICAgICBjdXJyZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICAgICAgICBcIiBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlP1wiKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3VycmVudCkgfHwgY3VycmVudDtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgK1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgK1xuICAgICAgICAgICAgICAgIFwiLiBMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcHJldlNpYmxpbmcuZWxlbWVudDtcbiAgICAgICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgIT09IHByZXZTaWJsaW5nLmNhY2hlICYmXG4gICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSBuZXh0U3RhdGUuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0h5ZHJhdGlvbiAmJiBwcmV2U2libGluZy5pc0RlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0ge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgaXNEZWh5ZHJhdGVkOiAhMSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBuZXh0U3RhdGUuY2FjaGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFByb3BzICE9PSByZXR1cm5GaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKGlzSHlkcmF0aW5nID0gITApLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG1vdW50Q2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgY3VycmVudDtcblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50LmZsYWdzID0gKGN1cnJlbnQuZmxhZ3MgJiAtMykgfCA0MDk2KSxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmcpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgICAgaWYgKG5leHRQcm9wcyA9PT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyAoY3VycmVudCA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudClcbiAgICAgICAgICAgICAgICAgIDogaXNIeWRyYXRpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgJiZcbiAgICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCksXG4gICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TaW5nbGV0b24oXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlXG4gICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA0KSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKG5leHRQcm9wcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIXByZXZTaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAgICgobmV4dFN0YXRlID0gY2FuSHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKChuZXh0UHJvcHMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRTdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9ICEwKSlcbiAgICAgICAgICAgICAgICAgIDogKG5leHRQcm9wcyA9ICExKSxcbiAgICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIW5leHRQcm9wcykpLFxuICAgICAgICAgICAgICBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGwpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbmV4dFByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0UHJvcHMpXG4gICAgICAgICAgICAgID8gKHJldHVybkZpYmVyID0gbnVsbClcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChwcmV2U2libGluZywgbmV4dFN0YXRlKSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAzMiksXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgICAgIDogKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChyZXR1cm5GaWJlciA9ICExKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIuZWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gcHJldlNpYmxpbmcudmFsdWUpLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiIGluIHByZXZTaWJsaW5nIHx8XG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIHx8XG4gICAgICAgICAgICAgICgoaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/XCJcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHJldHVybkZpYmVyLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBwcmV2U2libGluZy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZWFkQ29udGV4dChwcmV2U2libGluZykpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gY2FsbENvbXBvbmVudEluREVWKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGl2aXR5Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHBlZWtDYWNoZUZyb21Qb29sKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3NSb290KSxcbiAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZSA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgOiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgICAgICAgIChjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpKSxcbiAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZy5wYXJlbnQgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jYWNoZSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdGhyb3cgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDbG9uZWQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHN1cHBvcnRzUGVyc2lzdGVuY2UgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQpIHJldHVybiAhMTtcbiAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDE2KSkgcmV0dXJuICEwO1xuICAgICAgZm9yIChjdXJyZW50ID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgIGlmICgwICE9PSAoY3VycmVudC5mbGFncyAmIDgyMTgpIHx8IDAgIT09IChjdXJyZW50LnN1YnRyZWVGbGFncyAmIDgyMTgpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4oXG4gICAgICBwYXJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbilcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGU7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgNSA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgNiA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZ1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgNCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnKVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGQucmV0dXJuID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuIHx8XG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zaWJsaW5nLnJldHVybiA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpXG4gICAgICAgIGZvciAodmFyIF9ub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IF9ub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gX25vZGUudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBfbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIF9ub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBfbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBfbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBfbm9kZS50YWcpXG4gICAgICAgICAgICBpZiAoMjIgPT09IF9ub2RlLnRhZyAmJiBudWxsICE9PSBfbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5jaGlsZCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiYgKGluc3RhbmNlLnJldHVybiA9IF9ub2RlKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIF9ub2RlLCAhMCwgITApO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gX25vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgX25vZGUuY2hpbGQucmV0dXJuID0gX25vZGU7XG4gICAgICAgICAgICAgIF9ub2RlID0gX25vZGUuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChfbm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBfbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBfbm9kZS5yZXR1cm4gfHwgX25vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgX25vZGUgPSBfbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ub2RlLnNpYmxpbmcucmV0dXJuID0gX25vZGUucmV0dXJuO1xuICAgICAgICAgIF9ub2RlID0gX25vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKFxuICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICB2YXIgaGFzT2Zmc2NyZWVuQ29tcG9uZW50Q2hpbGQgPSAhMTtcbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKVxuICAgICAgICBmb3IgKHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICAgIGlmICg1ID09PSBub2RlLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBub2RlLnRhZylcbiAgICAgICAgICAgIChpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgICAgIGVsc2UgaWYgKDQgIT09IG5vZGUudGFnKVxuICAgICAgICAgICAgaWYgKDIyID09PSBub2RlLnRhZyAmJiBudWxsICE9PSBub2RlLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIChoYXNPZmZzY3JlZW5Db21wb25lbnRDaGlsZCA9IG5vZGUuY2hpbGQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGhhc09mZnNjcmVlbkNvbXBvbmVudENoaWxkICYmXG4gICAgICAgICAgICAgICAgICAoaGFzT2Zmc2NyZWVuQ29tcG9uZW50Q2hpbGQucmV0dXJuID0gbm9kZSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihjb250YWluZXJDaGlsZFNldCwgbm9kZSwgITAsICEwKSxcbiAgICAgICAgICAgICAgICAoaGFzT2Zmc2NyZWVuQ29tcG9uZW50Q2hpbGQgPSAhMCk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICByZXR1cm4gaGFzT2Zmc2NyZWVuQ29tcG9uZW50Q2hpbGQ7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gaGFzT2Zmc2NyZWVuQ29tcG9uZW50Q2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlICYmIGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBjdXJyZW50LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpO1xuICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgITEsICExKTtcbiAgICAgICAgY3VycmVudC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzKSB7XG4gICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbilcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlLFxuICAgICAgICAgIF9vbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChjdXJyZW50ID0gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHx8XG4gICAgICAgICAgX29sZFByb3BzICE9PSBuZXdQcm9wc1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICBfb2xkUHJvcHMgPSBjbG9uZUluc3RhbmNlKFxuICAgICAgICAgICAgY3VycmVudEluc3RhbmNlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIF9vbGRQcm9wcyxcbiAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgIWN1cnJlbnQsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfb2xkUHJvcHMgPT09IGN1cnJlbnRJbnN0YW5jZVxuICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlKVxuICAgICAgICAgICAgOiAobWFya0Nsb25lZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICAgICAgICAgICAgICAgIF9vbGRQcm9wcyxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dFxuICAgICAgICAgICAgICApICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX29sZFByb3BzKSxcbiAgICAgICAgICAgICAgY3VycmVudCAmJiBhcHBlbmRBbGxDaGlsZHJlbihfb2xkUHJvcHMsIHdvcmtJblByb2dyZXNzLCAhMSwgITEpKTtcbiAgICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICB0eXBlLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMzIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKG51bGwgPT09IG9sZFByb3BzXG4gICAgICAgICAgPyBtYXlTdXNwZW5kQ29tbWl0KHR5cGUsIG5ld1Byb3BzKVxuICAgICAgICAgIDogbWF5U3VzcGVuZENvbW1pdE9uVXBkYXRlKHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcykpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTY3NzcyMTYpLFxuICAgICAgICAgIChyZW5kZXJMYW5lcyAmIDMzNTU0NDEyOCkgPT09IHJlbmRlckxhbmVzIHx8XG4gICAgICAgICAgICBtYXlTdXNwZW5kQ29tbWl0SW5TeW5jUmVuZGVyKHR5cGUsIG5ld1Byb3BzKSlcbiAgICAgICAgKVxuICAgICAgICAgIGlmIChwcmVsb2FkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCB0eXBlLCBuZXdQcm9wcykpXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyO1xuICAgICAgICAgIGVsc2UgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCByZXNvdXJjZSkge1xuICAgICAgaWYgKG1heVJlc291cmNlU3VzcGVuZENvbW1pdChyZXNvdXJjZSkpIHtcbiAgICAgICAgaWYgKCgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTY3NzcyMTYpLCAhcHJlbG9hZFJlc291cmNlKHJlc291cmNlKSkpXG4gICAgICAgICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICAgICAgbnVsbCAhPT0gcmV0cnlRdWV1ZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICgocmV0cnlRdWV1ZSA9XG4gICAgICAgICAgMjIgIT09IHdvcmtJblByb2dyZXNzLnRhZyA/IGNsYWltTmV4dFJldHJ5TGFuZSgpIDogNTM2ODcwOTEyKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IHJldHJ5UXVldWUpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIHw9IHJldHJ5UXVldWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgICAgZm9yICh2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAoaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrLnNpYmxpbmcpO1xuICAgICAgICAgICAgbnVsbCA9PT0gbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICA6IChsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvbGxhcHNlZFwiOlxuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsOyBudWxsICE9PSBsYXN0VGFpbE5vZGU7IClcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbGFzdFRhaWxOb2RlLmFsdGVybmF0ZSAmJiAoX2xhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZSksXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZS5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IF9sYXN0VGFpbE5vZGVcbiAgICAgICAgICAgICAgPyBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgfHwgbnVsbCA9PT0gcmVuZGVyU3RhdGUudGFpbFxuICAgICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGwpXG4gICAgICAgICAgICAgIDogKF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICAgICAgdmFyIGRpZEJhaWxvdXQgPVxuICAgICAgICAgIG51bGwgIT09IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQsXG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSAwLFxuICAgICAgICBzdWJ0cmVlRmxhZ3MgPSAwO1xuICAgICAgaWYgKGRpZEJhaWxvdXQpXG4gICAgICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb24sXG4gICAgICAgICAgICAgIF9jaGlsZDIgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX2NoaWxkMjtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9IF9jaGlsZDIubGFuZXMgfCBfY2hpbGQyLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuc3VidHJlZUZsYWdzICYgNjUwMTE3MTIpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuZmxhZ3MgJiA2NTAxMTcxMiksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiArPSBfY2hpbGQyLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgICAoX2NoaWxkMiA9IF9jaGlsZDIuc2libGluZyk7XG4gICAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9XG4gICAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uc3VidHJlZUZsYWdzICYgNjUwMTE3MTIpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzICYgNjUwMTE3MTIpLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24ucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgZWxzZSBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gY2hpbGQubGFuZXMgfCBjaGlsZC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuc3VidHJlZUZsYWdzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3MpLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSxcbiAgICAgICAgICAgIChfY2hpbGQyICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX2NoaWxkMjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD1cbiAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICAgICAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgICAgIHJldHVybiBkaWRCYWlsb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKG5ld1Byb3BzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpO1xuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAoKHJlbmRlckxhbmVzLmNvbnRleHQgPSByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgPSBudWxsKSk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCA9PT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IChlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICA6IG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KSkgfHxcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkpO1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgID8gKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgOiBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICA/IG5leHRSZXNvdXJjZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3KSlcbiAgICAgICAgICAgICAgICA6ICgobmV4dFJlc291cmNlID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBuZXh0UmVzb3VyY2UgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgIDogdXBkYXRlSG9zdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgOiAoKGN1cnJlbnQgPSByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlc291cmNlKSxcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZUh5ZHJhdGVkQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICApICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBfcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBtYXJrQ2xvbmVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsICExLCAhMSk7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9yb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICAgICAgICAgICAgICAgIF9yb290Q29udGFpbmVySW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgKSAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IG51bGwgOiBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IHJlbmRlckxhbmVzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIDogc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzICE9PSBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICA/ICgoY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrQ2xvbmVkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHR5cGUgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gICAgICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0UmVzb3VyY2UudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKHR5cGUgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSBuZXh0UmVzb3VyY2UubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCh0eXBlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkuc2VydmVyUHJvcHMgPSB0eXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoeWRyYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgKSB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MsICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBtYXJrQ2xvbmVkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSByZW5kZXJMYW5lcykge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0QWN0aXZpdHlJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50KVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIGFjdGl2aXR5IGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGh5ZHJhdGVBY3Rpdml0eUluc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSxcbiAgICAgICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gITE7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmh5ZHJhdGlvbkVycm9ycyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudCA9ICEwKTtcbiAgICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNsaWVudCByZW5kZXJpbmcgYW4gQWN0aXZpdHkgc3VzcGVuZGVkIGl0IGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHlwZSA9IG5ld1Byb3BzO1xuICAgICAgICAgICAgbmV4dFJlc291cmNlID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHR5cGUgJiYgbnVsbCAhPT0gdHlwZS5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgPyBuZXh0UmVzb3VyY2UuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dFJlc291cmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgICAoKHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IHR5cGUudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksXG4gICAgICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAoKHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIHR5cGUgPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodHlwZSA9IHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5oeWRyYXRpb25FcnJvcnMgPSB0eXBlKSxcbiAgICAgICAgICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gbnVsbCAhPT0gbmV3UHJvcHM7XG4gICAgICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKHR5cGUgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKHR5cGUgPSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAobmV4dFJlc291cmNlID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSAhPT0gdHlwZSAmJiAobmV3UHJvcHMuZmxhZ3MgfD0gMjA0OCkpO1xuICAgICAgICAgIHJlbmRlckxhbmVzICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkLmZsYWdzIHw9IDgxOTIpO1xuICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdQcm9wcykgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICAgIHR5cGUgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgICAgIG5leHRSZXNvdXJjZSA9IG5ld1Byb3BzLnJlbmRlcmluZztcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV4dFJlc291cmNlKVxuICAgICAgICAgICAgaWYgKHR5cGUpIGN1dE9mZlRhaWxJZk5lZWRlZChuZXdQcm9wcywgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBuZXh0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV3UHJvcHMsICExKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHRSZXNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgICAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICZcbiAgICAgICAgICAgICAgICAgICAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLnRyZWVGb3JrQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMudGFpbCAmJlxuICAgICAgICAgICAgICAgIG5vdyQxKCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICh0eXBlID0gITApLFxuICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXdQcm9wcywgITEpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmRGaXJzdFN1c3BlbmRlZChuZXh0UmVzb3VyY2UpKSwgbnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICAgKHR5cGUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXdQcm9wcywgITApLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3UHJvcHMudGFpbCAmJlxuICAgICAgICAgICAgICAgICAgICBcImhpZGRlblwiID09PSBuZXdQcm9wcy50YWlsTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAhbmV4dFJlc291cmNlLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNIeWRyYXRpbmcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAyICogbm93JDEoKSAtIG5ld1Byb3BzLnJlbmRlcmluZ1N0YXJ0VGltZSA+XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgICA1MzY4NzA5MTIgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAodHlwZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXdQcm9wcywgITEpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICAgICAgbmV3UHJvcHMuaXNCYWNrd2FyZHNcbiAgICAgICAgICAgICAgPyAoKG5leHRSZXNvdXJjZS5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRSZXNvdXJjZSkpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gbmV3UHJvcHMubGFzdCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICAgICAgPyAoY3VycmVudC5zaWJsaW5nID0gbmV4dFJlc291cmNlKVxuICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0UmVzb3VyY2UpLFxuICAgICAgICAgICAgICAgIChuZXdQcm9wcy5sYXN0ID0gbmV4dFJlc291cmNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9PSBuZXdQcm9wcy50YWlsKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBuZXdQcm9wcy50YWlsKSxcbiAgICAgICAgICAgICAgKG5ld1Byb3BzLnJlbmRlcmluZyA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAobmV3UHJvcHMudGFpbCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAgIChuZXdQcm9wcy5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQuc2libGluZyA9IG51bGwpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSB0eXBlXG4gICAgICAgICAgICAgICAgPyAocmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSxcbiAgICAgICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAgIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMudHJlZUZvcmtDb3VudCksXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKVxuICAgICAgICAgICAgICA6IG5ld1Byb3BzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSxcbiAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgID8gMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSAmJlxuICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgNiAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpKVxuICAgICAgICAgICAgICA6IGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIG5ld1Byb3BzICE9PSByZW5kZXJMYW5lcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGUgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgK1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyArXG4gICAgICAgICAgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudCAmIDY1NTM2KSAmJiAwID09PSAoY3VycmVudCAmIDEyOClcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaykge1xuICAgICAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgbnVsbCAhPT0gaW50ZXJydXB0ZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHBvcFByb3ZpZGVyKGludGVycnVwdGVkV29yay50eXBlLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRQcm9maWxlKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiAoY3VycmVudC5tb2RlICYgMikgIT09IE5vTW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgobGFzdEVmZmVjdCA9IHZvaWQgMCksXG4gICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITApLFxuICAgICAgICAgICAgICAobGFzdEVmZmVjdCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjYWxsQ3JlYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgdXBkYXRlUXVldWVcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEpLFxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGxhc3RFZmZlY3QgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbGFzdEVmZmVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID1cbiAgICAgICAgICAgICAgICAwICE9PSAodXBkYXRlUXVldWUudGFnICYgTGF5b3V0KVxuICAgICAgICAgICAgICAgICAgPyBcInVzZUxheW91dEVmZmVjdFwiXG4gICAgICAgICAgICAgICAgICA6IDAgIT09ICh1cGRhdGVRdWV1ZS50YWcgJiBJbnNlcnRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIlxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlRWZmZWN0XCI7XG4gICAgICAgICAgICAgIHZhciBhZGRlbmR1bSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICAgIG51bGwgPT09IGxhc3RFZmZlY3RcbiAgICAgICAgICAgICAgICAgID8gXCIgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gdXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLlwiXG4gICAgICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxhc3RFZmZlY3QudGhlblxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuXFxuSXQgbG9va3MgbGlrZSB5b3Ugd3JvdGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICBcIihhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCBhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgaG9va05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKCgpID0+IHtcXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcXG4gICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbiAgICAvLyAuLi5cXG4gIH1cXG4gIGZldGNoRGF0YSgpO1xcbn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcbkxlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL2hvb2tzLWRhdGEtZmV0Y2hpbmdcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIFlvdSByZXR1cm5lZDogXCIgKyBsYXN0RWZmZWN0O1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG4sIGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXNcIixcbiAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgYVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvb2tOYW1lLFxuICAgICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgIGZsYWdzLFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAgICAgICB2YXIgaW5zdCA9IHVwZGF0ZVF1ZXVlLmluc3QsXG4gICAgICAgICAgICAgICAgZGVzdHJveSA9IGluc3QuZGVzdHJveTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBkZXN0cm95ICYmXG4gICAgICAgICAgICAgICAgKChpbnN0LmRlc3Ryb3kgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMCksXG4gICAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgbGFzdEVmZmVjdCxcbiAgICAgICAgICAgICAgICAgIGNhbGxEZXN0cm95SW5ERVYsXG4gICAgICAgICAgICAgICAgICBsYXN0RWZmZWN0LFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSB1cGRhdGVRdWV1ZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyhpbnN0YW5jZSwgcHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzU25hcHNob3QoZmluaXNoZWRXb3JrLCBjdXJyZW50KSB7XG4gICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgKGN1cnJlbnQucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgKSxcbiAgICAgICAgY3VycmVudC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXNvbHZlZFByZXZQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIHByZXZQcm9wc1xuICAgICAgICApO1xuICAgICAgICB2YXIgc25hcHNob3QgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHJlc29sdmVkUHJldlByb3BzLFxuICAgICAgICAgIHByZXZTdGF0ZVxuICAgICAgICApO1xuICAgICAgICBwcmV2UHJvcHMgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgdm9pZCAwICE9PSBzbmFwc2hvdCB8fFxuICAgICAgICAgIHByZXZQcm9wcy5oYXMoZmluaXNoZWRXb3JrLnR5cGUpIHx8XG4gICAgICAgICAgKHByZXZQcm9wcy5hZGQoZmluaXNoZWRXb3JrLnR5cGUpLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIGN1cnJlbnQuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICBjdXJyZW50LnR5cGUsXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgc2hvdWxkUHJvZmlsZShjdXJyZW50KVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgICAgaWYgKG51bGwgIT09IHJlZikge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlVG9Vc2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICBpbnN0YW5jZVRvVXNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbnN0YW5jZVRvVXNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlVG9Vc2UpKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZWZcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcIlN0cmluZyByZWZzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLlwiKVxuICAgICAgICAgICAgOiByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiBVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgY29tbWl0QXR0YWNoUmVmLCBjdXJyZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgICAgIHZhciByZWYgPSBjdXJyZW50LnJlZixcbiAgICAgICAgcmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgICAgIGlmIChudWxsICE9PSByZWYpXG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSlcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZkNsZWFudXApO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZkNsZWFudXApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmLCBudWxsKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWYsIG51bGwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDMpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFByb2ZpbGVyKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgIGVmZmVjdER1cmF0aW9uXG4gICAgKSB7XG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGlkID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLmlkLFxuICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vbkNvbW1pdDtcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblJlbmRlcjtcbiAgICAgIGN1cnJlbnQgPSBudWxsID09PSBjdXJyZW50ID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIjtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCAmJiAoY3VycmVudCA9IFwibmVzdGVkLXVwZGF0ZVwiKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9maW5pc2hlZFdvcmskbWVtb2l6ZSAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9uQ29tbWl0ICYmXG4gICAgICAgIG9uQ29tbWl0KGlkLCBjdXJyZW50LCBlZmZlY3REdXJhdGlvbiwgY29tbWl0U3RhcnRUaW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbChcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLmlkO1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Qb3N0Q29tbWl0O1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplMiAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdE1vdW50LFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFVwZGF0ZShmaW5pc2hlZFdvcmssIG5ld1Byb3BzLCBvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdFVwZGF0ZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgNSA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIDMgPT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAoc3VwcG9ydHNSZXNvdXJjZXMgPyAyNiA9PT0gZmliZXIudGFnIDogITEpIHx8XG4gICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICA/IDI3ID09PSBmaWJlci50YWcgJiYgaXNTaW5nbGV0b25TY29wZShmaWJlci50eXBlKVxuICAgICAgICAgIDogITEpIHx8XG4gICAgICAgIDQgPT09IGZpYmVyLnRhZ1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAgIGE6IGZvciAoOzspIHtcbiAgICAgICAgZm9yICg7IG51bGwgPT09IGZpYmVyLnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlci5yZXR1cm4gfHwgaXNIb3N0UGFyZW50KGZpYmVyLnJldHVybikpIHJldHVybiBudWxsO1xuICAgICAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpYmVyLnNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGZpYmVyID0gZmliZXIuc2libGluZztcbiAgICAgICAgICA1ICE9PSBmaWJlci50YWcgJiYgNiAhPT0gZmliZXIudGFnICYmIDE4ICE9PSBmaWJlci50YWc7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICAyNyA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICAgICBpc1NpbmdsZXRvblNjb3BlKGZpYmVyLnR5cGUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgY29udGludWUgYTtcbiAgICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiAyKSBjb250aW51ZSBhO1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlci5jaGlsZCB8fCA0ID09PSBmaWJlci50YWcpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgZWxzZSAoZmliZXIuY2hpbGQucmV0dXJuID0gZmliZXIpLCAoZmliZXIgPSBmaWJlci5jaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZmliZXIuZmxhZ3MgJiAyKSkgcmV0dXJuIGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgICAgPyBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUsIGJlZm9yZSlcbiAgICAgICAgICAgIDogYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgIDQgIT09IHRhZyAmJlxuICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgMjcgPT09IHRhZyAmJlxuICAgICAgICAgIGlzU2luZ2xldG9uU2NvcGUobm9kZS50eXBlKSAmJlxuICAgICAgICAgICgocGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUpLCAoYmVmb3JlID0gbnVsbCkpLFxuICAgICAgICAobm9kZSA9IG5vZGUuY2hpbGQpLFxuICAgICAgICBudWxsICE9PSBub2RlKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgICBudWxsICE9PSBub2RlO1xuXG4gICAgICAgIClcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgICAgICA/IGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUsIGJlZm9yZSlcbiAgICAgICAgICAgIDogYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICA0ICE9PSB0YWcgJiZcbiAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyAmJlxuICAgICAgICAgIDI3ID09PSB0YWcgJiZcbiAgICAgICAgICBpc1NpbmdsZXRvblNjb3BlKG5vZGUudHlwZSkgJiZcbiAgICAgICAgICAocGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAobm9kZSA9IG5vZGUuY2hpbGQpLFxuICAgICAgICBudWxsICE9PSBub2RlKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBob3N0UGFyZW50RmliZXIsIHBhcmVudEZpYmVyID0gZmluaXNoZWRXb3JrLnJldHVybjtcbiAgICAgICAgbnVsbCAhPT0gcGFyZW50RmliZXI7XG5cbiAgICAgICkge1xuICAgICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudEZpYmVyKSkge1xuICAgICAgICAgIGhvc3RQYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgaWYgKG51bGwgPT0gaG9zdFBhcmVudEZpYmVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBzd2l0Y2ggKGhvc3RQYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgICBob3N0UGFyZW50RmliZXIgPSBob3N0UGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudEZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gaG9zdFBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRGaWJlci5mbGFncyAmIDMyICYmXG4gICAgICAgICAgICAgIChyZXNldFRleHRDb250ZW50KHBhcmVudEZpYmVyKSwgKGhvc3RQYXJlbnRGaWJlci5mbGFncyAmPSAtMzMpKTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaG9zdFBhcmVudEZpYmVyLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBob3N0UGFyZW50RmliZXIgPSBob3N0UGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgICBob3N0UGFyZW50RmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICBwb3J0YWwsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBwZW5kaW5nQ2hpbGRyZW5cbiAgICApIHtcbiAgICAgIHBvcnRhbCA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgcGVuZGluZ0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFNpbmdsZXRvbkFjcXVpc2l0aW9uKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHNpbmdsZXRvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsXG4gICAgICAgIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHNpbmdsZXRvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc0h5ZHJhdGluZ1BhcmVudChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHJldHVybiAzMSA9PT0gZmluaXNoZWRXb3JrLnRhZ1xuICAgICAgICA/ICgoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJiBudWxsID09PSBmaW5pc2hlZFdvcmspXG4gICAgICAgIDogMTMgPT09IGZpbmlzaGVkV29yay50YWdcbiAgICAgICAgICA/ICgoY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50LmRlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgKG51bGwgPT09IGZpbmlzaGVkV29yayB8fCBudWxsID09PSBmaW5pc2hlZFdvcmsuZGVoeWRyYXRlZCkpXG4gICAgICAgICAgOiAzID09PSBmaW5pc2hlZFdvcmsudGFnXG4gICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgMCA9PT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDI1NilcbiAgICAgICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gICAgICBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICBmb3IgKG5leHRFZmZlY3QgPSBmaXJzdENoaWxkOyBudWxsICE9PSBuZXh0RWZmZWN0OyApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHJvb3QgPSBuZXh0RWZmZWN0KSxcbiAgICAgICAgICAoZmlyc3RDaGlsZCA9IHJvb3QuY2hpbGQpLFxuICAgICAgICAgIDAgIT09IChyb290LnN1YnRyZWVGbGFncyAmIDEwMjgpICYmIG51bGwgIT09IGZpcnN0Q2hpbGQpXG4gICAgICAgIClcbiAgICAgICAgICAoZmlyc3RDaGlsZC5yZXR1cm4gPSByb290KSwgKG5leHRFZmZlY3QgPSBmaXJzdENoaWxkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSByb290ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZmlyc3RDaGlsZC5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZsYWdzID0gZmlyc3RDaGlsZC5mbGFncztcbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmbGFncyAmIDQpICYmXG4gICAgICAgICAgICAgICAgICAoKGZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgIChmaXJzdENoaWxkID0gbnVsbCAhPT0gZmlyc3RDaGlsZCA/IGZpcnN0Q2hpbGQuZXZlbnRzIDogbnVsbCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmaXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGZvciAoY3VycmVudCA9IDA7IGN1cnJlbnQgPCBmaXJzdENoaWxkLmxlbmd0aDsgY3VycmVudCsrKVxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgPSBmaXJzdENoaWxkW2N1cnJlbnRdKSxcbiAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MucmVmLmltcGwgPSBmbGFncy5uZXh0SW1wbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAwICE9PSAoZmxhZ3MgJiAxMDI0KSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgY29tbWl0Q2xhc3NTbmFwc2hvdChmaXJzdENoaWxkLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIDAgIT09IChmbGFncyAmIDEwMjQpICYmXG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICBjbGVhckNvbnRhaW5lcihmaXJzdENoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gKGZsYWdzICYgMTAyNCkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSByb290LnNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICBmaXJzdENoaWxkLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCksXG4gICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hDb21wb25lbnRFZmZlY3REdXJhdGlvbigpLFxuICAgICAgICBwcmV2RWZmZWN0RXJyb3JzID0gcHVzaENvbXBvbmVudEVmZmVjdEVycm9ycygpLFxuICAgICAgICBwcmV2RWZmZWN0RGlkU3Bhd25VcGRhdGUgPSBwdXNoQ29tcG9uZW50RWZmZWN0RGlkU3Bhd25VcGRhdGUoKSxcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0IHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICAgICAgaWYgKCgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksIG51bGwgPT09IGN1cnJlbnQpKVxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFJvb3QucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZE1vdW50LiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgY29tcG9uZW50RGlkVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDY0ICYmIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjdXJyZW50ID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSwgbnVsbCAhPT0gZmxhZ3MpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmV2UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpbmlzaGVkV29yay5jaGlsZClcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhjdXJyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0SG9zdFNpbmdsZXRvbkFjcXVpc2l0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpXG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb24gKz0gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEFjdGl2aXR5SHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICAgICAgICgoZmxhZ3MgPSByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5LmJpbmQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoZmluaXNoZWRSb290LCBmbGFncykpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgZmxhZ3MgPVxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgfHwgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGlmICghZmxhZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICBwcmV2UHJvcHMgPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gZmxhZ3M7XG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGN1cnJlbnQpICYmXG4gICAgICAgICAgICAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW5cbiAgICAgICAgICAgICAgPyAocmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgODc3MilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgIDAuMDUgPCBjb21wb25lbnRFZmZlY3RFbmRUaW1lIC0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICBsb2dDb21wb25lbnRSZWFwcGVhcmVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZVxuICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2UHJvcHM7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgICgoY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSB8fCAwLjA1IDwgY29tcG9uZW50RWZmZWN0RHVyYXRpb24pICYmXG4gICAgICAgICAgbG9nQ29tcG9uZW50RWZmZWN0KFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzXG4gICAgICAgICAgKSxcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5yZXR1cm4gJiZcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIDAuMDUgPCBjb21wb25lbnRFZmZlY3RFbmRUaW1lIC0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgKGlzSHlkcmF0aW5nUGFyZW50KFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybi5hbHRlcm5hdGUsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgICAgbG9nQ29tcG9uZW50VHJpZ2dlcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVuZFRpbWUsXG4gICAgICAgICAgICAgIFwiTW91bnRcIlxuICAgICAgICAgICAgKSkpO1xuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdER1cmF0aW9uKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnMgPSBwcmV2RWZmZWN0RXJyb3JzO1xuICAgICAgY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSA9IHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgKChmaWJlci5hbHRlcm5hdGUgPSBudWxsKSwgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKSk7XG4gICAgICBmaWJlci5jaGlsZCA9IG51bGw7XG4gICAgICBmaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICA1ID09PSBmaWJlci50YWcgJiZcbiAgICAgICAgKChhbHRlcm5hdGUgPSBmaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIHBhcmVudFxuICAgICkge1xuICAgICAgZm9yIChwYXJlbnQgPSBwYXJlbnQuY2hpbGQ7IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZGVsZXRlZEZpYmVyXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnRcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJW9cIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpLFxuICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSxcbiAgICAgICAgcHJldkVmZmVjdEVycm9ycyA9IHB1c2hDb21wb25lbnRFZmZlY3RFcnJvcnMoKSxcbiAgICAgICAgcHJldkVmZmVjdERpZFNwYXduVXBkYXRlID0gcHVzaENvbXBvbmVudEVmZmVjdERpZFNwYXduVXBkYXRlKCk7XG4gICAgICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gcmVsZWFzZVJlc291cmNlKGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICA6IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICB1bm1vdW50SG9pc3RhYmxlKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgICB2YXIgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50LFxuICAgICAgICAgICAgICBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgaXNTaW5nbGV0b25TY29wZShkZWxldGVkRmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICAgKChob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSAhMSkpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGhvc3RQYXJlbnQgJiZcbiAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICAgICAgPyBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgID8gKChwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAocHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lciksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSlcbiAgICAgICAgICAgIDogKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgSW5zZXJ0aW9uLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIExheW91dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAoc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciksXG4gICAgICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByZXZIb3N0UGFyZW50LmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBwcmV2SG9zdFBhcmVudFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPVxuICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikgfHxcbiAgICAgICAgICAgIG51bGwgIT09IGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgKGRlbGV0ZWRGaWJlci5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSAmJlxuICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgJiZcbiAgICAgICAgKGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgfHwgMC4wNSA8IGNvbXBvbmVudEVmZmVjdER1cmF0aW9uKSAmJlxuICAgICAgICBsb2dDb21wb25lbnRFZmZlY3QoXG4gICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RFbmRUaW1lLFxuICAgICAgICAgIGNvbXBvbmVudEVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVycm9yc1xuICAgICAgICApO1xuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdER1cmF0aW9uKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnMgPSBwcmV2RWZmZWN0RXJyb3JzO1xuICAgICAgY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSA9IHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0QWN0aXZpdHlIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlKSxcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QubWVtb2l6ZWRTdGF0ZSksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpXG4gICAgICApIHtcbiAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290LmRlaHlkcmF0ZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZEFjdGl2aXR5SW5zdGFuY2UsXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICAgICAgcmV0cnlDYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCB3YWtlYWJsZXMpIHtcbiAgICAgIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICAgICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBpblByb2dyZXNzTGFuZXMgJiYgbnVsbCAhPT0gaW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsIGluUHJvZ3Jlc3NMYW5lcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcbiAgICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QkanNjb21wJDAsIHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyID0gZGVsZXRpb25zW2ldLFxuICAgICAgICAgICAgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCk7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGE6IGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaW5nbGV0b25TY29wZShwYXJlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgIH0gZWxzZSBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIChkZWxldGVkRmliZXIubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgJiZcbiAgICAgICAgICAgIDAuMDUgPCBjb21wb25lbnRFZmZlY3RFbmRUaW1lIC0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICBsb2dDb21wb25lbnRUcmlnZ2VyKFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICAgICAgXCJVbm1vdW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgICAgICByb290ID0gZGVsZXRlZEZpYmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcm9vdC5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiYgKHJldHVybkZpYmVyLnJldHVybiA9IG51bGwpO1xuICAgICAgICAgIHJvb3QucmV0dXJuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEzODg2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihwYXJlbnRGaWJlciwgcm9vdCRqc2NvbXAkMCksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKSxcbiAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaENvbXBvbmVudEVmZmVjdER1cmF0aW9uKCksXG4gICAgICAgIHByZXZFZmZlY3RFcnJvcnMgPSBwdXNoQ29tcG9uZW50RWZmZWN0RXJyb3JzKCksXG4gICAgICAgIHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZSA9IHB1c2hDb21wb25lbnRFZmZlY3REaWRTcGF3blVwZGF0ZSgpLFxuICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIChjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbiB8IEhhc0VmZmVjdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgTGF5b3V0IHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmxhZ3MuY2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICgocm9vdCA9IGZsYWdzLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MpLFxuICAgICAgICAgICAgICAgIChmbGFncy5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID1cbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3QgPyBjdXJyZW50IDogcm9vdC5jb25jYXQoY3VycmVudCkpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGhvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsKSxcbiAgICAgICAgICAgICAgKHJvb3QgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgID8gbnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICA/IChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gaHlkcmF0ZUhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgOiBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogZmxhZ3MgIT09IHJvb3RcbiAgICAgICAgICAgICAgICAgID8gKG51bGwgPT09IGZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBjdXJyZW50LnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShjdXJyZW50LnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHJlbGVhc2VSZXNvdXJjZShmbGFncyksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICA/IG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAzMikge1xuICAgICAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIHJlc2V0VGV4dENvbnRlbnQsIHJvb3QpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAgIG51bGwgIT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAoKHJvb3QgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJvb3RcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBmbGFncyAmIDEwMjQgJiZcbiAgICAgICAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJmb3JtXCIgIT09IGZpbmlzaGVkV29yay50eXBlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBob3N0IGNvbXBvbmVudCB0eXBlLiBFeHBlY3RlZCBhIGZvcm0uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5zdGF0ZU5vZGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0ICYmIHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IGZsYWdzO1xuICAgICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZmxhZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzKCk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3Qocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICAgIH0gZWxzZSByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICByb290LmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgZmxhZ3MgPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSByb290LnBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ICYmXG4gICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITEpLCByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMoaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSBjdXJyZW50SG9pc3RhYmxlUm9vdCksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBjdXJyZW50KSlcbiAgICAgICAgICAgIDogKHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGVuZGluZ0NoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuY2hpbGQuZmxhZ3MgJiA4MTkyICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpICE9PVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgICAgICAoZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCkpO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID1cbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IHdhc0hpZGRlbjtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgd2FzSGlkZGVuICYmXG4gICAgICAgICAgICAhaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgIXByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gJiZcbiAgICAgICAgICAgICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiAmJlxuICAgICAgICAgICAgKGZpbmlzaGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0RW5kVGltZSAmJlxuICAgICAgICAgICAgMC4wNSA8IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgLSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgIGxvZ0NvbXBvbmVudFJlYXBwZWFyZWQoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RFbmRUaW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKChyb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocm9vdC5fdmlzaWJpbGl0eSA9IGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgfk9mZnNjcmVlblZpc2libGVcbiAgICAgICAgICAgICAgOiByb290Ll92aXNpYmlsaXR5IHwgT2Zmc2NyZWVuVmlzaWJsZSksXG4gICAgICAgICAgICAhaG9pc3RhYmxlUm9vdCB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICAocmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGZpbmlzaGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgICAgICAgICAgMC4wNSA8IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgLSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICBsb2dDb21wb25lbnRUcmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIFwiRGlzY29ubmVjdFwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGE6IGlmICgoKGN1cnJlbnQgPSBudWxsKSwgc3VwcG9ydHNNdXRhdGlvbikpXG4gICAgICAgICAgICAgIGZvciAocm9vdCA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgICAgICAgICBpZiAoNSA9PT0gcm9vdC50YWcgfHwgKHN1cHBvcnRzUmVzb3VyY2VzICYmIDI2ID09PSByb290LnRhZykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbiA9IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSB3YXNIaWRkZW4uc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlkZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IHJvb3QudGFnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4gPSByb290O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdhc0hpZGRlbi5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDE4ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UkanNjb21wJDAgPSB3YXNIaWRkZW4uc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVEZWh5ZHJhdGVkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWRlRGVoeWRyYXRlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgKCgyMiAhPT0gcm9vdC50YWcgJiYgMjMgIT09IHJvb3QudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByb290Lm1lbW9pemVkU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gZmluaXNoZWRXb3JrKSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdC5jaGlsZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcm9vdC5jaGlsZC5yZXR1cm4gPSByb290O1xuICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgPT09IGZpbmlzaGVkV29yaykgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gcm9vdC5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSByb290LnJldHVybiB8fCByb290LnJldHVybiA9PT0gZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgcm9vdC5zaWJsaW5nLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmxhZ3MucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAoKGZsYWdzLnJldHJ5UXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgY3VycmVudCkpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgICAoZmluaXNoZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0RW5kVGltZSAmJlxuICAgICAgICAoKGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgfHwgMC4wNSA8IGNvbXBvbmVudEVmZmVjdER1cmF0aW9uKSAmJlxuICAgICAgICAgIGxvZ0NvbXBvbmVudEVmZmVjdChcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSxcbiAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVuZFRpbWUsXG4gICAgICAgICAgICBjb21wb25lbnRFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVycm9yc1xuICAgICAgICAgICksXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuICYmXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnJldHVybi5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAwLjA1IDwgY29tcG9uZW50RWZmZWN0RW5kVGltZSAtIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSAmJlxuICAgICAgICAgIChpc0h5ZHJhdGluZ1BhcmVudChcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4uYWx0ZXJuYXRlLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVyblxuICAgICAgICAgICkgfHxcbiAgICAgICAgICAgIGxvZ0NvbXBvbmVudFRyaWdnZXIoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RFbmRUaW1lLFxuICAgICAgICAgICAgICBcIk1vdW50XCJcbiAgICAgICAgICAgICkpKTtcbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3REdXJhdGlvbihwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzID0gcHJldkVmZmVjdEVycm9ycztcbiAgICAgIGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgPSBwcmV2RWZmZWN0RGlkU3Bhd25VcGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdFBsYWNlbWVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTM7XG4gICAgICB9XG4gICAgICBmbGFncyAmIDQwOTYgJiYgKGZpbmlzaGVkV29yay5mbGFncyAmPSAtNDA5Nyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjQpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciBmaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaWJlcik7XG4gICAgICAgICAgNSA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICAgICBmaWJlci5mbGFncyAmIDEwMjQgJiZcbiAgICAgICAgICAgIHJlc2V0Rm9ybUluc3RhbmNlKGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3MilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgcGFyZW50RmliZXIuYWx0ZXJuYXRlLCBwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKSxcbiAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaENvbXBvbmVudEVmZmVjdER1cmF0aW9uKCksXG4gICAgICAgIHByZXZFZmZlY3RFcnJvcnMgPSBwdXNoQ29tcG9uZW50RWZmZWN0RXJyb3JzKCksXG4gICAgICAgIHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZSA9IHB1c2hDb21wb25lbnRFZmZlY3REaWRTcGF3blVwZGF0ZSgpO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgTGF5b3V0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgIChjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlIHx8IDAuMDUgPCBjb21wb25lbnRFZmZlY3REdXJhdGlvbikgJiZcbiAgICAgICAgbG9nQ29tcG9uZW50RWZmZWN0KFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnNcbiAgICAgICAgKTtcbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3REdXJhdGlvbihwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzID0gcHJldkVmZmVjdEVycm9ycztcbiAgICAgIGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgPSBwcmV2RWZmZWN0RGlkU3Bhd25VcGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBjdXJyZW50LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpLFxuICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSxcbiAgICAgICAgcHJldkVmZmVjdEVycm9ycyA9IHB1c2hDb21wb25lbnRFZmZlY3RFcnJvcnMoKSxcbiAgICAgICAgcHJldkVmZmVjdERpZFNwYXduVXBkYXRlID0gcHVzaENvbXBvbmVudEVmZmVjdERpZFNwYXduVXBkYXRlKCksXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBMYXlvdXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRIaWRkZW5DYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIHN1cHBvcnRzU2luZ2xldG9ucyAmJiBjb21taXRIb3N0U2luZ2xldG9uQWNxdWlzaXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgNCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEFjdGl2aXR5SHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgIChjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlIHx8IDAuMDUgPCBjb21wb25lbnRFZmZlY3REdXJhdGlvbikgJiZcbiAgICAgICAgbG9nQ29tcG9uZW50RWZmZWN0KFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnNcbiAgICAgICAgKTtcbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3REdXJhdGlvbihwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzID0gcHJldkVmZmVjdEVycm9ycztcbiAgICAgIGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgPSBwcmV2RWZmZWN0RGlkU3Bhd25VcGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPVxuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKTtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBwYXJlbnRGaWJlci5hbHRlcm5hdGUsXG4gICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAocHJldmlvdXNDYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgICAgIGN1cnJlbnQgIT09IHByZXZpb3VzQ2FjaGUgJiZcbiAgICAgICAgKG51bGwgIT0gY3VycmVudCAmJiByZXRhaW5DYWNoZShjdXJyZW50KSxcbiAgICAgICAgbnVsbCAhPSBwcmV2aW91c0NhY2hlICYmIHJlbGVhc2VDYWNoZShwcmV2aW91c0NhY2hlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgIGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgZmluaXNoZWRXb3JrICE9PSBjdXJyZW50ICYmXG4gICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLCBudWxsICE9IGN1cnJlbnQgJiYgcmVsZWFzZUNhY2hlKGN1cnJlbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICByb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgZW5kVGltZVxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NiB8fFxuICAgICAgICAoMCAhPT0gcGFyZW50RmliZXIuYWN0dWFsRHVyYXRpb24gJiZcbiAgICAgICAgICAobnVsbCA9PT0gcGFyZW50RmliZXIuYWx0ZXJuYXRlIHx8XG4gICAgICAgICAgICBwYXJlbnRGaWJlci5hbHRlcm5hdGUuY2hpbGQgIT09IHBhcmVudEZpYmVyLmNoaWxkKSlcbiAgICAgIClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRTaWJsaW5nID8gbmV4dFNpYmxpbmcuYWN0dWFsU3RhcnRUaW1lIDogZW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBuZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgIGVuZFRpbWVcbiAgICApIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKSxcbiAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaENvbXBvbmVudEVmZmVjdER1cmF0aW9uKCksXG4gICAgICAgIHByZXZFZmZlY3RFcnJvcnMgPSBwdXNoQ29tcG9uZW50RWZmZWN0RXJyb3JzKCksXG4gICAgICAgIHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZSA9IHB1c2hDb21wb25lbnRFZmZlY3REaWRTcGF3blVwZGF0ZSgpLFxuICAgICAgICBwcmV2RGVlcEVxdWFsaXR5ID0gYWxyZWFkeVdhcm5lZEZvckRlZXBFcXVhbGl0eSxcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgIDAgPCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lICYmXG4gICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMSkgJiZcbiAgICAgICAgICAgIGxvZ0NvbXBvbmVudFJlbmRlcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICBpbkh5ZHJhdGVkU3VidHJlZSxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUgfCBIYXNFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgKGZpbmlzaGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgMCA8IGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICgwICE9PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTI4KVxuICAgICAgICAgICAgICA/IGxvZ0NvbXBvbmVudEVycm9yZWQoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxKSAmJlxuICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudFJlbmRlcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgaW5IeWRyYXRlZFN1YnRyZWUsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lc1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpLFxuICAgICAgICAgICAgd2FzSW5IeWRyYXRlZFN1YnRyZWUgPSBpbkh5ZHJhdGVkU3VidHJlZTtcbiAgICAgICAgICBpbkh5ZHJhdGVkU3VidHJlZSA9XG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAwID09PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMjU2KTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbkh5ZHJhdGVkU3VidHJlZSA9IHdhc0luSHlkcmF0ZWRTdWJ0cmVlO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgKChjb21taXR0ZWRMYW5lcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAoY29tbWl0dGVkTGFuZXMgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgKGNvbW1pdHRlZFRyYW5zaXRpb25zID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMgIT09IGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIChyZXRhaW5DYWNoZShjb21taXR0ZWRUcmFuc2l0aW9ucyksXG4gICAgICAgICAgICAgIG51bGwgIT0gY29tbWl0dGVkTGFuZXMgJiYgcmVsZWFzZUNhY2hlKGNvbW1pdHRlZExhbmVzKSkpO1xuICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKFxuICAgICAgICAgICAgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChmbGFncyAmIDIwNDgpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgZmxhZ3MgPSBpbkh5ZHJhdGVkU3VidHJlZTtcbiAgICAgICAgICBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9XG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlXG4gICAgICAgICAgICAgID8gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICB3YXNJbkh5ZHJhdGVkU3VidHJlZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uICYmIG51bGwgPT09IHdhc0luSHlkcmF0ZWRTdWJ0cmVlXG4gICAgICAgICAgICA/ICgod2FzSW5IeWRyYXRlZFN1YnRyZWUgPSBmaW5pc2hlZFdvcmsuZGVsZXRpb25zKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gd2FzSW5IeWRyYXRlZFN1YnRyZWUgJiZcbiAgICAgICAgICAgICAgMCA8IHdhc0luSHlkcmF0ZWRTdWJ0cmVlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAxOCA9PT0gd2FzSW5IeWRyYXRlZFN1YnRyZWVbMF0udGFnXG4gICAgICAgICAgICAgICAgPyAoKGluSHlkcmF0ZWRTdWJ0cmVlID0gITEpLFxuICAgICAgICAgICAgICAgICAgKHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24uaHlkcmF0aW9uRXJyb3JzKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudEVycm9yZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKGluSHlkcmF0ZWRTdWJ0cmVlID0gITApKVxuICAgICAgICAgICAgOiAoaW5IeWRyYXRlZFN1YnRyZWUgPSAhMSk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5IeWRyYXRlZFN1YnRyZWUgPSBmbGFncztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBmbGFncyA9IGluSHlkcmF0ZWRTdWJ0cmVlO1xuICAgICAgICAgIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGVcbiAgICAgICAgICAgICAgPyBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIHdhc0luSHlkcmF0ZWRTdWJ0cmVlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCA9PT0gcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gfHxcbiAgICAgICAgICBudWxsID09PSBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbi5kZWh5ZHJhdGVkIHx8XG4gICAgICAgICAgKG51bGwgIT09IHdhc0luSHlkcmF0ZWRTdWJ0cmVlICYmXG4gICAgICAgICAgICBudWxsICE9PSB3YXNJbkh5ZHJhdGVkU3VidHJlZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICAgPyAoaW5IeWRyYXRlZFN1YnRyZWUgPSAhMSlcbiAgICAgICAgICAgIDogKCh3YXNJbkh5ZHJhdGVkU3VidHJlZSA9IGZpbmlzaGVkV29yay5kZWxldGlvbnMpLFxuICAgICAgICAgICAgICBudWxsICE9PSB3YXNJbkh5ZHJhdGVkU3VidHJlZSAmJlxuICAgICAgICAgICAgICAwIDwgd2FzSW5IeWRyYXRlZFN1YnRyZWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgIDE4ID09PSB3YXNJbkh5ZHJhdGVkU3VidHJlZVswXS50YWdcbiAgICAgICAgICAgICAgICA/ICgoaW5IeWRyYXRlZFN1YnRyZWUgPSAhMSksXG4gICAgICAgICAgICAgICAgICAocHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbi5oeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgbG9nQ29tcG9uZW50RXJyb3JlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiAoaW5IeWRyYXRlZFN1YnRyZWUgPSAhMCkpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGluSHlkcmF0ZWRTdWJ0cmVlID0gZmxhZ3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgd2FzSW5IeWRyYXRlZFN1YnRyZWUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyB3YXNJbkh5ZHJhdGVkU3VidHJlZS5fdmlzaWJpbGl0eSAmXG4gICAgICAgICAgICAgIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogd2FzSW5IeWRyYXRlZFN1YnRyZWUuX3Zpc2liaWxpdHkgJlxuICAgICAgICAgICAgICAgIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKHdhc0luSHlkcmF0ZWRTdWJ0cmVlLl92aXNpYmlsaXR5IHw9XG4gICAgICAgICAgICAgICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpIHx8XG4gICAgICAgICAgICAgICAgICAgICgwICE9PSBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCAhPT0gZmluaXNoZWRXb3JrLmNoaWxkKSksXG4gICAgICAgICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLm1vZGUgJiAyKSA9PT0gTm9Nb2RlIHx8XG4gICAgICAgICAgICAgICAgICBpbkh5ZHJhdGVkU3VidHJlZSB8fFxuICAgICAgICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAgICAgICAgIDAuMDUgPCBlbmRUaW1lIC0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudFJlYXBwZWFyZWQoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFJvb3QsIGVuZFRpbWUpLFxuICAgICAgICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIDAuMDUgPCBjb21wb25lbnRFZmZlY3RFbmRUaW1lIC0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudFJlYXBwZWFyZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RFbmRUaW1lXG4gICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChmaW5pc2hlZFJvb3QgPVxuICAgICAgICAgICAgIWluSHlkcmF0ZWRTdWJ0cmVlICYmXG4gICAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuICYmXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLmFsdGVybmF0ZSlcbiAgICAgICAgKVxuICAgICAgICAgIChjb21taXR0ZWRMYW5lcyA9IGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUpLFxuICAgICAgICAgICAgMCA8PSBjb21taXR0ZWRMYW5lcyAmJlxuICAgICAgICAgICAgICAwLjA1IDwgZW5kVGltZSAtIGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIGxvZ0NvbXBvbmVudFRyaWdnZXIoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgXCJNb3VudFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgICAgKChjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlIHx8IDAuMDUgPCBjb21wb25lbnRFZmZlY3REdXJhdGlvbikgJiZcbiAgICAgICAgICAgIGxvZ0NvbXBvbmVudEVmZmVjdChcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVuZFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAwLjA1IDwgY29tcG9uZW50RWZmZWN0RW5kVGltZSAtIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSAmJlxuICAgICAgICAgICAgbG9nQ29tcG9uZW50VHJpZ2dlcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVuZFRpbWUsXG4gICAgICAgICAgICAgIFwiTW91bnRcIlxuICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0RHVyYXRpb24ocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgIGNvbXBvbmVudEVmZmVjdEVycm9ycyA9IHByZXZFZmZlY3RFcnJvcnM7XG4gICAgICBjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlID0gcHJldkVmZmVjdERpZFNwYXduVXBkYXRlO1xuICAgICAgYWxyZWFkeVdhcm5lZEZvckRlZXBFcXVhbGl0eSA9IHByZXZEZWVwRXF1YWxpdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMsXG4gICAgICBlbmRUaW1lXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAoMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KSB8fFxuICAgICAgICAgICgwICE9PSBwYXJlbnRGaWJlci5hY3R1YWxEdXJhdGlvbiAmJlxuICAgICAgICAgICAgKG51bGwgPT09IHBhcmVudEZpYmVyLmFsdGVybmF0ZSB8fFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlci5hbHRlcm5hdGUuY2hpbGQgIT09IHBhcmVudEZpYmVyLmNoaWxkKSkpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLFxuICAgICAgICAgIG51bGwgIT09IG5leHRTaWJsaW5nID8gbmV4dFNpYmxpbmcuYWN0dWFsU3RhcnRUaW1lIDogZW5kVGltZVxuICAgICAgICApO1xuICAgICAgICBwYXJlbnRGaWJlciA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLFxuICAgICAgZW5kVGltZVxuICAgICkge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpLFxuICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSxcbiAgICAgICAgcHJldkVmZmVjdEVycm9ycyA9IHB1c2hDb21wb25lbnRFZmZlY3RFcnJvcnMoKSxcbiAgICAgICAgcHJldkVmZmVjdERpZFNwYXduVXBkYXRlID0gcHVzaENvbXBvbmVudEVmZmVjdERpZFNwYXduVXBkYXRlKCksXG4gICAgICAgIHByZXZEZWVwRXF1YWxpdHkgPSBhbHJlYWR5V2FybmVkRm9yRGVlcEVxdWFsaXR5O1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAoZmluaXNoZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIDAgPCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lICYmXG4gICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxKSAmJlxuICAgICAgICBsb2dDb21wb25lbnRSZW5kZXIoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICBpbkh5ZHJhdGVkU3VidHJlZSxcbiAgICAgICAgICBjb21taXR0ZWRMYW5lc1xuICAgICAgICApO1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyxcbiAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgUGFzc2l2ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogKChfaW5zdGFuY2UyLl92aXNpYmlsaXR5IHw9IE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLFxuICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLFxuICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICAoZmluaXNoZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0RW5kVGltZSAmJlxuICAgICAgICAoY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSB8fCAwLjA1IDwgY29tcG9uZW50RWZmZWN0RHVyYXRpb24pICYmXG4gICAgICAgIGxvZ0NvbXBvbmVudEVmZmVjdChcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVuZFRpbWUsXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzXG4gICAgICAgICk7XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0RHVyYXRpb24ocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgIGNvbXBvbmVudEVmZmVjdEVycm9ycyA9IHByZXZFZmZlY3RFcnJvcnM7XG4gICAgICBjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlID0gcHJldkVmZmVjdERpZFNwYXduVXBkYXRlO1xuICAgICAgYWxyZWFkeVdhcm5lZEZvckRlZXBFcXVhbGl0eSA9IHByZXZEZWVwRXF1YWxpdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMkanNjb21wJDAsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyRqc2NvbXAkMCxcbiAgICAgIGVuZFRpbWUkanNjb21wJDBcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgcGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYgfHxcbiAgICAgICAgKDAgIT09IHBhcmVudEZpYmVyLmFjdHVhbER1cmF0aW9uICYmXG4gICAgICAgICAgKG51bGwgPT09IHBhcmVudEZpYmVyLmFsdGVybmF0ZSB8fFxuICAgICAgICAgICAgcGFyZW50RmliZXIuYWx0ZXJuYXRlLmNoaWxkICE9PSBwYXJlbnRGaWJlci5jaGlsZCkpXG4gICAgICApXG4gICAgICAgIGZvciAodmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApIHtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgdmFyIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzID0gY29tbWl0dGVkTGFuZXMkanNjb21wJDAsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyA9IGNvbW1pdHRlZFRyYW5zaXRpb25zJGpzY29tcCQwLFxuICAgICAgICAgICAgZW5kVGltZSA9XG4gICAgICAgICAgICAgIG51bGwgIT09IHBhcmVudEZpYmVyXG4gICAgICAgICAgICAgICAgPyBwYXJlbnRGaWJlci5hY3R1YWxTdGFydFRpbWVcbiAgICAgICAgICAgICAgICA6IGVuZFRpbWUkanNjb21wJDAsXG4gICAgICAgICAgICBwcmV2RGVlcEVxdWFsaXR5ID0gYWxyZWFkeVdhcm5lZEZvckRlZXBFcXVhbGl0eTtcbiAgICAgICAgICAoY2hpbGQubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgIDAgPCBjaGlsZC5hY3R1YWxTdGFydFRpbWUgJiZcbiAgICAgICAgICAgIDAgIT09IChjaGlsZC5mbGFncyAmIDEpICYmXG4gICAgICAgICAgICBsb2dDb21wb25lbnRSZW5kZXIoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICBjaGlsZC5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIGluSHlkcmF0ZWRTdWJ0cmVlLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgZmxhZ3MgPSBjaGlsZC5mbGFncztcbiAgICAgICAgICBzd2l0Y2ggKGNoaWxkLnRhZykge1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY2hpbGQuYWx0ZXJuYXRlLCBjaGlsZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGNoaWxkLmFsdGVybmF0ZSwgY2hpbGQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbHJlYWR5V2FybmVkRm9yRGVlcEVxdWFsaXR5ID0gcHJldkRlZXBFcXVhbGl0eTtcbiAgICAgICAgICBjaGlsZCA9IHBhcmVudEZpYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRTdGF0ZVxuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihcbiAgICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBzdXNwZW5kZWRTdGF0ZVxuICAgICAgICAgICksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoXG4gICAgICBmaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkU3RhdGVcbiAgICApIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZFN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIHN1c3BlbmRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICBzdXNwZW5kZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgKChjb21taXR0ZWRMYW5lcyAmIDMzNTU0NDEyOCkgPT09IGNvbW1pdHRlZExhbmVzIHx8XG4gICAgICAgICAgICAgICAgbWF5U3VzcGVuZENvbW1pdEluU3luY1JlbmRlcih0eXBlLCBmaWJlcikpICYmXG4gICAgICAgICAgICAgICAgc3VzcGVuZEluc3RhbmNlKHN1c3BlbmRlZFN0YXRlLCBpbnN0YW5jZSwgdHlwZSwgZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZFN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgICAgICgoaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKHR5cGUgPSBmaWJlci50eXBlKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgKChjb21taXR0ZWRMYW5lcyAmIDMzNTU0NDEyOCkgPT09IGNvbW1pdHRlZExhbmVzIHx8XG4gICAgICAgICAgICAgIG1heVN1c3BlbmRDb21taXRJblN5bmNSZW5kZXIodHlwZSwgZmliZXIpKSAmJlxuICAgICAgICAgICAgICBzdXNwZW5kSW5zdGFuY2Uoc3VzcGVuZGVkU3RhdGUsIGluc3RhbmNlLCB0eXBlLCBmaWJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAoKGluc3RhbmNlID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoXG4gICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgc3VzcGVuZGVkU3RhdGVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gaW5zdGFuY2UpKVxuICAgICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoXG4gICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgc3VzcGVuZGVkU3RhdGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoKGluc3RhbmNlID0gZmliZXIuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmIG51bGwgIT09IGluc3RhbmNlLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAoKGluc3RhbmNlID0gc3VzcGVuc2V5Q29tbWl0RmxhZyksXG4gICAgICAgICAgICAgICAgKHN1c3BlbnNleUNvbW1pdEZsYWcgPSAxNjc3NzIxNiksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHN1c3BlbmRlZFN0YXRlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IGluc3RhbmNlKSlcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgc3VzcGVuZGVkU3RhdGVcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgc3VzcGVuZGVkU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzRmliZXIgJiZcbiAgICAgICAgKChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIuY2hpbGQpLCBudWxsICE9PSBwYXJlbnRGaWJlcilcbiAgICAgICkge1xuICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgICAgZG9cbiAgICAgICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIpO1xuICAgICAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXSxcbiAgICAgICAgICAgICAgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKGNoaWxkVG9EZWxldGUubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgICAgICAgIDAuMDUgPCBjb21wb25lbnRFZmZlY3RFbmRUaW1lIC0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgIGxvZ0NvbXBvbmVudFRyaWdnZXIoXG4gICAgICAgICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICAgICAgICBcIlVubW91bnRcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpLFxuICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSxcbiAgICAgICAgcHJldkVmZmVjdEVycm9ycyA9IHB1c2hDb21wb25lbnRFZmZlY3RFcnJvcnMoKSxcbiAgICAgICAgcHJldkVmZmVjdERpZFNwYXduVXBkYXRlID0gcHVzaENvbXBvbmVudEVmZmVjdERpZFNwYXduVXBkYXRlKCk7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIFBhc3NpdmUgfCBIYXNFZmZlY3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmXG4gICAgICAgICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCAmJlxuICAgICAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgICAgID8gKChwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmPVxuICAgICAgICAgICAgICAgIH5PZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGZpbmlzaGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgICAgICAgICAgMC4wNSA8IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgLSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICBsb2dDb21wb25lbnRUcmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIFwiRGlzY29ubmVjdFwiXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIChmaW5pc2hlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgMCA8PSBjb21wb25lbnRFZmZlY3RFbmRUaW1lICYmXG4gICAgICAgIChjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlIHx8IDAuMDUgPCBjb21wb25lbnRFZmZlY3REdXJhdGlvbikgJiZcbiAgICAgICAgbG9nQ29tcG9uZW50RWZmZWN0KFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUsXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnNcbiAgICAgICAgKTtcbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3REdXJhdGlvbihwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSA9IHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZTtcbiAgICAgIGNvbXBvbmVudEVmZmVjdEVycm9ycyA9IHByZXZFZmZlY3RFcnJvcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldLFxuICAgICAgICAgICAgICBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAoY2hpbGRUb0RlbGV0ZS5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSAmJlxuICAgICAgICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgJiZcbiAgICAgICAgICAgICAgMC4wNSA8IGNvbXBvbmVudEVmZmVjdEVuZFRpbWUgLSBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgbG9nQ29tcG9uZW50VHJpZ2dlcihcbiAgICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRFZmZlY3RFbmRUaW1lLFxuICAgICAgICAgICAgICAgIFwiVW5tb3VudFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpLFxuICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSxcbiAgICAgICAgcHJldkVmZmVjdEVycm9ycyA9IHB1c2hDb21wb25lbnRFZmZlY3RFcnJvcnMoKSxcbiAgICAgICAgcHJldkVmZmVjdERpZFNwYXduVXBkYXRlID0gcHVzaENvbXBvbmVudEVmZmVjdERpZFNwYXduVXBkYXRlKCk7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgUGFzc2l2ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCAmJlxuICAgICAgICAgICAgKChpbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgICAoZmluaXNoZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lICYmXG4gICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0RW5kVGltZSAmJlxuICAgICAgICAoY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSB8fCAwLjA1IDwgY29tcG9uZW50RWZmZWN0RHVyYXRpb24pICYmXG4gICAgICAgIGxvZ0NvbXBvbmVudEVmZmVjdChcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgIGNvbXBvbmVudEVmZmVjdEVuZFRpbWUsXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzXG4gICAgICAgICk7XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0RHVyYXRpb24ocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgIGNvbXBvbmVudEVmZmVjdFNwYXduZWRVcGRhdGUgPSBwcmV2RWZmZWN0RGlkU3Bhd25VcGRhdGU7XG4gICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnMgPSBwcmV2RWZmZWN0RXJyb3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgZGVsZXRlZFN1YnRyZWVSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciRqc2NvbXAkMFxuICAgICkge1xuICAgICAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0LFxuICAgICAgICAgIGN1cnJlbnQgPSBmaWJlcixcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvciRqc2NvbXAkMCxcbiAgICAgICAgICBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKSxcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoQ29tcG9uZW50RWZmZWN0RHVyYXRpb24oKSxcbiAgICAgICAgICBwcmV2RWZmZWN0RXJyb3JzID0gcHVzaENvbXBvbmVudEVmZmVjdEVycm9ycygpLFxuICAgICAgICAgIHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZSA9IHB1c2hDb21wb25lbnRFZmZlY3REaWRTcGF3blVwZGF0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAoKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgJiZcbiAgICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcmVsZWFzZUNhY2hlKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgKGN1cnJlbnQubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAwIDw9IGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSAmJlxuICAgICAgICAgIDAgPD0gY29tcG9uZW50RWZmZWN0RW5kVGltZSAmJlxuICAgICAgICAgIChjb21wb25lbnRFZmZlY3RTcGF3bmVkVXBkYXRlIHx8IDAuMDUgPCBjb21wb25lbnRFZmZlY3REdXJhdGlvbikgJiZcbiAgICAgICAgICBsb2dDb21wb25lbnRFZmZlY3QoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lLFxuICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSxcbiAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzXG4gICAgICAgICAgKTtcbiAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0RHVyYXRpb24ocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSA9IHByZXZFZmZlY3REaWRTcGF3blVwZGF0ZTtcbiAgICAgICAgY29tcG9uZW50RWZmZWN0RXJyb3JzID0gcHJldkVmZmVjdEVycm9ycztcbiAgICAgICAgY3VycmVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkgKGN1cnJlbnQucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IGN1cnJlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYTogZm9yIChmaWJlciA9IGRlbGV0ZWRTdWJ0cmVlUm9vdDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHByZXZFZmZlY3RTdGFydCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gcHJldkVmZmVjdFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHByZXZFZmZlY3RTdGFydC5yZXR1cm4gPSBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBwcmV2RWZmZWN0U3RhcnQ7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KSB7XG4gICAgICB2YXIgbWF5YmVGaWJlciA9IGdldEluc3RhbmNlRnJvbU5vZGUoaG9zdFJvb3QpO1xuICAgICAgaWYgKG51bGwgIT0gbWF5YmVGaWJlcikge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG1heWJlRmliZXIubWVtb2l6ZWRQcm9wc1tcImRhdGEtdGVzdG5hbWVcIl0pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgaG9zdCByb290IHNwZWNpZmllZC4gU2hvdWxkIGJlIGVpdGhlciBhIFJlYWN0IGNvbnRhaW5lciBvciBhIG5vZGUgd2l0aCBhIHRlc3RuYW1lIGF0dHJpYnV0ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBtYXliZUZpYmVyO1xuICAgICAgfVxuICAgICAgaG9zdFJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcbiAgICAgIGlmIChudWxsID09PSBob3N0Um9vdClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJDb3VsZCBub3QgZmluZCBSZWFjdCBjb250YWluZXIgd2l0aGluIHNwZWNpZmllZCBob3N0IHN1YnRyZWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBob3N0Um9vdC5zdGF0ZU5vZGUuY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF0Y2hTZWxlY3RvcihmaWJlciRqc2NvbXAkMCwgc2VsZWN0b3IpIHtcbiAgICAgIHZhciB0YWcgPSBmaWJlciRqc2NvbXAkMC50YWc7XG4gICAgICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICAgICAgaWYgKGZpYmVyJGpzY29tcCQwLnR5cGUgPT09IHNlbGVjdG9yLnZhbHVlKSByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IudmFsdWU7XG4gICAgICAgICAgICBmaWJlciRqc2NvbXAkMCA9IFtmaWJlciRqc2NvbXAkMCwgMF07XG4gICAgICAgICAgICBmb3IgKHRhZyA9IDA7IHRhZyA8IGZpYmVyJGpzY29tcCQwLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgIHZhciBmaWJlciA9IGZpYmVyJGpzY29tcCQwW3RhZysrXSxcbiAgICAgICAgICAgICAgICB0YWckanNjb21wJDAgPSBmaWJlci50YWcsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCA9IGZpYmVyJGpzY29tcCQwW3RhZysrXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciRqc2NvbXAkMCA9IHNlbGVjdG9yW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKDUgIT09IHRhZyRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgMjYgIT09IHRhZyRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgMjcgIT09IHRhZyRqc2NvbXAkMCkgfHxcbiAgICAgICAgICAgICAgICAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBzZWxlY3RvciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IkanNjb21wJDApO1xuXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCsrLFxuICAgICAgICAgICAgICAgICAgICAoc2VsZWN0b3IkanNjb21wJDAgPSBzZWxlY3RvcltzZWxlY3RvckluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPT09IHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwLnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RvciA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKSAmJlxuICAgICAgICAgICAgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZShmaWJlciRqc2NvbXAkMC5zdGF0ZU5vZGUsIHNlbGVjdG9yLnZhbHVlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGZpYmVyJGpzY29tcCQwID0gZ2V0VGV4dENvbnRlbnQoZmliZXIkanNjb21wJDApKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmliZXIkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAwIDw9IGZpYmVyJGpzY29tcCQwLmluZGV4T2Yoc2VsZWN0b3IudmFsdWUpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG4gICAgICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoZmliZXIkanNjb21wJDAgPSBmaWJlciRqc2NvbXAkMC5tZW1vaXplZFByb3BzW1wiZGF0YS10ZXN0bmFtZVwiXSksXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBmaWJlciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnZhbHVlLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB7XG4gICAgICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShzZWxlY3Rvci52YWx1ZSkgfHwgXCJVbmtub3duXCIpICsgXCI+XCJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCI6aGFzKFwiICsgKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHx8IFwiXCIpICsgXCIpXCI7XG4gICAgICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnW3JvbGU9XCInICsgc2VsZWN0b3IudmFsdWUgKyAnXCJdJztcbiAgICAgICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdcIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIic7XG4gICAgICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdbZGF0YS10ZXN0bmFtZT1cIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIl0nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuICAgICAgcm9vdCA9IFtyb290LCAwXTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCByb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IHJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICAgIHNlbGVjdG9ySW5kZXggPSByb290W2luZGV4KytdLFxuICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDUgIT09IHRhZyAmJiAyNiAhPT0gdGFnICYmIDI3ICE9PSB0YWcpIHx8XG4gICAgICAgICAgIWlzSGlkZGVuU3VidHJlZShmaWJlcilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yICg7IG51bGwgIT0gc2VsZWN0b3IgJiYgbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpOyApXG4gICAgICAgICAgICBzZWxlY3RvckluZGV4KyssIChzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XSk7XG4gICAgICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPT09IHNlbGVjdG9ycy5sZW5ndGgpIG1hdGNoaW5nRmliZXJzLnB1c2goZmliZXIpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgcm9vdC5wdXNoKGZpYmVyLCBzZWxlY3RvckluZGV4KSwgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGluZ0ZpYmVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICBob3N0Um9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gICAgICBob3N0Um9vdCA9IGZpbmRQYXRocyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIHNlbGVjdG9ycyA9IFtdO1xuICAgICAgaG9zdFJvb3QgPSBBcnJheS5mcm9tKGhvc3RSb290KTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBob3N0Um9vdC5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgbm9kZSA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICBpc0hpZGRlblN1YnRyZWUobm9kZSkgfHwgc2VsZWN0b3JzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKVxuICAgICAgICAgICAgaG9zdFJvb3QucHVzaChub2RlKSwgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdG9ycztcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Db21taXRSb290KCkge1xuICAgICAgc3VwcG9ydHNUZXN0U2VsZWN0b3JzICYmXG4gICAgICAgIGNvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdEhvb2spIHtcbiAgICAgICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSB7XG4gICAgICB2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVFxuICAgICAgICAgID8gSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgOiB2b2lkIDA7XG4gICAgICBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgfHxcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBjdXJyZW50IHRlc3RpbmcgZW52aXJvbm1lbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBhY3QoLi4uKVwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAgICAgaWYgKFxuICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiZcbiAgICAgICAgMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgLXdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgcmV0dXJuIG51bGwgIT09IHRyYW5zaXRpb25cbiAgICAgICAgPyAodHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyB8fCAodHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKSksXG4gICAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpLFxuICAgICAgICAgIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpKVxuICAgICAgICA6IHJlc29sdmVVcGRhdGVQcmlvcml0eSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0RGVmZXJyZWRMYW5lKCkge1xuICAgICAgaWYgKDAgPT09IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKVxuICAgICAgICBpZiAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZykge1xuICAgICAgICAgIHZhciBsYW5lID0gbmV4dFRyYW5zaXRpb25EZWZlcnJlZExhbmU7XG4gICAgICAgICAgbmV4dFRyYW5zaXRpb25EZWZlcnJlZExhbmUgPDw9IDE7XG4gICAgICAgICAgMCA9PT0gKG5leHRUcmFuc2l0aW9uRGVmZXJyZWRMYW5lICYgMzkzMjE2MCkgJiZcbiAgICAgICAgICAgIChuZXh0VHJhbnNpdGlvbkRlZmVycmVkTGFuZSA9IDI2MjE0NCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSBsYW5lO1xuICAgICAgICB9IGVsc2Ugd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSA1MzY4NzA5MTI7XG4gICAgICBsYW5lID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIG51bGwgIT09IGxhbmUgJiYgKGxhbmUuZmxhZ3MgfD0gMzIpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFwidXNlSW5zZXJ0aW9uRWZmZWN0IG11c3Qgbm90IHNjaGVkdWxlIHVwZGF0ZXMuXCIpO1xuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzICYmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITApO1xuICAgICAgaWYgKFxuICAgICAgICAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgfHxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkFjdGlvbikpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKSxcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgbGFuZSk7XG4gICAgICBpZiAoXG4gICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJlxuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNSZW5kZXJpbmcpXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICByb290ID1cbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykpIHx8XG4gICAgICAgICAgICAgICAgXCJVbmtub3duXCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5oYXMocm9vdCkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChyb290KSxcbiAgICAgICAgICAgICAgICAoZmliZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIiksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXJcIixcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSxcbiAgICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICAgICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9IGxhbmUpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgbGFuZXMsIGZvcmNlU3luYykge1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIik7XG4gICAgICBpZiAoMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiYgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIHlpZWxkZWRGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHlpZWxkRW5kVGltZSA9IG5vdyQxKCk7XG4gICAgICAgIHN3aXRjaCAoeWllbGRSZWFzb24pIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHlpZWxkU3RhcnRUaW1lO1xuICAgICAgICAgICAgc3VwcG9ydHNVc2VyVGltaW5nICYmXG4gICAgICAgICAgICAgICgoeWllbGRlZEZpYmVyID0geWllbGRlZEZpYmVyLl9kZWJ1Z1Rhc2spXG4gICAgICAgICAgICAgICAgPyB5aWVsZGVkRmliZXIucnVuKFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdXNwZW5kZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgeWllbGRFbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ29tcG9uZW50cyBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgIFwicHJpbWFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICAgICAgICBcIlN1c3BlbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkRW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBcInByaW1hcnktbGlnaHRcIlxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uQWN0aW9uOlxuICAgICAgICAgICAgc3RhcnRUaW1lID0geWllbGRTdGFydFRpbWU7XG4gICAgICAgICAgICBzdXBwb3J0c1VzZXJUaW1pbmcgJiZcbiAgICAgICAgICAgICAgKCh5aWVsZGVkRmliZXIgPSB5aWVsZGVkRmliZXIuX2RlYnVnVGFzaylcbiAgICAgICAgICAgICAgICA/IHlpZWxkZWRGaWJlci5ydW4oXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkFjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgICB5aWVsZEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgXCJDb21wb25lbnRzIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgXCJwcmltYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICAgIFwiQWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgeWllbGRFbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBcIkNvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIFwicHJpbWFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdXBwb3J0c1VzZXJUaW1pbmcgJiZcbiAgICAgICAgICAgICAgKCh5aWVsZGVkRmliZXIgPSB5aWVsZEVuZFRpbWUgLSB5aWVsZFN0YXJ0VGltZSksXG4gICAgICAgICAgICAgIDMgPiB5aWVsZGVkRmliZXIgfHxcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgIFwiQmxvY2tlZFwiLFxuICAgICAgICAgICAgICAgICAgeWllbGRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICB5aWVsZEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICBcIkNvbXBvbmVudHMgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgNSA+IHlpZWxkZWRGaWJlclxuICAgICAgICAgICAgICAgICAgICA/IFwicHJpbWFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDogMTAgPiB5aWVsZGVkRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IFwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgOiAxMDAgPiB5aWVsZGVkRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJwcmltYXJ5LWRhcmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImVycm9yXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhcnRUaW1lID0gKGZvcmNlU3luYyA9XG4gICAgICAgICghZm9yY2VTeW5jICYmXG4gICAgICAgICAgMCA9PT0gKGxhbmVzICYgMTI3KSAmJlxuICAgICAgICAgIDAgPT09IChsYW5lcyAmIHJvb3QuZXhwaXJlZExhbmVzKSkgfHxcbiAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBsYW5lcykpXG4gICAgICAgID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpXG4gICAgICAgIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsICEwKTtcbiAgICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gZm9yY2VTeW5jO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAhZm9yY2VTeW5jICYmXG4gICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgMCwgITEpO1xuICAgICAgICAgIGxhbmVzID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb247XG4gICAgICAgICAgeWllbGRTdGFydFRpbWUgPSBub3coKTtcbiAgICAgICAgICB5aWVsZFJlYXNvbiA9IGxhbmVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkZWRGaWJlciA9IG5vdyQxKCk7XG4gICAgICAgICAgeWllbGRFbmRUaW1lID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICAgICAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKHlpZWxkRW5kVGltZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUcmFja0Zyb21MYW5lcyhsYW5lcyk7XG4gICAgICAgICAgICB5aWVsZEVuZFRpbWUgPSByZW5kZXJTdGFydFRpbWU7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSB5aWVsZGVkRmliZXI7XG4gICAgICAgICAgICAhc3VwcG9ydHNVc2VyVGltaW5nIHx8XG4gICAgICAgICAgICAgIHN0YXJ0VGltZSA8PSB5aWVsZEVuZFRpbWUgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVXBkYXRlVGFza1xuICAgICAgICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGVhcmVkIFJlbmRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgIHlpZWxkRW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICAgIFwiVGVhcmVkIFJlbmRlclwiLFxuICAgICAgICAgICAgICAgICAgICB5aWVsZEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBmaW5hbGl6ZVJlbmRlcihsYW5lcywgeWllbGRlZEZpYmVyKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCAhMSk7XG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChyb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IDA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIChlcnJvclJldHJ5TGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIC01MzY4NzA5MTMpLFxuICAgICAgICAgICAgICAgIChlcnJvclJldHJ5TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgMCAhPT0gZXJyb3JSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICAgICAgIDogZXJyb3JSZXRyeUxhbmVzICYgNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICAgICAgPyA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAgICAgaWYgKDAgIT09IGVycm9yUmV0cnlMYW5lcykge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50VHJhY2tGcm9tTGFuZXMobGFuZXMpO1xuICAgICAgICAgICAgICBsb2dFcnJvcmVkUmVuZGVyUGhhc2UoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHlpZWxkZWRGaWJlcixcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1VwZGF0ZVRhc2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmluYWxpemVSZW5kZXIobGFuZXMsIHlpZWxkZWRGaWJlcik7XG4gICAgICAgICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgeWllbGRlZEZpYmVyID0gcm9vdDtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICAgICAgICAgICAgICAgIHZhciB3YXNSb290RGVoeWRyYXRlZCA9XG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgeWllbGRlZEZpYmVyLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG4gICAgICAgICAgICAgICAgd2FzUm9vdERlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVwYXJlRnJlc2hTdGFjayh5aWVsZGVkRmliZXIsIGVycm9yUmV0cnlMYW5lcykuZmxhZ3MgfD1cbiAgICAgICAgICAgICAgICAgICAgMjU2KTtcbiAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMgPSByZW5kZXJSb290U3luYyhcbiAgICAgICAgICAgICAgICAgIHlpZWxkZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdhc1Jvb3REZWh5ZHJhdGVkXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGRlZEZpYmVyLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIHw9IHN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgeWllbGRlZEZpYmVyID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IHJlbmRlcldhc0NvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB5aWVsZGVkRmliZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB5aWVsZGVkRmliZXIpXG4gICAgICAgICAgICAgICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGRlZEZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPT0gUm9vdEVycm9yZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBlbHNlIHlpZWxkZWRGaWJlciA9IG5vdyQxKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydFRpbWUgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUcmFja0Zyb21MYW5lcyhsYW5lcyk7XG4gICAgICAgICAgICBsb2dFcnJvcmVkUmVuZGVyUGhhc2UoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgeWllbGRlZEZpYmVyLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluYWxpemVSZW5kZXIobGFuZXMsIHlpZWxkZWRGaWJlcik7XG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKTtcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgZm9yY2VTeW5jID0gcm9vdDtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEluUHJvZ3Jlc3M6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcbiAgICAgICAgICAgICAgICBpZiAoKGxhbmVzICYgNDE5NDA0OCkgIT09IGxhbmVzKSBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBSb290U3VzcGVuZGVkQXRUaGVTaGVsbDpcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHJhY2tGcm9tTGFuZXMobGFuZXMpO1xuICAgICAgICAgICAgICAgIGxvZ1N1c3BlbmRlZFJlbmRlclBoYXNlKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgeWllbGRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1VwZGF0ZVRhc2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpbmFsaXplUmVuZGVyKGxhbmVzLCB5aWVsZGVkRmliZXIpO1xuICAgICAgICAgICAgICAgIHlpZWxkRW5kVGltZSA9IGxhbmVzO1xuICAgICAgICAgICAgICAgIDAgIT09ICh5aWVsZEVuZFRpbWUgJiAxMjcpXG4gICAgICAgICAgICAgICAgICA/IChibG9ja2luZ1N1c3BlbmRlZFRpbWUgPSB5aWVsZGVkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IDAgIT09ICh5aWVsZEVuZFRpbWUgJiA0MTk0MDQ4KSAmJlxuICAgICAgICAgICAgICAgICAgICAodHJhbnNpdGlvblN1c3BlbmRlZFRpbWUgPSB5aWVsZGVkRmliZXIpO1xuICAgICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUpXG4gICAgICAgICAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgIHlpZWxkRW5kVGltZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHlpZWxkZWRGaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobGFuZXMgJiA2MjkxNDU2MCkgPT09IGxhbmVzICYmXG4gICAgICAgICAgICAgICAgKChyZW5kZXJXYXNDb25jdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgK1xuICAgICAgICAgICAgICAgICAgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLVxuICAgICAgICAgICAgICAgICAgbm93JDEoKSksXG4gICAgICAgICAgICAgICAgMTAgPCByZW5kZXJXYXNDb25jdXJyZW50KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gZ2V0TmV4dExhbmVzKGZvcmNlU3luYywgMCwgITApKSBicmVhayBhO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdFZmZlY3RzTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICAgICAgICBmb3JjZVN5bmMudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChcbiAgICAgICAgICAgICAgICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkuYmluZChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgICAgICB5aWVsZEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBcIlRocm90dGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkZWRGaWJlclxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgICAgeWllbGRFbmRUaW1lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICB5aWVsZGVkRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IHdoaWxlICgxKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgbGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICBleGl0U3RhdHVzLFxuICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICkge1xuICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgdmFyIHN1YnRyZWVGbGFncyA9IGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MsXG4gICAgICAgIHN1c3BlbmRlZFN0YXRlID0gbnVsbDtcbiAgICAgIGlmIChzdWJ0cmVlRmxhZ3MgJiA4MTkyIHx8IDE2Nzg1NDA4ID09PSAoc3VidHJlZUZsYWdzICYgMTY3ODU0MDgpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChzdXNwZW5kZWRTdGF0ZSA9IHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpKSxcbiAgICAgICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmssIGxhbmVzLCBzdXNwZW5kZWRTdGF0ZSksXG4gICAgICAgICAgKHN1YnRyZWVGbGFncyA9XG4gICAgICAgICAgICAobGFuZXMgJiA2MjkxNDU2MCkgPT09IGxhbmVzXG4gICAgICAgICAgICAgID8gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSAtIG5vdyQxKClcbiAgICAgICAgICAgICAgOiAobGFuZXMgJiA0MTk0MDQ4KSA9PT0gbGFuZXNcbiAgICAgICAgICAgICAgICA/IGdsb2JhbE1vc3RSZWNlbnRUcmFuc2l0aW9uVGltZSAtIG5vdyQxKClcbiAgICAgICAgICAgICAgICA6IDApLFxuICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgPSB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KHN1c3BlbmRlZFN0YXRlLCBzdWJ0cmVlRmxhZ3MpKSxcbiAgICAgICAgICBudWxsICE9PSBzdWJ0cmVlRmxhZ3MpXG4gICAgICAgICkge1xuICAgICAgICAgIHBlbmRpbmdFZmZlY3RzTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBzdWJ0cmVlRmxhZ3MoXG4gICAgICAgICAgICBjb21taXRSb290LmJpbmQoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICBleGl0U3RhdHVzLFxuICAgICAgICAgICAgICBzdXNwZW5kZWRTdGF0ZSxcbiAgICAgICAgICAgICAgZ2V0U3VzcGVuZGVkQ29tbWl0UmVhc29uKHN1c3BlbmRlZFN0YXRlLCByb290LmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICAhZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgbGFuZXMsXG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICBleGl0U3RhdHVzLFxuICAgICAgICBzdXNwZW5kZWRTdGF0ZSxcbiAgICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7IDsgKSB7XG4gICAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgwID09PSB0YWcgfHwgMTEgPT09IHRhZyB8fCAxNSA9PT0gdGFnKSAmJlxuICAgICAgICAgIG5vZGUuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgICAgICgodGFnID0gbm9kZS51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gdGFnICYmICgodGFnID0gdGFnLnN0b3JlcyksIG51bGwgIT09IHRhZykpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gdGFnW2ldLFxuICAgICAgICAgICAgICBnZXRTbmFwc2hvdCA9IGNoZWNrLmdldFNuYXBzaG90O1xuICAgICAgICAgICAgY2hlY2sgPSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghb2JqZWN0SXMoZ2V0U25hcHNob3QoKSwgY2hlY2spKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB0YWcgPSBub2RlLmNoaWxkO1xuICAgICAgICBpZiAobm9kZS5zdWJ0cmVlRmxhZ3MgJiAxNjM4NCAmJiBudWxsICE9PSB0YWcpXG4gICAgICAgICAgKHRhZy5yZXR1cm4gPSBub2RlKSwgKG5vZGUgPSB0YWcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSByZXR1cm4gITA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgcm9vdCxcbiAgICAgIHN1c3BlbmRlZExhbmVzLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVxuICAgICkge1xuICAgICAgc3VzcGVuZGVkTGFuZXMgJj0gfndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzO1xuICAgICAgc3VzcGVuZGVkTGFuZXMgJj0gfndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgJj0gfnN1c3BlbmRlZExhbmVzO1xuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgJiYgKHJvb3Qud2FybUxhbmVzIHw9IHN1c3BlbmRlZExhbmVzKTtcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gICAgICBmb3IgKHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzOyAwIDwgbGFuZXM7ICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWVbaW5kZXhdID0gLTE7XG4gICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgICAgMCAhPT0gc3Bhd25lZExhbmUgJiZcbiAgICAgICAgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIHN1c3BlbmRlZExhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jV29yaygpIHtcbiAgICAgIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHRcbiAgICAgICAgPyAoZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpLCAhMSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCkge1xuICAgICAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCkge1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gTm90U3VzcGVuZGVkKVxuICAgICAgICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCksXG4gICAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQoaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlJDEgPSBudWxsKSxcbiAgICAgICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCksXG4gICAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gaW50ZXJydXB0ZWRXb3JrOyApXG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yay5hbHRlcm5hdGUsIGludGVycnVwdGVkV29yayksXG4gICAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybik7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluYWxpemVSZW5kZXIobGFuZXMsIGZpbmFsaXphdGlvblRpbWUpIHtcbiAgICAgIDAgIT09IChsYW5lcyAmIDEyNykgJiYgKGJsb2NraW5nQ2xhbXBUaW1lID0gZmluYWxpemF0aW9uVGltZSk7XG4gICAgICAwICE9PSAobGFuZXMgJiA0MTk0MDQ4KSAmJiAodHJhbnNpdGlvbkNsYW1wVGltZSA9IGZpbmFsaXphdGlvblRpbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICAgICAgc3VwcG9ydHNVc2VyVGltaW5nICYmXG4gICAgICAgIChjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICBcIkJsb2NraW5nIFRyYWNrXCIsXG4gICAgICAgICAgMC4wMDMsXG4gICAgICAgICAgMC4wMDMsXG4gICAgICAgICAgXCJCbG9ja2luZ1wiLFxuICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICBcInByaW1hcnktbGlnaHRcIlxuICAgICAgICApLFxuICAgICAgICBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICBcIlRyYW5zaXRpb24gVHJhY2tcIixcbiAgICAgICAgICAwLjAwMyxcbiAgICAgICAgICAwLjAwMyxcbiAgICAgICAgICBcIlRyYW5zaXRpb25cIixcbiAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgXCJwcmltYXJ5LWxpZ2h0XCJcbiAgICAgICAgKSxcbiAgICAgICAgY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgXCJTdXNwZW5zZSBUcmFja1wiLFxuICAgICAgICAgIDAuMDAzLFxuICAgICAgICAgIDAuMDAzLFxuICAgICAgICAgIFwiU3VzcGVuc2VcIixcbiAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgXCJwcmltYXJ5LWxpZ2h0XCJcbiAgICAgICAgKSxcbiAgICAgICAgY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgXCJJZGxlIFRyYWNrXCIsXG4gICAgICAgICAgMC4wMDMsXG4gICAgICAgICAgMC4wMDMsXG4gICAgICAgICAgXCJJZGxlXCIsXG4gICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgIFwicHJpbWFyeS1saWdodFwiXG4gICAgICAgICkpO1xuICAgICAgdmFyIHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID0gcmVuZGVyU3RhcnRUaW1lO1xuICAgICAgcmVuZGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICBpZiAoMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiYgMCA8IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHNldEN1cnJlbnRUcmFja0Zyb21MYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkIHx8XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheVxuICAgICAgICApXG4gICAgICAgICAgbG9nU3VzcGVuZGVkUmVuZGVyUGhhc2UoXG4gICAgICAgICAgICBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZFRpbWUgPSByZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICBkZWJ1Z1Rhc2sgPSB3b3JrSW5Qcm9ncmVzc1VwZGF0ZVRhc2s7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhKGVuZFRpbWUgPD0gcHJldmlvdXNSZW5kZXJTdGFydFRpbWUpKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPVxuICAgICAgICAgICAgICAgIChsYW5lcyAmIDczODE5NzY1MykgPT09IGxhbmVzXG4gICAgICAgICAgICAgICAgICA/IFwidGVydGlhcnktZGFya1wiXG4gICAgICAgICAgICAgICAgICA6IFwicHJpbWFyeS1kYXJrXCIsXG4gICAgICAgICAgICAgIGxhYmVsID1cbiAgICAgICAgICAgICAgICAobGFuZXMgJiA1MzY4NzA5MTIpID09PSBsYW5lc1xuICAgICAgICAgICAgICAgICAgPyBcIlByZXdhcm1cIlxuICAgICAgICAgICAgICAgICAgOiAobGFuZXMgJiAyMDEzMjY3NDEpID09PSBsYW5lc1xuICAgICAgICAgICAgICAgICAgICA/IFwiSW50ZXJydXB0ZWQgSHlkcmF0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIkludGVycnVwdGVkIFJlbmRlclwiO1xuICAgICAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICBjb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsaXplUmVuZGVyKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCByZW5kZXJTdGFydFRpbWUpO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPSB3b3JrSW5Qcm9ncmVzc1VwZGF0ZVRhc2s7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1VwZGF0ZVRhc2sgPSBudWxsO1xuICAgICAgaWYgKDAgIT09IChsYW5lcyAmIDEyNykpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrID0gYmxvY2tpbmdVcGRhdGVUYXNrO1xuICAgICAgICBkZWJ1Z1Rhc2sgPVxuICAgICAgICAgIDAgPD0gYmxvY2tpbmdVcGRhdGVUaW1lICYmIGJsb2NraW5nVXBkYXRlVGltZSA8IGJsb2NraW5nQ2xhbXBUaW1lXG4gICAgICAgICAgICA/IGJsb2NraW5nQ2xhbXBUaW1lXG4gICAgICAgICAgICA6IGJsb2NraW5nVXBkYXRlVGltZTtcbiAgICAgICAgZW5kVGltZSA9XG4gICAgICAgICAgMCA8PSBibG9ja2luZ0V2ZW50VGltZSAmJiBibG9ja2luZ0V2ZW50VGltZSA8IGJsb2NraW5nQ2xhbXBUaW1lXG4gICAgICAgICAgICA/IGJsb2NraW5nQ2xhbXBUaW1lXG4gICAgICAgICAgICA6IGJsb2NraW5nRXZlbnRUaW1lO1xuICAgICAgICBjb2xvciA9XG4gICAgICAgICAgMCA8PSBlbmRUaW1lID8gZW5kVGltZSA6IDAgPD0gZGVidWdUYXNrID8gZGVidWdUYXNrIDogcmVuZGVyU3RhcnRUaW1lO1xuICAgICAgICAwIDw9IGJsb2NraW5nU3VzcGVuZGVkVGltZSAmJlxuICAgICAgICAgIChzZXRDdXJyZW50VHJhY2tGcm9tTGFuZXMoMiksXG4gICAgICAgICAgbG9nU3VzcGVuZGVkV2l0aERlbGF5UGhhc2UoXG4gICAgICAgICAgICBibG9ja2luZ1N1c3BlbmRlZFRpbWUsXG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWVcbiAgICAgICAgICApKTtcbiAgICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPSBkZWJ1Z1Rhc2s7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSBlbmRUaW1lLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IGJsb2NraW5nRXZlbnRUeXBlLFxuICAgICAgICAgIGV2ZW50SXNSZXBlYXQgPSAwIDwgYmxvY2tpbmdFdmVudFJlcGVhdFRpbWUsXG4gICAgICAgICAgaXNTcGF3bmVkVXBkYXRlID0gMSA9PT0gYmxvY2tpbmdVcGRhdGVUeXBlLFxuICAgICAgICAgIGlzUGluZ2VkVXBkYXRlID0gMiA9PT0gYmxvY2tpbmdVcGRhdGVUeXBlO1xuICAgICAgICBkZWJ1Z1Rhc2sgPSByZW5kZXJTdGFydFRpbWU7XG4gICAgICAgIGVuZFRpbWUgPSBibG9ja2luZ1VwZGF0ZVRhc2s7XG4gICAgICAgIGNvbG9yID0gYmxvY2tpbmdVcGRhdGVNZXRob2ROYW1lO1xuICAgICAgICBsYWJlbCA9IGJsb2NraW5nVXBkYXRlQ29tcG9uZW50TmFtZTtcbiAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgICAgIGN1cnJlbnRUcmFjayA9IFwiQmxvY2tpbmdcIjtcbiAgICAgICAgICAwIDwgcHJldmlvdXNSZW5kZXJTdGFydFRpbWVcbiAgICAgICAgICAgID8gcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPiBkZWJ1Z1Rhc2sgJiZcbiAgICAgICAgICAgICAgKHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID0gZGVidWdUYXNrKVxuICAgICAgICAgICAgOiAocHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPSBkZWJ1Z1Rhc2spO1xuICAgICAgICAgIDAgPCBldmVudFRpbWVcbiAgICAgICAgICAgID8gZXZlbnRUaW1lID4gcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgKGV2ZW50VGltZSA9IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lKVxuICAgICAgICAgICAgOiAoZXZlbnRUaW1lID0gcHJldmlvdXNSZW5kZXJTdGFydFRpbWUpO1xuICAgICAgICAgIGlmIChudWxsICE9PSBldmVudFR5cGUgJiYgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPiBldmVudFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciRqc2NvbXAkMCA9IGV2ZW50SXNSZXBlYXQgPyBcInNlY29uZGFyeS1saWdodFwiIDogXCJ3YXJuaW5nXCI7XG4gICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgICAgID8gZW5kVGltZS5ydW4oXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgICAgICBldmVudElzUmVwZWF0ID8gXCJDb25zZWN1dGl2ZVwiIDogXCJFdmVudDogXCIgKyBldmVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGltZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgIGV2ZW50SXNSZXBlYXQgPyBcIkNvbnNlY3V0aXZlXCIgOiBcIkV2ZW50OiBcIiArIGV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50VGltZSxcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgY29sb3IkanNjb21wJDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1Z1Rhc2sgPiBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSAmJlxuICAgICAgICAgICAgKChldmVudFRpbWUgPSBpc1NwYXduZWRVcGRhdGVcbiAgICAgICAgICAgICAgPyBcImVycm9yXCJcbiAgICAgICAgICAgICAgOiAobGFuZXMgJiA3MzgxOTc2NTMpID09PSBsYW5lc1xuICAgICAgICAgICAgICAgID8gXCJ0ZXJ0aWFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgOiBcInByaW1hcnktbGlnaHRcIiksXG4gICAgICAgICAgICAoaXNTcGF3bmVkVXBkYXRlID0gaXNQaW5nZWRVcGRhdGVcbiAgICAgICAgICAgICAgPyBcIlByb21pc2UgUmVzb2x2ZWRcIlxuICAgICAgICAgICAgICA6IGlzU3Bhd25lZFVwZGF0ZVxuICAgICAgICAgICAgICAgID8gXCJDYXNjYWRpbmcgVXBkYXRlXCJcbiAgICAgICAgICAgICAgICA6IDUgPCBkZWJ1Z1Rhc2sgLSBwcmV2aW91c1JlbmRlclN0YXJ0VGltZVxuICAgICAgICAgICAgICAgICAgPyBcIlVwZGF0ZSBCbG9ja2VkXCJcbiAgICAgICAgICAgICAgICAgIDogXCJVcGRhdGVcIiksXG4gICAgICAgICAgICAoaXNQaW5nZWRVcGRhdGUgPSBbXSksXG4gICAgICAgICAgICBudWxsICE9IGxhYmVsICYmIGlzUGluZ2VkVXBkYXRlLnB1c2goW1wiQ29tcG9uZW50IG5hbWVcIiwgbGFiZWxdKSxcbiAgICAgICAgICAgIG51bGwgIT0gY29sb3IgJiYgaXNQaW5nZWRVcGRhdGUucHVzaChbXCJNZXRob2QgbmFtZVwiLCBjb2xvcl0pLFxuICAgICAgICAgICAgKHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID0ge1xuICAgICAgICAgICAgICBzdGFydDogcHJldmlvdXNSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZDogZGVidWdUYXNrLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogaXNQaW5nZWRVcGRhdGUsXG4gICAgICAgICAgICAgICAgICB0cmFjazogY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgdHJhY2tHcm91cDogXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGV2ZW50VGltZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlbmRUaW1lXG4gICAgICAgICAgICAgID8gZW5kVGltZS5ydW4oXG4gICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICAgICAgICAgICAgICBpc1NwYXduZWRVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHBlcmZvcm1hbmNlLm1lYXN1cmUoaXNTcGF3bmVkVXBkYXRlLCBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSkpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NraW5nVXBkYXRlVGltZSA9IC0xLjE7XG4gICAgICAgIGJsb2NraW5nVXBkYXRlVHlwZSA9IDA7XG4gICAgICAgIGJsb2NraW5nVXBkYXRlQ29tcG9uZW50TmFtZSA9IGJsb2NraW5nVXBkYXRlTWV0aG9kTmFtZSA9IG51bGw7XG4gICAgICAgIGJsb2NraW5nU3VzcGVuZGVkVGltZSA9IC0xLjE7XG4gICAgICAgIGJsb2NraW5nRXZlbnRSZXBlYXRUaW1lID0gYmxvY2tpbmdFdmVudFRpbWU7XG4gICAgICAgIGJsb2NraW5nRXZlbnRUaW1lID0gLTEuMTtcbiAgICAgICAgYmxvY2tpbmdDbGFtcFRpbWUgPSBub3coKTtcbiAgICAgIH1cbiAgICAgIDAgIT09IChsYW5lcyAmIDQxOTQwNDgpICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrID0gdHJhbnNpdGlvblVwZGF0ZVRhc2spLFxuICAgICAgICAoZGVidWdUYXNrID1cbiAgICAgICAgICAwIDw9IHRyYW5zaXRpb25TdGFydFRpbWUgJiYgdHJhbnNpdGlvblN0YXJ0VGltZSA8IHRyYW5zaXRpb25DbGFtcFRpbWVcbiAgICAgICAgICAgID8gdHJhbnNpdGlvbkNsYW1wVGltZVxuICAgICAgICAgICAgOiB0cmFuc2l0aW9uU3RhcnRUaW1lKSxcbiAgICAgICAgKHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID1cbiAgICAgICAgICAwIDw9IHRyYW5zaXRpb25VcGRhdGVUaW1lICYmXG4gICAgICAgICAgdHJhbnNpdGlvblVwZGF0ZVRpbWUgPCB0cmFuc2l0aW9uQ2xhbXBUaW1lXG4gICAgICAgICAgICA/IHRyYW5zaXRpb25DbGFtcFRpbWVcbiAgICAgICAgICAgIDogdHJhbnNpdGlvblVwZGF0ZVRpbWUpLFxuICAgICAgICAoZW5kVGltZSA9XG4gICAgICAgICAgMCA8PSB0cmFuc2l0aW9uRXZlbnRUaW1lICYmIHRyYW5zaXRpb25FdmVudFRpbWUgPCB0cmFuc2l0aW9uQ2xhbXBUaW1lXG4gICAgICAgICAgICA/IHRyYW5zaXRpb25DbGFtcFRpbWVcbiAgICAgICAgICAgIDogdHJhbnNpdGlvbkV2ZW50VGltZSksXG4gICAgICAgIChjb2xvciA9XG4gICAgICAgICAgMCA8PSBlbmRUaW1lXG4gICAgICAgICAgICA/IGVuZFRpbWVcbiAgICAgICAgICAgIDogMCA8PSBwcmV2aW91c1JlbmRlclN0YXJ0VGltZVxuICAgICAgICAgICAgICA/IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lXG4gICAgICAgICAgICAgIDogcmVuZGVyU3RhcnRUaW1lKSxcbiAgICAgICAgMCA8PSB0cmFuc2l0aW9uU3VzcGVuZGVkVGltZSAmJlxuICAgICAgICAgIChzZXRDdXJyZW50VHJhY2tGcm9tTGFuZXMoMjU2KSxcbiAgICAgICAgICBsb2dTdXNwZW5kZWRXaXRoRGVsYXlQaGFzZShcbiAgICAgICAgICAgIHRyYW5zaXRpb25TdXNwZW5kZWRUaW1lLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVXBkYXRlVGFza1xuICAgICAgICAgICkpLFxuICAgICAgICAoaXNQaW5nZWRVcGRhdGUgPSBlbmRUaW1lKSxcbiAgICAgICAgKGV2ZW50VGltZSA9IHRyYW5zaXRpb25FdmVudFR5cGUpLFxuICAgICAgICAoZXZlbnRUeXBlID0gMCA8IHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUpLFxuICAgICAgICAoZXZlbnRJc1JlcGVhdCA9IDIgPT09IHRyYW5zaXRpb25VcGRhdGVUeXBlKSxcbiAgICAgICAgKGNvbG9yID0gcmVuZGVyU3RhcnRUaW1lKSxcbiAgICAgICAgKGVuZFRpbWUgPSB0cmFuc2l0aW9uVXBkYXRlVGFzayksXG4gICAgICAgIChsYWJlbCA9IHRyYW5zaXRpb25VcGRhdGVNZXRob2ROYW1lKSxcbiAgICAgICAgKGlzU3Bhd25lZFVwZGF0ZSA9IHRyYW5zaXRpb25VcGRhdGVDb21wb25lbnROYW1lKSxcbiAgICAgICAgc3VwcG9ydHNVc2VyVGltaW5nICYmXG4gICAgICAgICAgKChjdXJyZW50VHJhY2sgPSBcIlRyYW5zaXRpb25cIiksXG4gICAgICAgICAgMCA8IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lXG4gICAgICAgICAgICA/IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID4gY29sb3IgJiZcbiAgICAgICAgICAgICAgKHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID0gY29sb3IpXG4gICAgICAgICAgICA6IChwcmV2aW91c1JlbmRlclN0YXJ0VGltZSA9IGNvbG9yKSxcbiAgICAgICAgICAwIDwgZGVidWdUYXNrXG4gICAgICAgICAgICA/IGRlYnVnVGFzayA+IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgIChkZWJ1Z1Rhc2sgPSBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSlcbiAgICAgICAgICAgIDogKGRlYnVnVGFzayA9IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lKSxcbiAgICAgICAgICAwIDwgaXNQaW5nZWRVcGRhdGVcbiAgICAgICAgICAgID8gaXNQaW5nZWRVcGRhdGUgPiBkZWJ1Z1Rhc2sgJiYgKGlzUGluZ2VkVXBkYXRlID0gZGVidWdUYXNrKVxuICAgICAgICAgICAgOiAoaXNQaW5nZWRVcGRhdGUgPSBkZWJ1Z1Rhc2spLFxuICAgICAgICAgIGRlYnVnVGFzayA+IGlzUGluZ2VkVXBkYXRlICYmXG4gICAgICAgICAgICBudWxsICE9PSBldmVudFRpbWUgJiZcbiAgICAgICAgICAgICgoY29sb3IkanNjb21wJDAgPSBldmVudFR5cGUgPyBcInNlY29uZGFyeS1saWdodFwiIDogXCJ3YXJuaW5nXCIpLFxuICAgICAgICAgICAgZW5kVGltZVxuICAgICAgICAgICAgICA/IGVuZFRpbWUucnVuKFxuICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID8gXCJDb25zZWN1dGl2ZVwiIDogXCJFdmVudDogXCIgKyBldmVudFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGlzUGluZ2VkVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2ssXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA/IFwiQ29uc2VjdXRpdmVcIiA6IFwiRXZlbnQ6IFwiICsgZXZlbnRUaW1lLFxuICAgICAgICAgICAgICAgICAgaXNQaW5nZWRVcGRhdGUsXG4gICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2ssXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICBjb2xvciRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgIHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lID4gZGVidWdUYXNrICYmXG4gICAgICAgICAgICAoZW5kVGltZVxuICAgICAgICAgICAgICA/IGVuZFRpbWUucnVuKFxuICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgXCJBY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJpbWFyeS1kYXJrXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICBcIkFjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgZGVidWdUYXNrLFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICBcInByaW1hcnktZGFya1wiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgY29sb3IgPiBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSAmJlxuICAgICAgICAgICAgKChkZWJ1Z1Rhc2sgPSBldmVudElzUmVwZWF0XG4gICAgICAgICAgICAgID8gXCJQcm9taXNlIFJlc29sdmVkXCJcbiAgICAgICAgICAgICAgOiA1IDwgY29sb3IgLSBwcmV2aW91c1JlbmRlclN0YXJ0VGltZVxuICAgICAgICAgICAgICAgID8gXCJVcGRhdGUgQmxvY2tlZFwiXG4gICAgICAgICAgICAgICAgOiBcIlVwZGF0ZVwiKSxcbiAgICAgICAgICAgIChpc1BpbmdlZFVwZGF0ZSA9IFtdKSxcbiAgICAgICAgICAgIG51bGwgIT0gaXNTcGF3bmVkVXBkYXRlICYmXG4gICAgICAgICAgICAgIGlzUGluZ2VkVXBkYXRlLnB1c2goW1wiQ29tcG9uZW50IG5hbWVcIiwgaXNTcGF3bmVkVXBkYXRlXSksXG4gICAgICAgICAgICBudWxsICE9IGxhYmVsICYmIGlzUGluZ2VkVXBkYXRlLnB1c2goW1wiTWV0aG9kIG5hbWVcIiwgbGFiZWxdKSxcbiAgICAgICAgICAgIChwcmV2aW91c1JlbmRlclN0YXJ0VGltZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlbmQ6IGNvbG9yLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogaXNQaW5nZWRVcGRhdGUsXG4gICAgICAgICAgICAgICAgICB0cmFjazogY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgdHJhY2tHcm91cDogXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IFwicHJpbWFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgICAgICAgPyBlbmRUaW1lLnJ1bihcbiAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUuYmluZChcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcGVyZm9ybWFuY2UubWVhc3VyZShkZWJ1Z1Rhc2ssIHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lKSkpLFxuICAgICAgICAodHJhbnNpdGlvblVwZGF0ZVRpbWUgPSB0cmFuc2l0aW9uU3RhcnRUaW1lID0gLTEuMSksXG4gICAgICAgICh0cmFuc2l0aW9uVXBkYXRlVHlwZSA9IDApLFxuICAgICAgICAodHJhbnNpdGlvblN1c3BlbmRlZFRpbWUgPSAtMS4xKSxcbiAgICAgICAgKHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUgPSB0cmFuc2l0aW9uRXZlbnRUaW1lKSxcbiAgICAgICAgKHRyYW5zaXRpb25FdmVudFRpbWUgPSAtMS4xKSxcbiAgICAgICAgKHRyYW5zaXRpb25DbGFtcFRpbWUgPSBub3coKSkpO1xuICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPSByb290LnRpbWVvdXRIYW5kbGU7XG4gICAgICBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSAhPT0gbm9UaW1lb3V0ICYmXG4gICAgICAgICgocm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0KSxcbiAgICAgICAgY2FuY2VsVGltZW91dChwcmV2aW91c1JlbmRlclN0YXJ0VGltZSkpO1xuICAgICAgcHJldmlvdXNSZW5kZXJTdGFydFRpbWUgPSByb290LmNhbmNlbFBlbmRpbmdDb21taXQ7XG4gICAgICBudWxsICE9PSBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSAmJlxuICAgICAgICAoKHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGwpLCBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSgpKTtcbiAgICAgIHBlbmRpbmdFZmZlY3RzTGFuZXMgPSAwO1xuICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBwcmV2aW91c1JlbmRlclN0YXJ0VGltZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKFxuICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID1cbiAgICAgICAgbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMTtcbiAgICAgIDAgIT09IChsYW5lcyAmIDgpICYmIChsYW5lcyB8PSBsYW5lcyAmIDMyKTtcbiAgICAgIGVuZFRpbWUgPSByb290LmVudGFuZ2xlZExhbmVzO1xuICAgICAgaWYgKDAgIT09IGVuZFRpbWUpXG4gICAgICAgIGZvciAocm9vdCA9IHJvb3QuZW50YW5nbGVtZW50cywgZW5kVGltZSAmPSBsYW5lczsgMCA8IGVuZFRpbWU7IClcbiAgICAgICAgICAoZGVidWdUYXNrID0gMzEgLSBjbHozMihlbmRUaW1lKSksXG4gICAgICAgICAgICAoY29sb3IgPSAxIDw8IGRlYnVnVGFzayksXG4gICAgICAgICAgICAobGFuZXMgfD0gcm9vdFtkZWJ1Z1Rhc2tdKSxcbiAgICAgICAgICAgIChlbmRUaW1lICY9IH5jb2xvcik7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICAgICAgcm9vdCA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICAxZTMgPCByb290IC0gbGFzdFJlc2V0VGltZSAmJlxuICAgICAgICAoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzID0gMCksXG4gICAgICAgIChsYXN0UmVzZXRUaW1lID0gcm9vdCkpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICAgICAgcmV0dXJuIHByZXZpb3VzUmVuZGVyU3RhcnRUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHxcbiAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUFjdGlvbkV4Y2VwdGlvblxuICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkltbWVkaWF0ZSkpXG4gICAgICAgIDogdGhyb3duVmFsdWUgPT09IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvblxuICAgICAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbnN0YW5jZSkpXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBTdXNwZW5kZWRPbkh5ZHJhdGlvblxuICAgICAgICAgICAgICAgIDogbnVsbCAhPT0gdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHRocm93blZhbHVlLnRoZW5cbiAgICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgICA6IFN1c3BlbmRlZE9uRXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICAgICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBudWxsID09PSBlcnJvcmVkV29ya1xuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQpLFxuICAgICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgICApKVxuICAgICAgICA6IGVycm9yZWRXb3JrLm1vZGUgJiAyICYmXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbihlcnJvcmVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gaGFuZGxlclxuICAgICAgICA/ICEwXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDA0OCkgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgID8gbnVsbCA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgPyAhMFxuICAgICAgICAgICAgOiAhMVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIHx8XG4gICAgICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgICAgID8gaGFuZGxlciA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIHJldHVybiBudWxsID09PSBwcmV2RGlzcGF0Y2hlciA/IENvbnRleHRPbmx5RGlzcGF0Y2hlciA6IHByZXZEaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQXN5bmNEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IERlZmF1bHRBc3luY0Rpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlbmRlckRlcml2ZWRDYXVzZShmaWJlcikge1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1VwZGF0ZVRhc2sgPVxuICAgICAgICAgIG51bGwgPT0gZmliZXIuX2RlYnVnVGFzayA/IG51bGwgOiBmaWJlci5fZGVidWdUYXNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIHx8XG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA0MTk0MDQ4KSAhPT1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpIHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICEwKTtcbiAgICAgICgwID09PSAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzICYgMTM0MjE3NzI3KSAmJlxuICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgJiAxMzQyMTc3MjcpKSB8fFxuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgfHxcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZykge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbWVtb2l6ZWRVcGRhdGVycy5zaXplICYmXG4gICAgICAgICAgICAocmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCkpO1xuICAgICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICAgIGxhbmVzID0gITE7XG4gICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdFN1c3BlbmRlZEF0VGhlU2hlbGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25BY3Rpb246XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAgICAgIG51bGwgPT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQgJiYgKGxhbmVzID0gITApO1xuICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbjtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IFJvb3RJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDQpIHtcbiAgICAgICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQ0KTtcbiAgICAgICAgfVxuICAgICAgd2hpbGUgKDEpO1xuICAgICAgbGFuZXMgJiYgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyKys7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCksXG4gICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRVcGRhdGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICBiOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAoKGxhbmVzID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAobWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25BY3Rpb246XG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBTdXNwZW5kZWRPbkRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IFN1c3BlbmRlZE9uQWN0aW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUpO1xuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycylcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBob3N0RmliZXIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGhvc3RGaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZWxvYWRJbnN0YW5jZShob3N0RmliZXIuc3RhdGVOb2RlLCB0eXBlLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBob3N0RmliZXIuc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaG9zdEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVuaXRPZldvcmsocmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdHlwZSBvZiBmaWJlciB0cmlnZ2VyZWQgYSBzdXNwZW5zZXkgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZEF0VGhlU2hlbGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5kZWRSZWFzb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgICAgICA/IHdvcmtMb29wU3luYygpXG4gICAgICAgICAgICA6IHdvcmtMb29wQ29uY3VycmVudEJ5U2NoZWR1bGVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDUpIHtcbiAgICAgICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQ1KTtcbiAgICAgICAgfVxuICAgICAgd2hpbGUgKDEpO1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykgcmV0dXJuIFJvb3RJblByb2dyZXNzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMDtcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcENvbmN1cnJlbnRCeVNjaGVkdWxlcigpIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAhc2hvdWxkWWllbGQoKTsgKVxuICAgICAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gICAgICAodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZVxuICAgICAgICA/IChzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayksXG4gICAgICAgICAgKGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBiZWdpbldvcmssXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKSlcbiAgICAgICAgOiAoY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGJlZ2luV29yayxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgICApKTtcbiAgICAgIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBuZXh0ID0gcnVuV2l0aEZpYmVySW5ERVYodW5pdE9mV29yaywgcmVwbGF5QmVnaW5Xb3JrLCB1bml0T2ZXb3JrKTtcbiAgICAgIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICAgICAgbnVsbCA9PT0gbmV4dCA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSA6ICh3b3JrSW5Qcm9ncmVzcyA9IG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlCZWdpbldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgaXNQcm9maWxpbmdNb2RlID0gKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGU7XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiYgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgICAgc3dpdGNoICh1bml0T2ZXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY3VycmVudCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHVuaXRPZldvcmsudHlwZSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLnJlbmRlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmsucmVmLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCB1bml0T2ZXb3JrKSxcbiAgICAgICAgICAgICh1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAoY3VycmVudCA9IGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcykpO1xuICAgICAgfVxuICAgICAgaXNQcm9maWxpbmdNb2RlICYmXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24odW5pdE9mV29yayk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgIHJvb3QsXG4gICAgICB1bml0T2ZXb3JrLFxuICAgICAgdGhyb3duVmFsdWUsXG4gICAgICBzdXNwZW5kZWRSZWFzb25cbiAgICApIHtcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspO1xuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuICAgICAgdmFyIHJldHVybkZpYmVyID0gdW5pdE9mV29yay5yZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhyb3dFeGNlcHRpb24oXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICAgICk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKSB0aHJvdyAoKHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIpLCBlcnJvcik7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodW5pdE9mV29yay5mbGFncyAmIDMyNzY4KSB7XG4gICAgICAgIGlmIChpc0h5ZHJhdGluZyB8fCBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRXJyb3IpIHJvb3QgPSAhMDtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgfHxcbiAgICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgICAgIClcbiAgICAgICAgICByb290ID0gITE7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gcm9vdCA9ICEwKSxcbiAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSB8fFxuICAgICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkFjdGlvbiB8fFxuICAgICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkltbWVkaWF0ZSB8fFxuICAgICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UpXG4gICAgICAgIClcbiAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICBudWxsICE9PSBzdXNwZW5kZWRSZWFzb24gJiZcbiAgICAgICAgICAgICAgMTMgPT09IHN1c3BlbmRlZFJlYXNvbi50YWcgJiZcbiAgICAgICAgICAgICAgKHN1c3BlbmRlZFJlYXNvbi5mbGFncyB8PSAxNjM4NCk7XG4gICAgICAgIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgcm9vdCk7XG4gICAgICB9IGVsc2UgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAzMjc2OCkpIHtcbiAgICAgICAgICB1bndpbmRVbml0T2ZXb3JrKFxuICAgICAgICAgICAgY29tcGxldGVkV29yayxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIHVuaXRPZldvcmsgPSBjb21wbGV0ZWRXb3JrLnJldHVybjtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgY29tcGxldGVkV29yayxcbiAgICAgICAgICBjb21wbGV0ZVdvcmssXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIChjb21wbGV0ZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24oY29tcGxldGVkV29yayk7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRXb3JrID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCBza2lwU2libGluZ3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHQpIHtcbiAgICAgICAgICBuZXh0LmZsYWdzICY9IDMyNzY3O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24odW5pdE9mV29yayk7XG4gICAgICAgICAgbmV4dCA9IHVuaXRPZldvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgZm9yICh2YXIgY2hpbGQgPSB1bml0T2ZXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZDsgKVxuICAgICAgICAgICAgKG5leHQgKz0gY2hpbGQuYWN0dWFsRHVyYXRpb24pLCAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB1bml0T2ZXb3JrLmFjdHVhbER1cmF0aW9uID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gdW5pdE9mV29yay5yZXR1cm47XG4gICAgICAgIG51bGwgIT09IG5leHQgJiZcbiAgICAgICAgICAoKG5leHQuZmxhZ3MgfD0gMzI3NjgpLFxuICAgICAgICAgIChuZXh0LnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgIChuZXh0LmRlbGV0aW9ucyA9IG51bGwpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFza2lwU2libGluZ3MgJiZcbiAgICAgICAgICAoKHVuaXRPZldvcmsgPSB1bml0T2ZXb3JrLnNpYmxpbmcpLCBudWxsICE9PSB1bml0T2ZXb3JrKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcms7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gdW5pdE9mV29yayA9IG5leHQ7XG4gICAgICB9IHdoaWxlIChudWxsICE9PSB1bml0T2ZXb3JrKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkQXRUaGVTaGVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdChcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBsYW5lcyxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBleGl0U3RhdHVzLFxuICAgICAgc3VzcGVuZGVkU3RhdGUsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgICAgZG8gZmx1c2hQZW5kaW5nRWZmZWN0cygpO1xuICAgICAgd2hpbGUgKHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBOT19QRU5ESU5HX0VGRkVDVFMpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIpO1xuICAgICAgc2V0Q3VycmVudFRyYWNrRnJvbUxhbmVzKGxhbmVzKTtcbiAgICAgIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkXG4gICAgICAgID8gbG9nRXJyb3JlZFJlbmRlclBoYXNlKFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZSxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGwgIT09IHJlY292ZXJhYmxlRXJyb3JzXG4gICAgICAgICAgPyBsb2dSZWNvdmVyZWRSZW5kZXJQaGFzZShcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yayAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDI1NiksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVXBkYXRlVGFza1xuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbG9nUmVuZGVyUGhhc2UoXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZSxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVXBkYXRlVGFza1xuICAgICAgICAgICAgKTtcbiAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgMCA9PT0gbGFuZXMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJmaW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayA9PT0gcm9vdC5jdXJyZW50KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlID1cbiAgICAgICAgICBmaW5pc2hlZFdvcmsubGFuZXMgfCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcztcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIHw9IGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcztcbiAgICAgICAgbWFya1Jvb3RGaW5pc2hlZChcbiAgICAgICAgICByb290LFxuICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICAgICApO1xuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCkpO1xuICAgICAgICBwZW5kaW5nRmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBwZW5kaW5nRWZmZWN0c1Jvb3QgPSByb290O1xuICAgICAgICBwZW5kaW5nRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGU7XG4gICAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgICAgICAgcGVuZGluZ1JlY292ZXJhYmxlRXJyb3JzID0gcmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzUmVuZGVyRW5kVGltZSA9IGNvbXBsZXRlZFJlbmRlckVuZFRpbWU7XG4gICAgICAgIHBlbmRpbmdTdXNwZW5kZWRDb21taXRSZWFzb24gPSBzdXNwZW5kZWRDb21taXRSZWFzb247XG4gICAgICAgIHBlbmRpbmdEZWxheWVkQ29tbWl0UmVhc29uID0gSU1NRURJQVRFX0NPTU1JVDtcbiAgICAgICAgcGVuZGluZ1N1c3BlbmRlZFZpZXdUcmFuc2l0aW9uUmVhc29uID0gbnVsbDtcbiAgICAgICAgMCAhPT0gZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uIHx8XG4gICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpIHx8XG4gICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1NilcbiAgICAgICAgICA/ICgocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSxcbiAgICAgICAgICAgIChyb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwKSxcbiAgICAgICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0cmFja1NjaGVkdWxlckV2ZW50KCk7XG4gICAgICAgICAgICAgIHBlbmRpbmdEZWxheWVkQ29tbWl0UmVhc29uID09PSBJTU1FRElBVEVfQ09NTUlUICYmXG4gICAgICAgICAgICAgICAgKHBlbmRpbmdEZWxheWVkQ29tbWl0UmVhc29uID0gREVMQVlFRF9QQVNTSVZFX0NPTU1JVCk7XG4gICAgICAgICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA6ICgocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSwgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApKTtcbiAgICAgICAgY29tbWl0RXJyb3JzID0gbnVsbDtcbiAgICAgICAgY29tbWl0U3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAgIG51bGwgIT09IHN1c3BlbmRlZENvbW1pdFJlYXNvbiAmJlxuICAgICAgICAgIGxvZ1N1c3BlbmRlZENvbW1pdFBoYXNlKFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZSxcbiAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVXBkYXRlVGFza1xuICAgICAgICAgICk7XG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzID0gMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDEzODc4KTtcbiAgICAgICAgaWYgKDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTM4NzgpIHx8IHJlY292ZXJhYmxlRXJyb3JzKSB7XG4gICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICAgIHRyYW5zaXRpb25zID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpO1xuICAgICAgICAgIHNwYXduZWRMYW5lID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSBzcGF3bmVkTGFuZSksXG4gICAgICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSh0cmFuc2l0aW9ucyksXG4gICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcmVjb3ZlcmFibGVFcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyA9IFBFTkRJTkdfTVVUQVRJT05fUEhBU0U7XG4gICAgICAgIGZsdXNoTXV0YXRpb25FZmZlY3RzKCk7XG4gICAgICAgIGZsdXNoTGF5b3V0RWZmZWN0cygpO1xuICAgICAgICBmbHVzaFNwYXduZWRXb3JrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoTXV0YXRpb25FZmZlY3RzKCkge1xuICAgICAgaWYgKHBlbmRpbmdFZmZlY3RzU3RhdHVzID09PSBQRU5ESU5HX01VVEFUSU9OX1BIQVNFKSB7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzU3RhdHVzID0gTk9fUEVORElOR19FRkZFQ1RTO1xuICAgICAgICB2YXIgcm9vdCA9IHBlbmRpbmdFZmZlY3RzUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsgPSBwZW5kaW5nRmluaXNoZWRXb3JrLFxuICAgICAgICAgIGxhbmVzID0gcGVuZGluZ0VmZmVjdHNMYW5lcyxcbiAgICAgICAgICByb290TXV0YXRpb25IYXNFZmZlY3QgPSAwICE9PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTM4NzgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMzg3OCkgfHxcbiAgICAgICAgICByb290TXV0YXRpb25IYXNFZmZlY3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgcm9vdE11dGF0aW9uSGFzRWZmZWN0ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKTtcbiAgICAgICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgKGluUHJvZ3Jlc3NMYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAgKGluUHJvZ3Jlc3NSb290ID0gcm9vdCksXG4gICAgICAgICAgICAgIHJlc2V0Q29tcG9uZW50RWZmZWN0VGltZXJzKCksXG4gICAgICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSxcbiAgICAgICAgICAgICAgKGluUHJvZ3Jlc3NSb290ID0gaW5Qcm9ncmVzc0xhbmVzID0gbnVsbCksXG4gICAgICAgICAgICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByb290TXV0YXRpb25IYXNFZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzU3RhdHVzID0gUEVORElOR19MQVlPVVRfUEhBU0U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoTGF5b3V0RWZmZWN0cygpIHtcbiAgICAgIGlmIChwZW5kaW5nRWZmZWN0c1N0YXR1cyA9PT0gUEVORElOR19MQVlPVVRfUEhBU0UpIHtcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBOT19QRU5ESU5HX0VGRkVDVFM7XG4gICAgICAgIHZhciBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbiA9XG4gICAgICAgICAgcGVuZGluZ1N1c3BlbmRlZFZpZXdUcmFuc2l0aW9uUmVhc29uO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3VzcGVuZGVkVmlld1RyYW5zaXRpb25SZWFzb24pIHtcbiAgICAgICAgICBjb21taXRTdGFydFRpbWUgPSBub3coKTtcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gY29tbWl0RW5kVGltZSxcbiAgICAgICAgICAgIGVuZFRpbWUgPSBjb21taXRTdGFydFRpbWU7XG4gICAgICAgICAgIXN1cHBvcnRzVXNlclRpbWluZyB8fFxuICAgICAgICAgICAgZW5kVGltZSA8PSBzdGFydFRpbWUgfHxcbiAgICAgICAgICAgIChhbmltYXRpbmdUYXNrXG4gICAgICAgICAgICAgID8gYW5pbWF0aW5nVGFzay5ydW4oXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzZWNvbmRhcnktbGlnaHRcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgIHN1c3BlbmRlZFZpZXdUcmFuc2l0aW9uUmVhc29uLFxuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgIFwic2Vjb25kYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbiA9IHBlbmRpbmdFZmZlY3RzUm9vdDtcbiAgICAgICAgc3RhcnRUaW1lID0gcGVuZGluZ0ZpbmlzaGVkV29yaztcbiAgICAgICAgZW5kVGltZSA9IHBlbmRpbmdFZmZlY3RzTGFuZXM7XG4gICAgICAgIHZhciByb290SGFzTGF5b3V0RWZmZWN0ID0gMCAhPT0gKHN0YXJ0VGltZS5mbGFncyAmIDg3NzIpO1xuICAgICAgICBpZiAoMCAhPT0gKHN0YXJ0VGltZS5zdWJ0cmVlRmxhZ3MgJiA4NzcyKSB8fCByb290SGFzTGF5b3V0RWZmZWN0KSB7XG4gICAgICAgICAgcm9vdEhhc0xheW91dEVmZmVjdCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpO1xuICAgICAgICAgIHZhciBfcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgKGluUHJvZ3Jlc3NMYW5lcyA9IGVuZFRpbWUpLFxuICAgICAgICAgICAgICAoaW5Qcm9ncmVzc1Jvb3QgPSBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbiksXG4gICAgICAgICAgICAgIHJlc2V0Q29tcG9uZW50RWZmZWN0VGltZXJzKCksXG4gICAgICAgICAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIoXG4gICAgICAgICAgICAgICAgc3VzcGVuZGVkVmlld1RyYW5zaXRpb25SZWFzb24sXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGluUHJvZ3Jlc3NSb290ID0gaW5Qcm9ncmVzc0xhbmVzID0gbnVsbCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ID0gX3ByZXZFeGVjdXRpb25Db250ZXh0KSxcbiAgICAgICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KF9wcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByb290SGFzTGF5b3V0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VzcGVuZGVkVmlld1RyYW5zaXRpb25SZWFzb24gPSBwZW5kaW5nRWZmZWN0c1JlbmRlckVuZFRpbWU7XG4gICAgICAgIHN0YXJ0VGltZSA9IHBlbmRpbmdTdXNwZW5kZWRDb21taXRSZWFzb247XG4gICAgICAgIGNvbW1pdEVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgc3VzcGVuZGVkVmlld1RyYW5zaXRpb25SZWFzb24gPVxuICAgICAgICAgIG51bGwgPT09IHN0YXJ0VGltZSA/IHN1c3BlbmRlZFZpZXdUcmFuc2l0aW9uUmVhc29uIDogY29tbWl0U3RhcnRUaW1lO1xuICAgICAgICBzdGFydFRpbWUgPSBjb21taXRFbmRUaW1lO1xuICAgICAgICBlbmRUaW1lID0gcGVuZGluZ0RlbGF5ZWRDb21taXRSZWFzb24gPT09IEFCT1JURURfVklFV19UUkFOU0lUSU9OX0NPTU1JVDtcbiAgICAgICAgcm9vdEhhc0xheW91dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzVXBkYXRlVGFzaztcbiAgICAgICAgbnVsbCAhPT0gY29tbWl0RXJyb3JzXG4gICAgICAgICAgPyBsb2dDb21taXRFcnJvcmVkKFxuICAgICAgICAgICAgICBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBjb21taXRFcnJvcnMsXG4gICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICByb290SGFzTGF5b3V0RWZmZWN0XG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAhc3VwcG9ydHNVc2VyVGltaW5nIHx8XG4gICAgICAgICAgICBzdGFydFRpbWUgPD0gc3VzcGVuZGVkVmlld1RyYW5zaXRpb25SZWFzb24gfHxcbiAgICAgICAgICAgIChyb290SGFzTGF5b3V0RWZmZWN0XG4gICAgICAgICAgICAgID8gcm9vdEhhc0xheW91dEVmZmVjdC5ydW4oXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lID8gXCJDb21taXQgSW50ZXJydXB0ZWQgVmlldyBUcmFuc2l0aW9uXCIgOiBcIkNvbW1pdFwiLFxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA/IFwiZXJyb3JcIiA6IFwic2Vjb25kYXJ5LWRhcmtcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPyBcIkNvbW1pdCBJbnRlcnJ1cHRlZCBWaWV3IFRyYW5zaXRpb25cIiA6IFwiQ29tbWl0XCIsXG4gICAgICAgICAgICAgICAgICBzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbixcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPyBcImVycm9yXCIgOiBcInNlY29uZGFyeS1kYXJrXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBQRU5ESU5HX0FGVEVSX01VVEFUSU9OX1BIQVNFO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFNwYXduZWRXb3JrKCkge1xuICAgICAgaWYgKFxuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyA9PT0gUEVORElOR19TUEFXTkVEX1dPUksgfHxcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPT09IFBFTkRJTkdfQUZURVJfTVVUQVRJT05fUEhBU0VcbiAgICAgICkge1xuICAgICAgICBpZiAocGVuZGluZ0VmZmVjdHNTdGF0dXMgPT09IFBFTkRJTkdfU1BBV05FRF9XT1JLKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUgPSBjb21taXRFbmRUaW1lO1xuICAgICAgICAgIGNvbW1pdEVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgICB2YXIgZW5kVGltZSA9IGNvbW1pdEVuZFRpbWUsXG4gICAgICAgICAgICBhYm9ydGVkVmlld1RyYW5zaXRpb24gPVxuICAgICAgICAgICAgICBwZW5kaW5nRGVsYXllZENvbW1pdFJlYXNvbiA9PT0gQUJPUlRFRF9WSUVXX1RSQU5TSVRJT05fQ09NTUlUO1xuICAgICAgICAgICFzdXBwb3J0c1VzZXJUaW1pbmcgfHxcbiAgICAgICAgICAgIGVuZFRpbWUgPD0gc3RhcnRWaWV3VHJhbnNpdGlvblN0YXJ0VGltZSB8fFxuICAgICAgICAgICAgKGFuaW1hdGluZ1Rhc2tcbiAgICAgICAgICAgICAgPyBhbmltYXRpbmdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZVN0YW1wLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICAgIGFib3J0ZWRWaWV3VHJhbnNpdGlvblxuICAgICAgICAgICAgICAgICAgICAgID8gXCJJbnRlcnJ1cHRlZCBWaWV3IFRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJTdGFydGluZyBBbmltYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWaWV3VHJhbnNpdGlvblN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgIGFib3J0ZWRWaWV3VHJhbnNpdGlvbiA/IFwiZXJyb3JcIiA6IFwic2Vjb25kYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS50aW1lU3RhbXAoXG4gICAgICAgICAgICAgICAgICBhYm9ydGVkVmlld1RyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBcIkludGVycnVwdGVkIFZpZXcgVHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJTdGFydGluZyBBbmltYXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgYWJvcnRlZFZpZXdUcmFuc2l0aW9uID8gXCIgZXJyb3JcIiA6IFwic2Vjb25kYXJ5LWxpZ2h0XCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwZW5kaW5nRGVsYXllZENvbW1pdFJlYXNvbiAhPT0gQUJPUlRFRF9WSUVXX1RSQU5TSVRJT05fQ09NTUlUICYmXG4gICAgICAgICAgICAocGVuZGluZ0RlbGF5ZWRDb21taXRSZWFzb24gPSBBTklNQVRJT05fU1RBUlRFRF9DT01NSVQpO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzU3RhdHVzID0gTk9fUEVORElOR19FRkZFQ1RTO1xuICAgICAgICByZXF1ZXN0UGFpbnQoKTtcbiAgICAgICAgc3RhcnRWaWV3VHJhbnNpdGlvblN0YXJ0VGltZSA9IHBlbmRpbmdFZmZlY3RzUm9vdDtcbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHBlbmRpbmdGaW5pc2hlZFdvcms7XG4gICAgICAgIGVuZFRpbWUgPSBwZW5kaW5nRWZmZWN0c0xhbmVzO1xuICAgICAgICBhYm9ydGVkVmlld1RyYW5zaXRpb24gPSBwZW5kaW5nUmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID1cbiAgICAgICAgICAwICE9PSBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24gfHxcbiAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KSB8fFxuICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1Nik7XG4gICAgICAgIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHNcbiAgICAgICAgICA/IChwZW5kaW5nRWZmZWN0c1N0YXR1cyA9IFBFTkRJTkdfUEFTU0lWRV9QSEFTRSlcbiAgICAgICAgICA6ICgocGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBOT19QRU5ESU5HX0VGRkVDVFMpLFxuICAgICAgICAgICAgKHBlbmRpbmdGaW5pc2hlZFdvcmsgPSBwZW5kaW5nRWZmZWN0c1Jvb3QgPSBudWxsKSxcbiAgICAgICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUoXG4gICAgICAgICAgICAgIHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUsXG4gICAgICAgICAgICAgIHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUucGVuZGluZ0xhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSk7XG4gICAgICAgIHZhciByZW1haW5pbmdMYW5lcyA9IHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUucGVuZGluZ0xhbmVzO1xuICAgICAgICAwID09PSByZW1haW5pbmdMYW5lcyAmJiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsKTtcbiAgICAgICAgcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyB8fFxuICAgICAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihzdGFydFZpZXdUcmFuc2l0aW9uU3RhcnRUaW1lKTtcbiAgICAgICAgcmVtYWluaW5nTGFuZXMgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShlbmRUaW1lKTtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdFxuICAgICAgICApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkaWRFcnJvciA9IDEyOCA9PT0gKGZpbmlzaGVkV29yay5jdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVtYWluaW5nTGFuZXMpIHtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChcbiAgICAgICAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSxcbiAgICAgICAgICAgICAgZGlkRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlb1wiLFxuICAgICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmXG4gICAgICAgICAgc3RhcnRWaWV3VHJhbnNpdGlvblN0YXJ0VGltZS5tZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIG9uQ29tbWl0Um9vdCgpO1xuICAgICAgICBpZiAobnVsbCAhPT0gYWJvcnRlZFZpZXdUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgb25SZWNvdmVyYWJsZUVycm9yID1cbiAgICAgICAgICAgICAgc3RhcnRWaWV3VHJhbnNpdGlvblN0YXJ0VGltZS5vblJlY292ZXJhYmxlRXJyb3I7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsgPSAwO1xuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsgPCBhYm9ydGVkVmlld1RyYW5zaXRpb24ubGVuZ3RoO1xuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvdmVyYWJsZUVycm9yID0gYWJvcnRlZFZpZXdUcmFuc2l0aW9uW2ZpbmlzaGVkV29ya10sXG4gICAgICAgICAgICAgICAgZXJyb3JJbmZvID0gbWFrZUVycm9ySW5mbyhyZWNvdmVyYWJsZUVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvci5zb3VyY2UsXG4gICAgICAgICAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3IudmFsdWUsXG4gICAgICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gZGlkRXJyb3IpLFxuICAgICAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAwICE9PSAocGVuZGluZ0VmZmVjdHNMYW5lcyAmIDMpICYmIGZsdXNoUGVuZGluZ0VmZmVjdHMoKTtcbiAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUpO1xuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUucGVuZGluZ0xhbmVzO1xuICAgICAgICAwICE9PSAoZW5kVGltZSAmIDI2MTkzMCkgJiYgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgICAgICAgPyAoKG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICAgIHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgICA/IG5lc3RlZFVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgICAgICAgKHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IHN0YXJ0Vmlld1RyYW5zaXRpb25TdGFydFRpbWUpKSlcbiAgICAgICAgICA6IChuZXN0ZWRVcGRhdGVDb3VudCA9IDApO1xuICAgICAgICByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzIHx8IGZpbmFsaXplUmVuZGVyKGVuZFRpbWUsIGNvbW1pdEVuZFRpbWUpO1xuICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJiBmbHVzaEh5ZHJhdGlvbkV2ZW50cygpO1xuICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvckluZm8oY29tcG9uZW50U3RhY2spIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrID0geyBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2sgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnRTdGFjaywgXCJkaWdlc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ1lvdSBhcmUgYWNjZXNzaW5nIFwiZGlnZXN0XCIgZnJvbSB0aGUgZXJyb3JJbmZvIG9iamVjdCBwYXNzZWQgdG8gb25SZWNvdmVyYWJsZUVycm9yLiBUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBwcm92aWRlZCBhcyBwYXJ0IG9mIGVycm9ySW5mbyBidXQgY2FuIGJlIGFjY2Vzc2VkIGFzIGEgcHJvcGVydHkgb2YgdGhlIEVycm9yIGluc3RhbmNlIGl0c2VsZi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgICAgIDAgPT09IChyb290LnBvb2xlZENhY2hlTGFuZXMgJj0gcmVtYWluaW5nTGFuZXMpICYmXG4gICAgICAgICgocmVtYWluaW5nTGFuZXMgPSByb290LnBvb2xlZENhY2hlKSxcbiAgICAgICAgbnVsbCAhPSByZW1haW5pbmdMYW5lcyAmJlxuICAgICAgICAgICgocm9vdC5wb29sZWRDYWNoZSA9IG51bGwpLCByZWxlYXNlQ2FjaGUocmVtYWluaW5nTGFuZXMpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0VmZmVjdHMoKSB7XG4gICAgICBmbHVzaE11dGF0aW9uRWZmZWN0cygpO1xuICAgICAgZmx1c2hMYXlvdXRFZmZlY3RzKCk7XG4gICAgICBmbHVzaFNwYXduZWRXb3JrKCk7XG4gICAgICByZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAgICAgaWYgKHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBQRU5ESU5HX1BBU1NJVkVfUEhBU0UpIHJldHVybiAhMTtcbiAgICAgIHZhciByb290ID0gcGVuZGluZ0VmZmVjdHNSb290LFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdFZmZlY3RzUmVtYWluaW5nTGFuZXM7XG4gICAgICBwZW5kaW5nRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMDtcbiAgICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdFZmZlY3RzTGFuZXMpLFxuICAgICAgICBwcmlvcml0eSA9IDMyID4gcmVuZGVyUHJpb3JpdHkgPyAzMiA6IHJlbmRlclByaW9yaXR5O1xuICAgICAgcmVuZGVyUHJpb3JpdHkgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbnMgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICAgICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgcHJpb3JpdHkgPSBwZW5kaW5nRWZmZWN0c1Jvb3Q7XG4gICAgICAgIHZhciBsYW5lcyA9IHBlbmRpbmdFZmZlY3RzTGFuZXM7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzU3RhdHVzID0gTk9fUEVORElOR19FRkZFQ1RTO1xuICAgICAgICBwZW5kaW5nRmluaXNoZWRXb3JrID0gcGVuZGluZ0VmZmVjdHNSb290ID0gbnVsbDtcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNMYW5lcyA9IDA7XG4gICAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgc2V0Q3VycmVudFRyYWNrRnJvbUxhbmVzKGxhbmVzKTtcbiAgICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITA7XG4gICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMTtcbiAgICAgICAgdmFyIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAwO1xuICAgICAgICBjb21taXRFcnJvcnMgPSBudWxsO1xuICAgICAgICBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gbm93JDEoKTtcbiAgICAgICAgaWYgKHBlbmRpbmdEZWxheWVkQ29tbWl0UmVhc29uID09PSBBTklNQVRJT05fU1RBUlRFRF9DT01NSVQpIHtcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gY29tbWl0RW5kVGltZSxcbiAgICAgICAgICAgIGVuZFRpbWUgPSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgICAgICAgICFzdXBwb3J0c1VzZXJUaW1pbmcgfHxcbiAgICAgICAgICAgIGVuZFRpbWUgPD0gc3RhcnRUaW1lIHx8XG4gICAgICAgICAgICAoYW5pbWF0aW5nVGFza1xuICAgICAgICAgICAgICA/IGFuaW1hdGluZ1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgXCJBbmltYXRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzZWNvbmRhcnktZGFya1wiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICAgICAgXCJBbmltYXRpbmdcIixcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICBcInNlY29uZGFyeS1kYXJrXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBjb21taXRFbmRUaW1lO1xuICAgICAgICAgIGVuZFRpbWUgPSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgICAgICAgIHZhciBkZWxheWVkVW50aWxQYWludCA9XG4gICAgICAgICAgICBwZW5kaW5nRGVsYXllZENvbW1pdFJlYXNvbiA9PT0gREVMQVlFRF9QQVNTSVZFX0NPTU1JVDtcbiAgICAgICAgICAhc3VwcG9ydHNVc2VyVGltaW5nIHx8XG4gICAgICAgICAgICBlbmRUaW1lIDw9IHN0YXJ0VGltZSB8fFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVXBkYXRlVGFza1xuICAgICAgICAgICAgICA/IHdvcmtJblByb2dyZXNzVXBkYXRlVGFzay5ydW4oXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVTdGFtcC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLFxuICAgICAgICAgICAgICAgICAgICBkZWxheWVkVW50aWxQYWludCA/IFwiV2FpdGluZyBmb3IgUGFpbnRcIiA6IFwiV2FpdGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICAgICAgXCJTY2hlZHVsZXIgXFx1MjY5YlwiLFxuICAgICAgICAgICAgICAgICAgICBcInNlY29uZGFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUudGltZVN0YW1wKFxuICAgICAgICAgICAgICAgICAgZGVsYXllZFVudGlsUGFpbnQgPyBcIldhaXRpbmcgZm9yIFBhaW50XCIgOiBcIldhaXRpbmdcIixcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2ssXG4gICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICBcInNlY29uZGFyeS1saWdodFwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRUaW1lID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgICAgICB2YXIgZmluaXNoZWRXb3JrID0gcHJpb3JpdHkuY3VycmVudDtcbiAgICAgICAgcmVzZXRDb21wb25lbnRFZmZlY3RUaW1lcnMoKTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHZhciBmaW5pc2hlZFdvcmskanNjb21wJDAgPSBwcmlvcml0eS5jdXJyZW50O1xuICAgICAgICBmaW5pc2hlZFdvcmsgPSBwZW5kaW5nRWZmZWN0c1JlbmRlckVuZFRpbWU7XG4gICAgICAgIHJlc2V0Q29tcG9uZW50RWZmZWN0VGltZXJzKCk7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgZmluaXNoZWRXb3JrJGpzY29tcCQwLFxuICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocHJpb3JpdHkpO1xuICAgICAgICBleGVjdXRpb25Db250ZXh0ID0gc3RhcnRUaW1lO1xuICAgICAgICB2YXIgcGFzc2l2ZUVmZmVjdHNFbmRUaW1lID0gbm93JDEoKTtcbiAgICAgICAgZmluaXNoZWRXb3JrJGpzY29tcCQwID0gcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZTtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gd29ya0luUHJvZ3Jlc3NVcGRhdGVUYXNrO1xuICAgICAgICBudWxsICE9PSBjb21taXRFcnJvcnNcbiAgICAgICAgICA/IGxvZ0NvbW1pdEVycm9yZWQoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdHNFbmRUaW1lLFxuICAgICAgICAgICAgICBjb21taXRFcnJvcnMsXG4gICAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6ICFzdXBwb3J0c1VzZXJUaW1pbmcgfHxcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3RzRW5kVGltZSA8PSBmaW5pc2hlZFdvcmskanNjb21wJDAgfHxcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgPyBmaW5pc2hlZFdvcmsucnVuKFxuICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lU3RhbXAuYmluZChcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgXCJSZW1haW5pbmcgRWZmZWN0c1wiLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmskanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmVFZmZlY3RzRW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBcIlNjaGVkdWxlciBcXHUyNjliXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2Vjb25kYXJ5LWRhcmtcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLnRpbWVTdGFtcChcbiAgICAgICAgICAgICAgICAgIFwiUmVtYWluaW5nIEVmZmVjdHNcIixcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHBhc3NpdmVFZmZlY3RzRW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayxcbiAgICAgICAgICAgICAgICAgIFwiU2NoZWR1bGVyIFxcdTI2OWJcIixcbiAgICAgICAgICAgICAgICAgIFwic2Vjb25kYXJ5LWRhcmtcIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICBmaW5hbGl6ZVJlbmRlcihsYW5lcywgcGFzc2l2ZUVmZmVjdHNFbmRUaW1lKTtcbiAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzXG4gICAgICAgICAgPyBwcmlvcml0eSA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgPyBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgOiAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHByaW9yaXR5KSlcbiAgICAgICAgICA6IChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKTtcbiAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9ICExO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdFxuICAgICAgICApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcHJpb3JpdHkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJW9cIixcbiAgICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGVOb2RlID0gcHJpb3JpdHkuY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByZW5kZXJQcmlvcml0eSksXG4gICAgICAgICAgcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICByZWNvcmRFZmZlY3RFcnJvcihzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBzb3VyY2VGaWJlciwgMik7XG4gICAgICByb290RmliZXIgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgc291cmNlRmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdEZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShyb290RmliZXIsIDIpLCBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdEZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZXJyb3JcbiAgICApIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExO1xuICAgICAgaWYgKDMgPT09IHNvdXJjZUZpYmVyLnRhZylcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3I7ICkge1xuICAgICAgICAgIGlmICgzID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSkpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RXJyb3Ioc291cmNlRmliZXIpO1xuICAgICAgICAgICAgICBlcnJvciA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoMik7XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gZW5xdWV1ZVVwZGF0ZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciwgMik7XG4gICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgKGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWFya1Jvb3RVcGRhdGVkJDEoaW5zdGFuY2UsIDIpLFxuICAgICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbnN0YW5jZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yIGluc2lkZSBhIGRldGFjaGVkIHRyZWUuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LiBQb3RlbnRpYWwgY2F1c2VzIGluY2x1ZGUgZGVsZXRpbmcgdGhlIHNhbWUgZmliZXIgbW9yZSB0aGFuIG9uY2UsIGNvbW1pdHRpbmcgYW4gYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuRXJyb3IgbWVzc2FnZTpcXG5cXG4lc1wiLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgICAgIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgICAgIGlmIChudWxsID09PSBwaW5nQ2FjaGUpIHtcbiAgICAgICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgICAgIHZhciB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRocmVhZElEcyA9IHBpbmdDYWNoZS5nZXQod2FrZWFibGUpKSxcbiAgICAgICAgICB2b2lkIDAgPT09IHRocmVhZElEcyAmJlxuICAgICAgICAgICAgKCh0aHJlYWRJRHMgPSBuZXcgU2V0KCkpLCBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpKTtcbiAgICAgIHRocmVhZElEcy5oYXMobGFuZXMpIHx8XG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITApLFxuICAgICAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKSxcbiAgICAgICAgKHBpbmdDYWNoZSA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKSksXG4gICAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpLFxuICAgICAgICB3YWtlYWJsZS50aGVuKHBpbmdDYWNoZSwgcGluZ0NhY2hlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICAgICAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICAgICAgbnVsbCAhPT0gcGluZ0NhY2hlICYmIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyB8PSByb290LnN1c3BlbmRlZExhbmVzICYgcGluZ2VkTGFuZXM7XG4gICAgICByb290Lndhcm1MYW5lcyAmPSB+cGluZ2VkTGFuZXM7XG4gICAgICAwICE9PSAocGluZ2VkTGFuZXMgJiAxMjcpXG4gICAgICAgID8gMCA+IGJsb2NraW5nVXBkYXRlVGltZSAmJlxuICAgICAgICAgICgoYmxvY2tpbmdDbGFtcFRpbWUgPSBibG9ja2luZ1VwZGF0ZVRpbWUgPSBub3coKSksXG4gICAgICAgICAgKGJsb2NraW5nVXBkYXRlVGFzayA9IGNyZWF0ZVRhc2soXCJQcm9taXNlIFJlc29sdmVkXCIpKSxcbiAgICAgICAgICAoYmxvY2tpbmdVcGRhdGVUeXBlID0gMikpXG4gICAgICAgIDogMCAhPT0gKHBpbmdlZExhbmVzICYgNDE5NDA0OCkgJiZcbiAgICAgICAgICAwID4gdHJhbnNpdGlvblVwZGF0ZVRpbWUgJiZcbiAgICAgICAgICAoKHRyYW5zaXRpb25DbGFtcFRpbWUgPSB0cmFuc2l0aW9uVXBkYXRlVGltZSA9IG5vdygpKSxcbiAgICAgICAgICAodHJhbnNpdGlvblVwZGF0ZVRhc2sgPSBjcmVhdGVUYXNrKFwiUHJvbWlzZSBSZXNvbHZlZFwiKSksXG4gICAgICAgICAgKHRyYW5zaXRpb25VcGRhdGVUeXBlID0gMikpO1xuICAgICAgaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJlxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG5XaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbmFjdCgoKSA9PiB7XFxuICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbn0pO1xcbi8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3RcIlxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHBpbmdlZExhbmVzKSA9PT0gcGluZ2VkTGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG5vdyQxKCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpXG4gICAgICAgICAgPyAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgfD0gcGluZ2VkTGFuZXMpLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDApKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgMCA9PT0gcmV0cnlMYW5lICYmIChyZXRyeUxhbmUgPSBjbGFpbU5leHRSZXRyeUxhbmUoKSk7XG4gICAgICBib3VuZGFyeUZpYmVyID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICBudWxsICE9PSBib3VuZGFyeUZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpLFxuICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoYm91bmRhcnlGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICByZXRyeUxhbmUgPSAwO1xuICAgICAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gICAgICB2YXIgcmV0cnlMYW5lID0gMDtcbiAgICAgIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlLl9yZXRyeUNhY2hlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHJldHJ5Q2FjaGUgJiYgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICByb290JGpzY29tcCQwLFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpc0luU3RyaWN0TW9kZVxuICAgICkge1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA2NzExNzA1NikpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlciA9IGZpYmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBpc0luU3RyaWN0TW9kZSB8fCBpc1N0cmljdE1vZGVGaWJlcjtcbiAgICAgICAgICAyMiAhPT0gZmliZXIudGFnXG4gICAgICAgICAgICA/IGZpYmVyLmZsYWdzICYgNjcxMDg4NjRcbiAgICAgICAgICAgICAgPyBpc1N0cmljdE1vZGVGaWJlciAmJlxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IG51bGwgPT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgKGlzU3RyaWN0TW9kZUZpYmVyICYmIGZpYmVyLmZsYWdzICYgODE5MlxuICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGZpYmVyLnN1YnRyZWVGbGFncyAmIDY3MTA4ODY0ICYmXG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlclxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyKHJvb3QsIGZpYmVyKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpYmVyKSxcbiAgICAgICAgICBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaWJlciksXG4gICAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKHJvb3QsIGZpYmVyLmFsdGVybmF0ZSwgZmliZXIsICExKSxcbiAgICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhyb290LCBmaWJlciwgMCwgbnVsbCwgITEsIDApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCkge1xuICAgICAgdmFyIGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMDtcbiAgICAgIHJvb3QuY3VycmVudC5tb2RlICYgMjQgfHwgKGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMSk7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgICByb290LFxuICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDMgPT09IHRhZyB8fFxuICAgICAgICAgIDEgPT09IHRhZyB8fFxuICAgICAgICAgIDAgPT09IHRhZyB8fFxuICAgICAgICAgIDExID09PSB0YWcgfHxcbiAgICAgICAgICAxNCA9PT0gdGFnIHx8XG4gICAgICAgICAgMTUgPT09IHRhZ1xuICAgICAgICApIHtcbiAgICAgICAgICB0YWcgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlJlYWN0Q29tcG9uZW50XCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyh0YWcpKSByZXR1cm47XG4gICAgICAgICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZCh0YWcpO1xuICAgICAgICAgIH0gZWxzZSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbdGFnXSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvIHVzZUVmZmVjdCBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmXG4gICAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsaW5nRmliZXIpIHtcbiAgICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIHJldHVybiBudWxsICE9PSBhY3RRdWV1ZVxuICAgICAgICA/IChhY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKSwgZmFrZUFjdENhbGxiYWNrTm9kZSlcbiAgICAgICAgOiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpIHtcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiB0eXBlO1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBmYW1pbHkgPyB0eXBlIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5XG4gICAgICAgID8gbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucmVuZGVyICYmXG4gICAgICAgICAgKChmYW1pbHkgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpKSxcbiAgICAgICAgICB0eXBlLnJlbmRlciAhPT0gZmFtaWx5KVxuICAgICAgICAgID8gKChmYW1pbHkgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IGZhbWlseSB9KSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAoZmFtaWx5LmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSksXG4gICAgICAgICAgICBmYW1pbHkpXG4gICAgICAgICAgOiB0eXBlXG4gICAgICAgIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiAhMTtcbiAgICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICExLFxuICAgICAgICAkJHR5cGVvZk5leHRUeXBlID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJiBudWxsICE9PSBlbGVtZW50XG4gICAgICAgICAgICA/IGVsZW1lbnQuJCR0eXBlb2ZcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50ICYmIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVsZW1lbnRcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRVxuICAgICAgICAgICAgPyAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMClcbiAgICAgICAgICAgIDogJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9NRU1PX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lZWRzQ29tcGFyZUZhbWlsaWVzICYmXG4gICAgICAgICgoZmliZXIgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gZmliZXIgJiYgZmliZXIgPT09IHJlc29sdmVGYW1pbHkoZWxlbWVudCkpXG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IHJlc29sdmVGYW1pbHkgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCAmJlxuICAgICAgICAobnVsbCA9PT0gZmFpbGVkQm91bmRhcmllcyAmJiAoZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCkpLFxuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgZmliZXIsXG4gICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICBzdGFsZUZhbWlsaWVzXG4gICAgKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBfZmliZXIgPSBmaWJlcixcbiAgICAgICAgICBhbHRlcm5hdGUgPSBfZmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICAgIGNoaWxkID0gX2ZpYmVyLmNoaWxkLFxuICAgICAgICAgIHNpYmxpbmcgPSBfZmliZXIuc2libGluZyxcbiAgICAgICAgICB0YWcgPSBfZmliZXIudGFnO1xuICAgICAgICBfZmliZXIgPSBfZmliZXIudHlwZTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbmRpZGF0ZVR5cGUgPSBfZmliZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IF9maWJlci5yZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC5cIik7XG4gICAgICAgIHZhciBuZWVkc1JlbmRlciA9ICExO1xuICAgICAgICBfZmliZXIgPSAhMTtcbiAgICAgICAgbnVsbCAhPT0gY2FuZGlkYXRlVHlwZSAmJlxuICAgICAgICAgICgoY2FuZGlkYXRlVHlwZSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gY2FuZGlkYXRlVHlwZSAmJlxuICAgICAgICAgICAgKHN0YWxlRmFtaWxpZXMuaGFzKGNhbmRpZGF0ZVR5cGUpXG4gICAgICAgICAgICAgID8gKF9maWJlciA9ICEwKVxuICAgICAgICAgICAgICA6IHVwZGF0ZWRGYW1pbGllcy5oYXMoY2FuZGlkYXRlVHlwZSkgJiZcbiAgICAgICAgICAgICAgICAoMSA9PT0gdGFnID8gKF9maWJlciA9ICEwKSA6IChuZWVkc1JlbmRlciA9ICEwKSkpKTtcbiAgICAgICAgbnVsbCAhPT0gZmFpbGVkQm91bmRhcmllcyAmJlxuICAgICAgICAgIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkpICYmXG4gICAgICAgICAgKF9maWJlciA9ICEwKTtcbiAgICAgICAgX2ZpYmVyICYmIChmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSAhMCk7XG4gICAgICAgIGlmIChfZmliZXIgfHwgbmVlZHNSZW5kZXIpXG4gICAgICAgICAgKGFsdGVybmF0ZSA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhbHRlcm5hdGUsIGZpYmVyLCAyKTtcbiAgICAgICAgbnVsbCA9PT0gY2hpbGQgfHxcbiAgICAgICAgICBfZmliZXIgfHxcbiAgICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgICBzdGFsZUZhbWlsaWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHNpYmxpbmcpIGJyZWFrO1xuICAgICAgICBmaWJlciA9IHNpYmxpbmc7XG4gICAgICB9IHdoaWxlICgxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnNpYmxpbmcgPVxuICAgICAgICB0aGlzLmNoaWxkID1cbiAgICAgICAgdGhpcy5yZXR1cm4gPVxuICAgICAgICB0aGlzLnN0YXRlTm9kZSA9XG4gICAgICAgIHRoaXMudHlwZSA9XG4gICAgICAgIHRoaXMuZWxlbWVudFR5cGUgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVmQ2xlYW51cCA9IHRoaXMucmVmID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICB0aGlzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXVlID1cbiAgICAgICAgdGhpcy5tZW1vaXplZFByb3BzID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc3VidHJlZUZsYWdzID0gdGhpcy5mbGFncyA9IDA7XG4gICAgICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkTGFuZXMgPSB0aGlzLmxhbmVzID0gMDtcbiAgICAgIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTEuMTtcbiAgICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5fZGVidWdUYXNrID1cbiAgICAgICAgdGhpcy5fZGVidWdTdGFjayA9XG4gICAgICAgIHRoaXMuX2RlYnVnT3duZXIgPVxuICAgICAgICB0aGlzLl9kZWJ1Z0luZm8gPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICExO1xuICAgICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuICAgICAgaGFzQmFkTWFwUG9seWZpbGwgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8XG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhKCFDb21wb25lbnQgfHwgIUNvbXBvbmVudC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICAgICAgY3VycmVudC50YWcsXG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICBjdXJyZW50LmtleSxcbiAgICAgICAgICAgIGN1cnJlbnQubW9kZVxuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXIpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdTdGFjayA9IGN1cnJlbnQuX2RlYnVnU3RhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdUYXNrID0gY3VycmVudC5fZGVidWdUYXNrKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAoY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTEuMSkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgNjUwMTE3MTI7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICBwZW5kaW5nUHJvcHMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgPT09IHBlbmRpbmdQcm9wc1xuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBsYW5lczogcGVuZGluZ1Byb3BzLmxhbmVzLFxuICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHBlbmRpbmdQcm9wcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHBlbmRpbmdQcm9wcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbyA9IGN1cnJlbnQuX2RlYnVnSW5mbztcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IDY1MDExNzE0O1xuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMCkpXG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIGxhbmVzOiByZW5kZXJMYW5lcy5sYW5lcyxcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcmVuZGVyTGFuZXMuZmlyc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcmVuZGVyTGFuZXMuX2RlYnVnVGhlbmFibGVTdGF0ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgb3duZXIsXG4gICAgICBtb2RlLFxuICAgICAgbGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBmaWJlclRhZyA9IDAsXG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHR5cGU7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmIChmaWJlclRhZyA9IDEpLFxuICAgICAgICAgIChyZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKSk7XG4gICAgICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXMgJiYgc3VwcG9ydHNTaW5nbGV0b25zXG4gICAgICAgICAgPyAoKGZpYmVyVGFnID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAoZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgZmliZXJUYWcpXG4gICAgICAgICAgICAgID8gMjZcbiAgICAgICAgICAgICAgOiBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAyN1xuICAgICAgICAgICAgICAgIDogNSkpXG4gICAgICAgICAgOiBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAoKGZpYmVyVGFnID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBmaWJlclRhZylcbiAgICAgICAgICAgICAgICA/IDI2XG4gICAgICAgICAgICAgICAgOiA1KSlcbiAgICAgICAgICAgIDogKGZpYmVyVGFnID0gc3VwcG9ydHNTaW5nbGV0b25zXG4gICAgICAgICAgICAgICAgPyBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpXG4gICAgICAgICAgICAgICAgICA/IDI3XG4gICAgICAgICAgICAgICAgICA6IDVcbiAgICAgICAgICAgICAgICA6IDUpO1xuICAgICAgZWxzZVxuICAgICAgICBhOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMzEsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9BQ1RJVklUWV9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgICAgIG1vZGUgfD0gMjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodHlwZSA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChvd25lciA9IG1vZGUpLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdHlwZS5pZCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZS5pZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMiwgdHlwZSwga2V5LCBvd25lciB8IDIpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICAoa2V5LnN0YXRlTm9kZSA9IHsgZWZmZWN0RHVyYXRpb246IDAsIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMCB9KSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTksIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE2O1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwibnVsbFwiKVxuICAgICAgICAgICAgICA6IGlzQXJyYXlJbXBsKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlID1cbiAgICAgICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgICAgIDogKHBlbmRpbmdQcm9wcyA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gb3duZXJcbiAgICAgICAgICAgICAgPyBcIm51bWJlclwiID09PSB0eXBlb2Ygb3duZXIudGFnXG4gICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG93bmVyLm5hbWVcbiAgICAgICAgICAgICAgICAgID8gb3duZXIubmFtZVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZpYmVyVGFnICYmXG4gICAgICAgICAgICAgIChyZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGZpYmVyVGFnICsgXCJgLlwiKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gMjk7XG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMgPSBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAocGVuZGluZ1Byb3BzICsgXCIuXCIgKyByZXNvbHZlZFR5cGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAga2V5ID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICAgIGtleS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICBrZXkudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgICAgIGtleS5sYW5lcyA9IGxhbmVzO1xuICAgICAga2V5Ll9kZWJ1Z093bmVyID0gb3duZXI7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICBlbGVtZW50LnR5cGUsXG4gICAgICAgIGVsZW1lbnQua2V5LFxuICAgICAgICBlbGVtZW50LnByb3BzLFxuICAgICAgICBlbGVtZW50Ll9vd25lcixcbiAgICAgICAgbW9kZSxcbiAgICAgICAgbGFuZXNcbiAgICAgICk7XG4gICAgICBtb2RlLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBtb2RlLl9kZWJ1Z1N0YWNrID0gZWxlbWVudC5fZGVidWdTdGFjaztcbiAgICAgIG1vZGUuX2RlYnVnVGFzayA9IGVsZW1lbnQuX2RlYnVnVGFzaztcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICAgICAgZWxlbWVudHMgPSBjcmVhdGVGaWJlcig3LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgICAgIGVsZW1lbnRzLmxhbmVzID0gbGFuZXM7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIGNvbnRlbnQgPSBjcmVhdGVGaWJlcig2LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgICAgIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoZGVoeWRyYXRlZE5vZGUpIHtcbiAgICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKDE4LCBudWxsLCBudWxsLCBOb01vZGUpO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gZGVoeWRyYXRlZE5vZGU7XG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXIoXG4gICAgICAgIDQsXG4gICAgICAgIG51bGwgIT09IHBvcnRhbC5jaGlsZHJlbiA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdLFxuICAgICAgICBwb3J0YWwua2V5LFxuICAgICAgICBtb2RlXG4gICAgICApO1xuICAgICAgbW9kZS5sYW5lcyA9IGxhbmVzO1xuICAgICAgbW9kZS5zdGF0ZU5vZGUgPSB7XG4gICAgICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgIH07XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJSb290Tm9kZShcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB0aGlzLnRhZyA9IDE7XG4gICAgICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICAgICAgdGhpcy5waW5nQ2FjaGUgPSB0aGlzLmN1cnJlbnQgPSB0aGlzLnBlbmRpbmdDaGlsZHJlbiA9IG51bGw7XG4gICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gICAgICB0aGlzLmNhbGxiYWNrTm9kZSA9XG4gICAgICAgIHRoaXMubmV4dCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHQgPVxuICAgICAgICB0aGlzLmNvbnRleHQgPVxuICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdDb21taXQgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICAgICAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKC0xKTtcbiAgICAgIHRoaXMuZW50YW5nbGVkTGFuZXMgPVxuICAgICAgICB0aGlzLnNoZWxsU3VzcGVuZENvdW50ZXIgPVxuICAgICAgICB0aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID1cbiAgICAgICAgdGhpcy5leHBpcmVkTGFuZXMgPVxuICAgICAgICB0aGlzLndhcm1MYW5lcyA9XG4gICAgICAgIHRoaXMucGluZ2VkTGFuZXMgPVxuICAgICAgICB0aGlzLnN1c3BlbmRlZExhbmVzID1cbiAgICAgICAgdGhpcy5wZW5kaW5nTGFuZXMgPVxuICAgICAgICAgIDA7XG4gICAgICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKDApO1xuICAgICAgdGhpcy5oaWRkZW5VcGRhdGVzID0gY3JlYXRlTGFuZU1hcChudWxsKTtcbiAgICAgIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXg7XG4gICAgICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMub25DYXVnaHRFcnJvciA9IG9uQ2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGUgPSBudWxsO1xuICAgICAgdGhpcy5wb29sZWRDYWNoZUxhbmVzID0gMDtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gZm9ybVN0YXRlO1xuICAgICAgdGhpcy5pbmNvbXBsZXRlVHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IHRoaXMuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcbiAgICAgIGNvbnRhaW5lckluZm8gPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcbiAgICAgIGZvciAodGFnID0gMDsgMzEgPiB0YWc7IHRhZysrKSBjb250YWluZXJJbmZvLnB1c2gobmV3IFNldCgpKTtcbiAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gXCJoeWRyYXRlUm9vdCgpXCIgOiBcImNyZWF0ZVJvb3QoKVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBmb3JtU3RhdGUsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgb25EZWZhdWx0VHJhbnNpdGlvbkluZGljYXRvclxuICAgICkge1xuICAgICAgY29udGFpbmVySW5mbyA9IG5ldyBGaWJlclJvb3ROb2RlKFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgIGh5ZHJhdGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICB0YWcgPSAxO1xuICAgICAgITAgPT09IGlzU3RyaWN0TW9kZSAmJiAodGFnIHw9IDI0KTtcbiAgICAgIGlzU3RyaWN0TW9kZSA9IGNyZWF0ZUZpYmVyKDMsIG51bGwsIG51bGwsIHRhZyB8IDIpO1xuICAgICAgY29udGFpbmVySW5mby5jdXJyZW50ID0gaXNTdHJpY3RNb2RlO1xuICAgICAgaXNTdHJpY3RNb2RlLnN0YXRlTm9kZSA9IGNvbnRhaW5lckluZm87XG4gICAgICB0YWcgPSBjcmVhdGVDYWNoZSgpO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8ucG9vbGVkQ2FjaGUgPSB0YWc7XG4gICAgICByZXRhaW5DYWNoZSh0YWcpO1xuICAgICAgaXNTdHJpY3RNb2RlLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuICAgICAgICBjYWNoZTogdGFnXG4gICAgICB9O1xuICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGlzU3RyaWN0TW9kZSk7XG4gICAgICByZXR1cm4gY29udGFpbmVySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGlmICghcGFyZW50Q29tcG9uZW50KSByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgcGFyZW50Q29tcG9uZW50ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyU3luYyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgIDIsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgcm9vdEZpYmVyLFxuICAgICAgbGFuZSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3RcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCBjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlb1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICAgICAgPyAoY29udGFpbmVyLmNvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpXG4gICAgICAgIDogKGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpc1JlbmRlcmluZyAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzICYmXG4gICAgICAgICgoZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy5cIixcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICkpO1xuICAgICAgY29udGFpbmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgY29udGFpbmVyLnBheWxvYWQgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjayAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICksXG4gICAgICAgIChjb250YWluZXIuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICAgICAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgICAgICAoc3RhcnRVcGRhdGVUaW1lckJ5TGFuZShsYW5lLCBcInJvb3QucmVuZGVyKClcIiwgbnVsbCksXG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihlbGVtZW50LCByb290RmliZXIsIGxhbmUpLFxuICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIgJiYgbnVsbCAhPT0gZmliZXIuZGVoeWRyYXRlZCkge1xuICAgICAgICB2YXIgYSA9IGZpYmVyLnJldHJ5TGFuZTtcbiAgICAgICAgZmliZXIucmV0cnlMYW5lID0gMCAhPT0gYSAmJiBhIDwgcmV0cnlMYW5lID8gYSA6IHJldHJ5TGFuZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICAoZmliZXIgPSBmaWJlci5hbHRlcm5hdGUpICYmIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIChcInVzZSBzdHJpY3RcIik7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgU2NoZWR1bGVyID0gcmVxdWlyZShcInNjaGVkdWxlclwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik7XG4gICAgdmFyIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnRyYWNpbmdfbWFya2VyXCIpO1xuICAgIHZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnZpZXdfdHJhbnNpdGlvblwiKTtcbiAgICB2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICByZW5kZXJlclZlcnNpb24gPSAkJCRjb25maWcucmVuZGVyZXJWZXJzaW9uLFxuICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZSA9ICQkJGNvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgICAgZXh0cmFEZXZUb29sc0NvbmZpZyA9ICQkJGNvbmZpZy5leHRyYURldlRvb2xzQ29uZmlnLFxuICAgICAgZ2V0UHVibGljSW5zdGFuY2UgPSAkJCRjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBnZXRSb290SG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Um9vdEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9ICQkJGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9ICQkJGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0LFxuICAgICAgY3JlYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSW5zdGFuY2U7XG4gICAgJCQkY29uZmlnLmNsb25lTXV0YWJsZUluc3RhbmNlO1xuICAgIHZhciBhcHBlbmRJbml0aWFsQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBzaG91bGRTZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2U7XG4gICAgJCQkY29uZmlnLmNsb25lTXV0YWJsZVRleHRJbnN0YW5jZTtcbiAgICB2YXIgc2NoZWR1bGVUaW1lb3V0ID0gJCQkY29uZmlnLnNjaGVkdWxlVGltZW91dCxcbiAgICAgIGNhbmNlbFRpbWVvdXQgPSAkJCRjb25maWcuY2FuY2VsVGltZW91dCxcbiAgICAgIG5vVGltZW91dCA9ICQkJGNvbmZpZy5ub1RpbWVvdXQsXG4gICAgICBpc1ByaW1hcnlSZW5kZXJlciA9ICQkJGNvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbiAgICAkJCRjb25maWcud2FybnNJZk5vdEFjdGluZztcbiAgICB2YXIgc3VwcG9ydHNNdXRhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c011dGF0aW9uLFxuICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGNvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlLFxuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNIeWRyYXRpb24sXG4gICAgICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgJCQkY29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICB2YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkY29uZmlnLnByZXBhcmVQb3J0YWxNb3VudDtcbiAgICAkJCRjb25maWcucHJlcGFyZVNjb3BlVXBkYXRlO1xuICAgICQkJGNvbmZpZy5nZXRJbnN0YW5jZUZyb21TY29wZTtcbiAgICB2YXIgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSxcbiAgICAgIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHksXG4gICAgICByZXNvbHZlVXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcucmVzb2x2ZVVwZGF0ZVByaW9yaXR5LFxuICAgICAgdHJhY2tTY2hlZHVsZXJFdmVudCA9ICQkJGNvbmZpZy50cmFja1NjaGVkdWxlckV2ZW50LFxuICAgICAgcmVzb2x2ZUV2ZW50VHlwZSA9ICQkJGNvbmZpZy5yZXNvbHZlRXZlbnRUeXBlLFxuICAgICAgcmVzb2x2ZUV2ZW50VGltZVN0YW1wID0gJCQkY29uZmlnLnJlc29sdmVFdmVudFRpbWVTdGFtcCxcbiAgICAgIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24gPSAkJCRjb25maWcuc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbixcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5kZXRhY2hEZWxldGVkSW5zdGFuY2U7XG4gICAgJCQkY29uZmlnLnJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjaztcbiAgICB2YXIgbWF5U3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlTdXNwZW5kQ29tbWl0LFxuICAgICAgbWF5U3VzcGVuZENvbW1pdE9uVXBkYXRlID0gJCQkY29uZmlnLm1heVN1c3BlbmRDb21taXRPblVwZGF0ZSxcbiAgICAgIG1heVN1c3BlbmRDb21taXRJblN5bmNSZW5kZXIgPSAkJCRjb25maWcubWF5U3VzcGVuZENvbW1pdEluU3luY1JlbmRlcixcbiAgICAgIHByZWxvYWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5wcmVsb2FkSW5zdGFuY2UsXG4gICAgICBzdGFydFN1c3BlbmRpbmdDb21taXQgPSAkJCRjb25maWcuc3RhcnRTdXNwZW5kaW5nQ29tbWl0LFxuICAgICAgc3VzcGVuZEluc3RhbmNlID0gJCQkY29uZmlnLnN1c3BlbmRJbnN0YW5jZTtcbiAgICAkJCRjb25maWcuc3VzcGVuZE9uQWN0aXZlVmlld1RyYW5zaXRpb247XG4gICAgdmFyIHdhaXRGb3JDb21taXRUb0JlUmVhZHkgPSAkJCRjb25maWcud2FpdEZvckNvbW1pdFRvQmVSZWFkeSxcbiAgICAgIGdldFN1c3BlbmRlZENvbW1pdFJlYXNvbiA9ICQkJGNvbmZpZy5nZXRTdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBOb3RQZW5kaW5nVHJhbnNpdGlvbiA9ICQkJGNvbmZpZy5Ob3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dCA9ICQkJGNvbmZpZy5Ib3N0VHJhbnNpdGlvbkNvbnRleHQsXG4gICAgICByZXNldEZvcm1JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZXNldEZvcm1JbnN0YW5jZSxcbiAgICAgIGJpbmRUb0NvbnNvbGUgPSAkJCRjb25maWcuYmluZFRvQ29uc29sZSxcbiAgICAgIHN1cHBvcnRzTWljcm90YXNrcyA9ICQkJGNvbmZpZy5zdXBwb3J0c01pY3JvdGFza3MsXG4gICAgICBzY2hlZHVsZU1pY3JvdGFzayA9ICQkJGNvbmZpZy5zY2hlZHVsZU1pY3JvdGFzayxcbiAgICAgIHN1cHBvcnRzVGVzdFNlbGVjdG9ycyA9ICQkJGNvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnMsXG4gICAgICBmaW5kRmliZXJSb290ID0gJCQkY29uZmlnLmZpbmRGaWJlclJvb3QsXG4gICAgICBnZXRCb3VuZGluZ1JlY3QgPSAkJCRjb25maWcuZ2V0Qm91bmRpbmdSZWN0LFxuICAgICAgZ2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuZ2V0VGV4dENvbnRlbnQsXG4gICAgICBpc0hpZGRlblN1YnRyZWUgPSAkJCRjb25maWcuaXNIaWRkZW5TdWJ0cmVlLFxuICAgICAgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGNvbmZpZy5tYXRjaEFjY2Vzc2liaWxpdHlSb2xlLFxuICAgICAgc2V0Rm9jdXNJZkZvY3VzYWJsZSA9ICQkJGNvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlLFxuICAgICAgc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciA9ICQkJGNvbmZpZy5zZXR1cEludGVyc2VjdGlvbk9ic2VydmVyLFxuICAgICAgYXBwZW5kQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBjb21taXRNb3VudCA9ICQkJGNvbmZpZy5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRVcGRhdGUsXG4gICAgICBpbnNlcnRCZWZvcmUgPSAkJCRjb25maWcuaW5zZXJ0QmVmb3JlLFxuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUgPSAkJCRjb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZEZyb21Db250YWluZXIsXG4gICAgICByZXNldFRleHRDb250ZW50ID0gJCQkY29uZmlnLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBoaWRlSW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZUluc3RhbmNlLFxuICAgICAgaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlVGV4dEluc3RhbmNlLFxuICAgICAgdW5oaWRlSW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlSW5zdGFuY2UsXG4gICAgICB1bmhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlVGV4dEluc3RhbmNlO1xuICAgICQkJGNvbmZpZy5jYW5jZWxWaWV3VHJhbnNpdGlvbk5hbWU7XG4gICAgJCQkY29uZmlnLmNhbmNlbFJvb3RWaWV3VHJhbnNpdGlvbk5hbWU7XG4gICAgJCQkY29uZmlnLnJlc3RvcmVSb290Vmlld1RyYW5zaXRpb25OYW1lO1xuICAgICQkJGNvbmZpZy5jbG9uZVJvb3RWaWV3VHJhbnNpdGlvbkNvbnRhaW5lcjtcbiAgICAkJCRjb25maWcucmVtb3ZlUm9vdFZpZXdUcmFuc2l0aW9uQ2xvbmU7XG4gICAgJCQkY29uZmlnLm1lYXN1cmVDbG9uZWRJbnN0YW5jZTtcbiAgICAkJCRjb25maWcuaGFzSW5zdGFuY2VDaGFuZ2VkO1xuICAgICQkJGNvbmZpZy5oYXNJbnN0YW5jZUFmZmVjdGVkUGFyZW50O1xuICAgICQkJGNvbmZpZy5zdGFydFZpZXdUcmFuc2l0aW9uO1xuICAgICQkJGNvbmZpZy5zdGFydEdlc3R1cmVUcmFuc2l0aW9uO1xuICAgICQkJGNvbmZpZy5zdG9wVmlld1RyYW5zaXRpb247XG4gICAgJCQkY29uZmlnLmdldEN1cnJlbnRHZXN0dXJlT2Zmc2V0O1xuICAgICQkJGNvbmZpZy5jcmVhdGVWaWV3VHJhbnNpdGlvbkluc3RhbmNlO1xuICAgIHZhciBjbGVhckNvbnRhaW5lciA9ICQkJGNvbmZpZy5jbGVhckNvbnRhaW5lcjtcbiAgICAkJCRjb25maWcuY3JlYXRlRnJhZ21lbnRJbnN0YW5jZTtcbiAgICAkJCRjb25maWcudXBkYXRlRnJhZ21lbnRJbnN0YW5jZUZpYmVyO1xuICAgICQkJGNvbmZpZy5jb21taXROZXdDaGlsZFRvRnJhZ21lbnRJbnN0YW5jZTtcbiAgICAkJCRjb25maWcuZGVsZXRlQ2hpbGRGcm9tRnJhZ21lbnRJbnN0YW5jZTtcbiAgICB2YXIgY2xvbmVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUluc3RhbmNlLFxuICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5JbnN0YW5jZSxcbiAgICAgIGNsb25lSGlkZGVuVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlLFxuICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGNvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nLFxuICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2ssXG4gICAgICBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMgPVxuICAgICAgICAkJCRjb25maWcuZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzLFxuICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRjb25maWcucmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnksXG4gICAgICBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIsXG4gICAgICBpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nID0gJCQkY29uZmlnLmlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nQWZ0ZXJTaW5nbGV0b24gPVxuICAgICAgICAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nQWZ0ZXJTaW5nbGV0b24sXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9ICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyID1cbiAgICAgICAgJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5BY3Rpdml0eUluc3RhbmNlID1cbiAgICAgICAgJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQWN0aXZpdHlJbnN0YW5jZSxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblNpbmdsZXRvbiA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblNpbmdsZXRvbixcbiAgICAgIGNhbkh5ZHJhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlQWN0aXZpdHlJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlQWN0aXZpdHlJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVBY3Rpdml0eUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVBY3Rpdml0eUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJBY3Rpdml0eUluc3RhbmNlID1cbiAgICAgICAgJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlckFjdGl2aXR5SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlID1cbiAgICAgICAgJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjb21taXRIeWRyYXRlZEluc3RhbmNlID0gJCQkY29uZmlnLmNvbW1pdEh5ZHJhdGVkSW5zdGFuY2UsXG4gICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZENvbnRhaW5lcixcbiAgICAgIGNvbW1pdEh5ZHJhdGVkQWN0aXZpdHlJbnN0YW5jZSA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZEFjdGl2aXR5SW5zdGFuY2UsXG4gICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgZmluYWxpemVIeWRyYXRlZENoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplSHlkcmF0ZWRDaGlsZHJlbixcbiAgICAgIGZsdXNoSHlkcmF0aW9uRXZlbnRzID0gJCQkY29uZmlnLmZsdXNoSHlkcmF0aW9uRXZlbnRzO1xuICAgICQkJGNvbmZpZy5jbGVhckFjdGl2aXR5Qm91bmRhcnk7XG4gICAgdmFyIGNsZWFyU3VzcGVuc2VCb3VuZGFyeSA9ICQkJGNvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnk7XG4gICAgJCQkY29uZmlnLmNsZWFyQWN0aXZpdHlCb3VuZGFyeUZyb21Db250YWluZXI7XG4gICAgdmFyIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcixcbiAgICAgIGhpZGVEZWh5ZHJhdGVkQm91bmRhcnkgPSAkJCRjb25maWcuaGlkZURlaHlkcmF0ZWRCb3VuZGFyeSxcbiAgICAgIHVuaGlkZURlaHlkcmF0ZWRCb3VuZGFyeSA9ICQkJGNvbmZpZy51bmhpZGVEZWh5ZHJhdGVkQm91bmRhcnksXG4gICAgICBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9XG4gICAgICAgICQkJGNvbmZpZy5zaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyxcbiAgICAgIGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MgPVxuICAgICAgICAkJCRjb25maWcuZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyxcbiAgICAgIGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyA9ICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MsXG4gICAgICBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzID1cbiAgICAgICAgJCQkY29uZmlnLmRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MsXG4gICAgICB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSA9ICQkJGNvbmZpZy52YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIHZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy52YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UsXG4gICAgICBzdXBwb3J0c1Jlc291cmNlcyA9ICQkJGNvbmZpZy5zdXBwb3J0c1Jlc291cmNlcyxcbiAgICAgIGlzSG9zdEhvaXN0YWJsZVR5cGUgPSAkJCRjb25maWcuaXNIb3N0SG9pc3RhYmxlVHlwZSxcbiAgICAgIGdldEhvaXN0YWJsZVJvb3QgPSAkJCRjb25maWcuZ2V0SG9pc3RhYmxlUm9vdCxcbiAgICAgIGdldFJlc291cmNlID0gJCQkY29uZmlnLmdldFJlc291cmNlLFxuICAgICAgYWNxdWlyZVJlc291cmNlID0gJCQkY29uZmlnLmFjcXVpcmVSZXNvdXJjZSxcbiAgICAgIHJlbGVhc2VSZXNvdXJjZSA9ICQkJGNvbmZpZy5yZWxlYXNlUmVzb3VyY2UsXG4gICAgICBoeWRyYXRlSG9pc3RhYmxlID0gJCQkY29uZmlnLmh5ZHJhdGVIb2lzdGFibGUsXG4gICAgICBtb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy5tb3VudEhvaXN0YWJsZSxcbiAgICAgIHVubW91bnRIb2lzdGFibGUgPSAkJCRjb25maWcudW5tb3VudEhvaXN0YWJsZSxcbiAgICAgIGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyA9ICQkJGNvbmZpZy5wcmVwYXJlVG9Db21taXRIb2lzdGFibGVzLFxuICAgICAgbWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0ID0gJCQkY29uZmlnLm1heVJlc291cmNlU3VzcGVuZENvbW1pdCxcbiAgICAgIHByZWxvYWRSZXNvdXJjZSA9ICQkJGNvbmZpZy5wcmVsb2FkUmVzb3VyY2UsXG4gICAgICBzdXNwZW5kUmVzb3VyY2UgPSAkJCRjb25maWcuc3VzcGVuZFJlc291cmNlLFxuICAgICAgc3VwcG9ydHNTaW5nbGV0b25zID0gJCQkY29uZmlnLnN1cHBvcnRzU2luZ2xldG9ucyxcbiAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcuYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIGlzSG9zdFNpbmdsZXRvblR5cGUgPSAkJCRjb25maWcuaXNIb3N0U2luZ2xldG9uVHlwZSxcbiAgICAgIGlzU2luZ2xldG9uU2NvcGUgPSAkJCRjb25maWcuaXNTaW5nbGV0b25TY29wZSxcbiAgICAgIHZhbHVlU3RhY2sgPSBbXTtcbiAgICB2YXIgZmliZXJTdGFjayA9IFtdO1xuICAgIHZhciBpbmRleCRqc2NvbXAkMCA9IC0xLFxuICAgICAgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuICAgIHZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyQxID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIG5leHRUcmFuc2l0aW9uVXBkYXRlTGFuZSA9IDI1NixcbiAgICAgIG5leHRUcmFuc2l0aW9uRGVmZXJyZWRMYW5lID0gMjYyMTQ0LFxuICAgICAgbmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQsXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDMgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICAgIGNhbmNlbENhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgICBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgICAgIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsXG4gICAgICBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgICBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxcbiAgICAgIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICAgICAgTm9ybWFsUHJpb3JpdHkkMSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgIElkbGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHksXG4gICAgICBsb2cgPSBTY2hlZHVsZXIubG9nLFxuICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUgPSBTY2hlZHVsZXIudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUsXG4gICAgICByZW5kZXJlcklEID0gbnVsbCxcbiAgICAgIGluamVjdGVkSG9vayA9IG51bGwsXG4gICAgICBoYXNMb2dnZWRFcnJvciA9ICExLFxuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLFxuICAgICAgbGFzdFJlc2V0VGltZSA9IDA7XG4gICAgaWYgKFxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZS5ub3dcbiAgICApIHtcbiAgICAgIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gICAgICB2YXIgZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gICAgICBnZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXBvcnRFcnJvclxuICAgICAgICAgID8gcmVwb3J0RXJyb3JcbiAgICAgICAgICA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHdpbmRvdyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdpbmRvdy5FcnJvckV2ZW50XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyB3aW5kb3cuRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcm9jZXNzLmVtaXRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5jYXVnaHRFeGNlcHRpb25cIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBzdXBwb3J0c1VzZXJUaW1pbmcgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY29uc29sZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb25zb2xlLnRpbWVTdGFtcCAmJlxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSxcbiAgICAgIGN1cnJlbnRUcmFjayA9IFwiQmxvY2tpbmdcIixcbiAgICAgIGFscmVhZHlXYXJuZWRGb3JEZWVwRXF1YWxpdHkgPSAhMSxcbiAgICAgIHJldXNhYmxlQ29tcG9uZW50RGV2VG9vbERldGFpbHMgPSB7XG4gICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgdG9vbHRpcFRleHQ6IFwiXCIsXG4gICAgICAgIHRyYWNrOiBcIkNvbXBvbmVudHMgXFx1MjY5YlwiXG4gICAgICB9LFxuICAgICAgcmV1c2FibGVDb21wb25lbnRPcHRpb25zID0ge1xuICAgICAgICBzdGFydDogLTAsXG4gICAgICAgIGVuZDogLTAsXG4gICAgICAgIGRldGFpbDogeyBkZXZ0b29sczogcmV1c2FibGVDb21wb25lbnREZXZUb29sRGV0YWlscyB9XG4gICAgICB9LFxuICAgICAgcmVzdWFibGVDaGFuZ2VkUHJvcHNFbnRyeSA9IFtcIkNoYW5nZWQgUHJvcHNcIiwgXCJcIl0sXG4gICAgICByZXVzYWJsZURlZXBseUVxdWFsUHJvcHNFbnRyeSA9IFtcbiAgICAgICAgXCJDaGFuZ2VkIFByb3BzXCIsXG4gICAgICAgIFwiVGhpcyBjb21wb25lbnQgcmVjZWl2ZWQgZGVlcGx5IGVxdWFsIHByb3BzLiBJdCBtaWdodCBiZW5lZml0IGZyb20gdXNlTWVtbyBvciB0aGUgUmVhY3QgQ29tcGlsZXIgaW4gaXRzIG93bmVyLlwiXG4gICAgICBdLFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBmb3JrU3RhY2sgPSBbXSxcbiAgICAgIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUZvcmtDb3VudCA9IDAsXG4gICAgICBpZFN0YWNrID0gW10sXG4gICAgICBpZFN0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlQ29udGV4dElkID0gMSxcbiAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBcIlwiLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBuZWVkc0VzY2FwaW5nID0gL1tcIicmPD5cXG5cXHRdfF5cXHN8XFxzJC8sXG4gICAgICBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGlzUmVuZGVyaW5nID0gITEsXG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwsXG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCxcbiAgICAgIGlzSHlkcmF0aW5nID0gITEsXG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExLFxuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsLFxuICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSxcbiAgICAgIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiSHlkcmF0aW9uIE1pc21hdGNoIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgTm9Nb2RlID0gMCxcbiAgICAgIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlckN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXIyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlclNpZ2lsID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsLFxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbCxcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMSxcbiAgICAgIEFib3J0Q29udHJvbGxlckxvY2FsID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIEFib3J0Q29udHJvbGxlclxuICAgICAgICAgID8gQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgICAgICAgICBzaWduYWwgPSAodGhpcy5zaWduYWwgPSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydGVkOiAhMSxcbiAgICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLmFib3J0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMiA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgICAgTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBDYWNoZUNvbnRleHQgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgIENvbnN1bWVyOiBudWxsLFxuICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTI6IG51bGwsXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgX2N1cnJlbnRSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRSZW5kZXJlcjI6IG51bGxcbiAgICAgIH0sXG4gICAgICBub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICByZW5kZXJTdGFydFRpbWUgPSAtMCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IC0wLFxuICAgICAgY29tbWl0RW5kVGltZSA9IC0wLFxuICAgICAgY29tbWl0RXJyb3JzID0gbnVsbCxcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTEuMSxcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSAtMCxcbiAgICAgIGNvbXBvbmVudEVmZmVjdER1cmF0aW9uID0gLTAsXG4gICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgPSAtMS4xLFxuICAgICAgY29tcG9uZW50RWZmZWN0RW5kVGltZSA9IC0xLjEsXG4gICAgICBjb21wb25lbnRFZmZlY3RFcnJvcnMgPSBudWxsLFxuICAgICAgY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSA9ICExLFxuICAgICAgYmxvY2tpbmdDbGFtcFRpbWUgPSAtMCxcbiAgICAgIGJsb2NraW5nVXBkYXRlVGltZSA9IC0xLjEsXG4gICAgICBibG9ja2luZ1VwZGF0ZVRhc2sgPSBudWxsLFxuICAgICAgYmxvY2tpbmdVcGRhdGVUeXBlID0gMCxcbiAgICAgIGJsb2NraW5nVXBkYXRlTWV0aG9kTmFtZSA9IG51bGwsXG4gICAgICBibG9ja2luZ1VwZGF0ZUNvbXBvbmVudE5hbWUgPSBudWxsLFxuICAgICAgYmxvY2tpbmdFdmVudFRpbWUgPSAtMS4xLFxuICAgICAgYmxvY2tpbmdFdmVudFR5cGUgPSBudWxsLFxuICAgICAgYmxvY2tpbmdFdmVudFJlcGVhdFRpbWUgPSAtMS4xLFxuICAgICAgYmxvY2tpbmdTdXNwZW5kZWRUaW1lID0gLTEuMSxcbiAgICAgIHRyYW5zaXRpb25DbGFtcFRpbWUgPSAtMCxcbiAgICAgIHRyYW5zaXRpb25TdGFydFRpbWUgPSAtMS4xLFxuICAgICAgdHJhbnNpdGlvblVwZGF0ZVRpbWUgPSAtMS4xLFxuICAgICAgdHJhbnNpdGlvblVwZGF0ZVR5cGUgPSAwLFxuICAgICAgdHJhbnNpdGlvblVwZGF0ZVRhc2sgPSBudWxsLFxuICAgICAgdHJhbnNpdGlvblVwZGF0ZU1ldGhvZE5hbWUgPSBudWxsLFxuICAgICAgdHJhbnNpdGlvblVwZGF0ZUNvbXBvbmVudE5hbWUgPSBudWxsLFxuICAgICAgdHJhbnNpdGlvbkV2ZW50VGltZSA9IC0xLjEsXG4gICAgICB0cmFuc2l0aW9uRXZlbnRUeXBlID0gbnVsbCxcbiAgICAgIHRyYW5zaXRpb25FdmVudFJlcGVhdFRpbWUgPSAtMS4xLFxuICAgICAgdHJhbnNpdGlvblN1c3BlbmRlZFRpbWUgPSAtMS4xLFxuICAgICAgYW5pbWF0aW5nVGFzayA9IG51bGwsXG4gICAgICB5aWVsZFJlYXNvbiA9IDAsXG4gICAgICB5aWVsZFN0YXJ0VGltZSA9IC0xLjEsXG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMSxcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExLFxuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID0gITEsXG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSAhMSxcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICExLFxuICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMSxcbiAgICAgIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCxcbiAgICAgIGZha2VBY3RDYWxsYmFja05vZGUkMSA9IHt9LFxuICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGwsXG4gICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGwsXG4gICAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlMgPSBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIGdsb2JhbE1vc3RSZWNlbnRUcmFuc2l0aW9uVGltZSA9IG5vdyQxKCk7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICApIHtcbiAgICAgICAgaWYgKDAgPiB0cmFuc2l0aW9uU3RhcnRUaW1lICYmIDAgPiB0cmFuc2l0aW9uVXBkYXRlVGltZSkge1xuICAgICAgICAgIHRyYW5zaXRpb25TdGFydFRpbWUgPSBub3coKTtcbiAgICAgICAgICB2YXIgbmV3RXZlbnRUaW1lID0gcmVzb2x2ZUV2ZW50VGltZVN0YW1wKCksXG4gICAgICAgICAgICBuZXdFdmVudFR5cGUgPSByZXNvbHZlRXZlbnRUeXBlKCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmV3RXZlbnRUaW1lICE9PSB0cmFuc2l0aW9uRXZlbnRSZXBlYXRUaW1lIHx8XG4gICAgICAgICAgICBuZXdFdmVudFR5cGUgIT09IHRyYW5zaXRpb25FdmVudFR5cGVcbiAgICAgICAgICApXG4gICAgICAgICAgICB0cmFuc2l0aW9uRXZlbnRSZXBlYXRUaW1lID0gLTEuMTtcbiAgICAgICAgICB0cmFuc2l0aW9uRXZlbnRUaW1lID0gbmV3RXZlbnRUaW1lO1xuICAgICAgICAgIHRyYW5zaXRpb25FdmVudFR5cGUgPSBuZXdFdmVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgICBudWxsICE9PSBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICB9O1xuICAgIHZhciByZXN1bWVkQ2FjaGUgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgICAgICAgcmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9LFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSxcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSB8fFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgITAgIT09XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIDggJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIGlmICgwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUpIHtcbiAgICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgIH07XG4gICAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKSxcbiAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICB2YXIgc3RyaWN0Um9vdCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmliZXI7IG51bGwgIT09IG5vZGU7IClcbiAgICAgICAgbm9kZS5tb2RlICYgOCAmJiAoc3RyaWN0Um9vdCA9IG5vZGUpLCAobm9kZSA9IG5vZGUucmV0dXJuKTtcbiAgICAgIG51bGwgPT09IHN0cmljdFJvb3RcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKVxuICAgICAgICA6ICFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICgobm9kZSA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCkpLFxuICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCkpICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gbm9kZSAmJlxuICAgICAgICAgICAgKChub2RlID0gW10pLCBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIG5vZGUpKSxcbiAgICAgICAgICBub2RlLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSkge1xuICAgICAgICBpZiAoMCAhPT0gZmliZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF0sXG4gICAgICAgICAgICB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmlyc3RGaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS5cXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyB1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dFwiLFxuICAgICAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIHZhciBjYWxsQ29tcG9uZW50ID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudEluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChjYWxsQ29tcG9uZW50KSxcbiAgICAgIGNhbGxSZW5kZXIgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHdhc1JlbmRlcmluZyA9IGlzUmVuZGVyaW5nO1xuICAgICAgICAgIGlzUmVuZGVyaW5nID0gITA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbFJlbmRlckluREVWID0gY2FsbFJlbmRlci5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChjYWxsUmVuZGVyKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudCA9IHtcbiAgICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrLCBpbnN0YW5jZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRcbiAgICAgICAgKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGUgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgIHNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZS5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgICksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2ggPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGluc3RhbmNlLCBlcnJvckluZm8pIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFjazogbnVsbCAhPT0gc3RhY2sgPyBzdGFjayA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoLnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaFxuICAgICAgICApLFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50ID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgICAgKSxcbiAgICAgIGNhbGxDcmVhdGUgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgICAgIHJldHVybiAoZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENyZWF0ZUluREVWID0gY2FsbENyZWF0ZS5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChjYWxsQ3JlYXRlKSxcbiAgICAgIGNhbGxEZXN0cm95ID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgZGVzdHJveVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbERlc3Ryb3lJbkRFViA9IGNhbGxEZXN0cm95LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKGNhbGxEZXN0cm95KSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAobGF6eSkge1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eS5faW5pdDtcbiAgICAgICAgICByZXR1cm4gaW5pdChsYXp5Ll9wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxMYXp5SW5pdEluREVWID1cbiAgICAgICAgY2FsbExhenlJbml0LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWAuXCJcbiAgICAgICksXG4gICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciwgYW5kIHNob3VsZCBub3QgbGVhayBpbnRvIHVzZXJzcGFjZS4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBpdCdzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKSxcbiAgICAgIFN1c3BlbnNlQWN0aW9uRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VBY3Rpb25TdGF0ZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyIHJldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VBY3Rpb25TdGF0ZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LlwiXG4gICAgICApLFxuICAgICAgbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQSBsaXN0ZW5lciB3YXMgdW5leHBlY3RlZGx5IGF0dGFjaGVkIHRvIGEgXCJub29wXCIgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsLFxuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSxcbiAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGwsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCxcbiAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0TWFwcztcbiAgICB2YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IChkaWRXYXJuQWJvdXRNYXBzID0gITEpO1xuICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICB2YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG4gICAgdmFyIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmcgPSB7fTtcbiAgICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGNoaWxkICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjaGlsZCAmJlxuICAgICAgICBjaGlsZC5fc3RvcmUgJiZcbiAgICAgICAgKCghY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCAmJiBudWxsID09IGNoaWxkLmtleSkgfHxcbiAgICAgICAgICAyID09PSBjaGlsZC5fc3RvcmUudmFsaWRhdGVkKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQuX3N0b3JlKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSxcbiAgICAgICAgICBjb21wb25lbnRLZXkgPSBjb21wb25lbnROYW1lIHx8IFwibnVsbFwiO1xuICAgICAgICBpZiAoIW93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldKSB7XG4gICAgICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0gPSAhMDtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9vd25lcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gXCJcIjtcbiAgICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJldHVybkZpYmVyLnRhZyAmJlxuICAgICAgICAgICAgKGNvbXBvbmVudEtleSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpKSAmJlxuICAgICAgICAgICAgKGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGNvbXBvbmVudEtleSArIFwiYC5cIik7XG4gICAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyB8fFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPi5cIikpO1xuICAgICAgICAgIHZhciBjaGlsZE93bmVyQXBwZW5kaXggPSBcIlwiO1xuICAgICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBjaGlsZCAmJlxuICAgICAgICAgICAgKChjb21wb25lbnROYW1lID0gbnVsbCksXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2hpbGQudGFnXG4gICAgICAgICAgICAgID8gKGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGNoaWxkKSlcbiAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGQubmFtZSAmJiAoY29tcG9uZW50TmFtZSA9IGNoaWxkLm5hbWUpLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lckFwcGVuZGl4ID1cbiAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIi5cIikpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKHdvcmtJblByb2dyZXNzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sXG4gICAgICAgICAgICAgIGNoaWxkT3duZXJBcHBlbmRpeFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCEwKSxcbiAgICAgIG1vdW50Q2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITEpLFxuICAgICAgT2Zmc2NyZWVuVmlzaWJsZSA9IDEsXG4gICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCA9IDIsXG4gICAgICBjb25jdXJyZW50UXVldWVzID0gW10sXG4gICAgICBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwLFxuICAgICAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gMCxcbiAgICAgIFVwZGF0ZVN0YXRlID0gMCxcbiAgICAgIFJlcGxhY2VTdGF0ZSA9IDEsXG4gICAgICBGb3JjZVVwZGF0ZSA9IDIsXG4gICAgICBDYXB0dXJlVXBkYXRlID0gMyxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSAhMTtcbiAgICB2YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgICB2YXIgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExLFxuICAgICAgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcigwKSxcbiAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgc2hlbGxCb3VuZGFyeSA9IG51bGwsXG4gICAgICBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDEsXG4gICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyLFxuICAgICAgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcigwKSxcbiAgICAgIE5vRmxhZ3MgPSAwLFxuICAgICAgSGFzRWZmZWN0ID0gMSxcbiAgICAgIEluc2VydGlvbiA9IDIsXG4gICAgICBMYXlvdXQgPSA0LFxuICAgICAgUGFzc2l2ZSA9IDgsXG4gICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcbiAgICB2YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcmVuZGVyTGFuZXMgPSAwLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsLFxuICAgICAgY3VycmVudEhvb2sgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExLFxuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMSxcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgZ2xvYmFsQ2xpZW50SWRDb3VudGVyID0gMCxcbiAgICAgIFJFX1JFTkRFUl9MSU1JVCA9IDI1LFxuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsLFxuICAgICAgaG9va1R5cGVzRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTEsXG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9ICExLFxuICAgICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICAgICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICAgIHVzZTogdXNlLFxuICAgICAgICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VGb3JtU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlQWN0aW9uU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlT3B0aW1pc3RpYzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VNZW1vQ2FjaGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlQ2FjaGVSZWZyZXNoOiB0aHJvd0ludmFsaWRIb29rRXJyb3JcbiAgICAgIH07XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUVmZmVjdEV2ZW50ID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIHZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlRm9ybVN0YXRlOiBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICAgIH0sXG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMsXG4gICAgICB1c2VNZW1vQ2FjaGU6IHVzZU1lbW9DYWNoZSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3RFdmVudDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RFdmVudFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFdmVudChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VBY3Rpb25TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgICAgfSxcbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cyxcbiAgICAgIHVzZU1lbW9DYWNoZTogdXNlTWVtb0NhY2hlLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3RFdmVudDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RFdmVudFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RXZlbnQoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VGb3JtU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICAgIH0sXG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMsXG4gICAgICB1c2VNZW1vQ2FjaGU6IHVzZU1lbW9DYWNoZSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3RFdmVudDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RFdmVudFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUV2ZW50KGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgICAgfSxcbiAgICAgIHVzZUFjdGlvblN0YXRlOiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgfSxcbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cyxcbiAgICAgIHVzZU1lbW9DYWNoZTogdXNlTWVtb0NhY2hlLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdEV2ZW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdEV2ZW50XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRXZlbnQoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VGb3JtU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9LFxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdEV2ZW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdEV2ZW50XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFdmVudChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlT3B0aW1pc3RpYzogZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9LFxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdEV2ZW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdEV2ZW50XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUV2ZW50KGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICB1c2VBY3Rpb25TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgICAgfSxcbiAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9LFxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdEV2ZW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdEV2ZW50XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUV2ZW50KGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuICAgIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xuICAgIHZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAgICAgICAoc3RhcnRVcGRhdGVUaW1lckJ5TGFuZShsYW5lLCBcInRoaXMuc2V0U3RhdGUoKVwiLCBpbnN0KSxcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShpbnN0KSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHN0YXJ0VXBkYXRlVGltZXJCeUxhbmUobGFuZSwgXCJ0aGlzLnJlcGxhY2VTdGF0ZSgpXCIsIGluc3QpLFxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChzdGFydFVwZGF0ZVRpbWVyQnlMYW5lKGxhbmUsIFwidGhpcy5mb3JjZVVwZGF0ZSgpXCIsIGluc3QpLFxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGNhbGxiYWNrLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoY2FsbGJhY2ssIGluc3QsIGxhbmUpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBudWxsLFxuICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsLFxuICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBSZWFjdCdzIHNlbGVjdGl2ZSBoeWRyYXRpb24gZmVhdHVyZS4gSWYgdGhpcyBsZWFrcyBpbnRvIHVzZXJzcGFjZSwgaXQncyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICksXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG4gICAgdmFyIFNVU1BFTkRFRF9NQVJLRVIgPSB7XG4gICAgICAgIGRlaHlkcmF0ZWQ6IG51bGwsXG4gICAgICAgIHRyZWVDb250ZXh0OiBudWxsLFxuICAgICAgICByZXRyeUxhbmU6IDAsXG4gICAgICAgIGh5ZHJhdGlvbkVycm9yczogbnVsbFxuICAgICAgfSxcbiAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG4gICAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9ICExLFxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9ICExLFxuICAgICAgbmVlZHNGb3JtUmVzZXQgPSAhMSxcbiAgICAgIFBvc3NpYmx5V2Vha1NldCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgPyBXZWFrU2V0IDogU2V0LFxuICAgICAgbmV4dEVmZmVjdCA9IG51bGwsXG4gICAgICBpblByb2dyZXNzTGFuZXMgPSBudWxsLFxuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgaG9zdFBhcmVudCA9IG51bGwsXG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMSxcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gbnVsbCxcbiAgICAgIGluSHlkcmF0ZWRTdWJ0cmVlID0gITEsXG4gICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gODE5MixcbiAgICAgIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIGdldENhY2hlRm9yVHlwZTogZnVuY3Rpb24gKHJlc291cmNlVHlwZSkge1xuICAgICAgICAgIHZhciBjYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCksXG4gICAgICAgICAgICBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gY2FjaGVGb3JUeXBlICYmXG4gICAgICAgICAgICAoKGNhY2hlRm9yVHlwZSA9IHJlc291cmNlVHlwZSgpKSxcbiAgICAgICAgICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKSk7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlRm9yVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGVTaWduYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KS5jb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENPTVBPTkVOVF9UWVBFID0gMCxcbiAgICAgIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDEsXG4gICAgICBST0xFX1RZUEUgPSAyLFxuICAgICAgVEVTVF9OQU1FX1RZUEUgPSAzLFxuICAgICAgVEVYVF9UWVBFID0gNDtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5mb3IpIHtcbiAgICAgIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICAgICAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5jb21wb25lbnRcIik7XG4gICAgICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzXCIpO1xuICAgICAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3Iucm9sZVwiKTtcbiAgICAgIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IudGVzdF9pZFwiKTtcbiAgICAgIFRFWFRfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnRleHRcIik7XG4gICAgfVxuICAgIHZhciBjb21taXRIb29rcyA9IFtdLFxuICAgICAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gICAgICBOb0NvbnRleHQgPSAwLFxuICAgICAgUmVuZGVyQ29udGV4dCA9IDIsXG4gICAgICBDb21taXRDb250ZXh0ID0gNCxcbiAgICAgIFJvb3RJblByb2dyZXNzID0gMCxcbiAgICAgIFJvb3RGYXRhbEVycm9yZWQgPSAxLFxuICAgICAgUm9vdEVycm9yZWQgPSAyLFxuICAgICAgUm9vdFN1c3BlbmRlZCA9IDMsXG4gICAgICBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNCxcbiAgICAgIFJvb3RTdXNwZW5kZWRBdFRoZVNoZWxsID0gNixcbiAgICAgIFJvb3RDb21wbGV0ZWQgPSA1LFxuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IE5vQ29udGV4dCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDAsXG4gICAgICBOb3RTdXNwZW5kZWQgPSAwLFxuICAgICAgU3VzcGVuZGVkT25FcnJvciA9IDEsXG4gICAgICBTdXNwZW5kZWRPbkRhdGEgPSAyLFxuICAgICAgU3VzcGVuZGVkT25JbW1lZGlhdGUgPSAzLFxuICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZSA9IDQsXG4gICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlID0gNSxcbiAgICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA9IDYsXG4gICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUgPSA3LFxuICAgICAgU3VzcGVuZGVkT25IeWRyYXRpb24gPSA4LFxuICAgICAgU3VzcGVuZGVkT25BY3Rpb24gPSA5LFxuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMSxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExLFxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMSxcbiAgICAgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwLFxuICAgICAgZ2xvYmFsTW9zdFJlY2VudFRyYW5zaXRpb25UaW1lID0gMCxcbiAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TID0gMzAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5LFxuICAgICAgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzVXBkYXRlVGFzayA9IG51bGwsXG4gICAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwsXG4gICAgICBJTU1FRElBVEVfQ09NTUlUID0gMCxcbiAgICAgIEFCT1JURURfVklFV19UUkFOU0lUSU9OX0NPTU1JVCA9IDEsXG4gICAgICBERUxBWUVEX1BBU1NJVkVfQ09NTUlUID0gMixcbiAgICAgIEFOSU1BVElPTl9TVEFSVEVEX0NPTU1JVCA9IDMsXG4gICAgICBOT19QRU5ESU5HX0VGRkVDVFMgPSAwLFxuICAgICAgUEVORElOR19NVVRBVElPTl9QSEFTRSA9IDEsXG4gICAgICBQRU5ESU5HX0xBWU9VVF9QSEFTRSA9IDIsXG4gICAgICBQRU5ESU5HX0FGVEVSX01VVEFUSU9OX1BIQVNFID0gMyxcbiAgICAgIFBFTkRJTkdfU1BBV05FRF9XT1JLID0gNCxcbiAgICAgIFBFTkRJTkdfUEFTU0lWRV9QSEFTRSA9IDUsXG4gICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyA9IDAsXG4gICAgICBwZW5kaW5nRWZmZWN0c1Jvb3QgPSBudWxsLFxuICAgICAgcGVuZGluZ0ZpbmlzaGVkV29yayA9IG51bGwsXG4gICAgICBwZW5kaW5nRWZmZWN0c0xhbmVzID0gMCxcbiAgICAgIHBlbmRpbmdFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ0VmZmVjdHNSZW5kZXJFbmRUaW1lID0gLTAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIHBlbmRpbmdSZWNvdmVyYWJsZUVycm9ycyA9IG51bGwsXG4gICAgICBwZW5kaW5nU3VzcGVuZGVkQ29tbWl0UmVhc29uID0gbnVsbCxcbiAgICAgIHBlbmRpbmdEZWxheWVkQ29tbWl0UmVhc29uID0gSU1NRURJQVRFX0NPTU1JVCxcbiAgICAgIHBlbmRpbmdTdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbiA9IG51bGwsXG4gICAgICBORVNURURfVVBEQVRFX0xJTUlUID0gNTAsXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCxcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGZha2VBY3RDYWxsYmFja05vZGUgPSB7fSxcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBudWxsLFxuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgdmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gITA7XG4gICAgfVxuICAgIHZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG4gICAgdmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wcyA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBzY2hlZHVsZVVwZGF0ZSA9IG51bGwsXG4gICAgICBzY2hlZHVsZVJldHJ5ID0gbnVsbCxcbiAgICAgIHNldEVycm9ySGFuZGxlciA9IG51bGwsXG4gICAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuICAgIG92ZXJyaWRlSG9va1N0YXRlID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgocGF0aCA9IGNvcHlXaXRoU2V0SW1wbChpZC5tZW1vaXplZFN0YXRlLCBwYXRoLCAwLCB2YWx1ZSkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aERlbGV0ZUltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKG9sZFBhdGggPSBjb3B5V2l0aFJlbmFtZShpZC5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBvbGRQYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKG9sZFBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gb2xkUGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIob2xkUGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldEltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCwgdmFsdWUpO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlSW1wbChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCAwKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgb2xkUGF0aCxcbiAgICAgICAgbmV3UGF0aFxuICAgICAgKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzY2hlZHVsZVJldHJ5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgbGFuZSA9IGNsYWltTmV4dFJldHJ5TGFuZSgpLFxuICAgICAgICByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9O1xuICAgIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICAgIHNob3VsZEVycm9ySW1wbCA9IG5ld1Nob3VsZEVycm9ySW1wbDtcbiAgICB9O1xuICAgIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGlmICgxMyA9PT0gZmliZXIudGFnIHx8IDMxID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZyB8fCAzMSA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgICBsYW5lID0gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbkJ5TGFuZShsYW5lKTtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpO1xuICAgICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIHZhciBsYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGZpYmVyLnBlbmRpbmdMYW5lcyk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gbGFuZXMpIHtcbiAgICAgICAgICAgICAgZmliZXIucGVuZGluZ0xhbmVzIHw9IDI7XG4gICAgICAgICAgICAgIGZvciAoZmliZXIuZW50YW5nbGVkTGFuZXMgfD0gMjsgbGFuZXM7ICkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gMSA8PCAoMzEgLSBjbHozMihsYW5lcykpO1xuICAgICAgICAgICAgICAgIGZpYmVyLmVudGFuZ2xlbWVudHNbMV0gfD0gbGFuZTtcbiAgICAgICAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoZmliZXIpO1xuICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PVxuICAgICAgICAgICAgICAgIE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9XG4gICAgICAgICAgICAgICAgICBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpLFxuICAgICAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIChsYW5lcyA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbGFuZXMgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGxhbmVzLCBmaWJlciwgMiksXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrKCksXG4gICAgICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhKSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IENPTVBPTkVOVF9UWVBFLCB2YWx1ZTogY29tcG9uZW50IH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgICExLFxuICAgICAgICBudWxsLFxuICAgICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIG9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3JcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLCB2YWx1ZTogc2VsZWN0b3JzIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIG9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4gPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgITAsXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIG9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3JcbiAgICAgICk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICAgICAgY29udGFpbmVySW5mbyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICAgICAgdGFnID0gcmVxdWVzdFVwZGF0ZUxhbmUoY29udGFpbmVySW5mbyk7XG4gICAgICB0YWcgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uQnlMYW5lKHRhZyk7XG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MgPSBjcmVhdGVVcGRhdGUodGFnKTtcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcy5jYWxsYmFjayA9XG4gICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IG51bGw7XG4gICAgICBlbnF1ZXVlVXBkYXRlKGNvbnRhaW5lckluZm8sIGh5ZHJhdGlvbkNhbGxiYWNrcywgdGFnKTtcbiAgICAgIHN0YXJ0VXBkYXRlVGltZXJCeUxhbmUodGFnLCBcImh5ZHJhdGVSb290KClcIiwgbnVsbCk7XG4gICAgICBjYWxsYmFjayA9IHRhZztcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jdXJyZW50LmxhbmVzID0gY2FsbGJhY2s7XG4gICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbml0aWFsQ2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbml0aWFsQ2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIGluaXRpYWxDaGlsZHJlbjtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUG9ydGFsID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgdmFyIGtleSA9XG4gICAgICAgIDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlJDYpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAga2V5W1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgICBrZXkuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgICAgXCJPYmplY3RcIlxuICAgICAgICApLFxuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAgICAgIGtleTogbnVsbCA9PSBrZXkgPyBudWxsIDogXCJcIiArIGtleSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVJvbGVTZWxlY3RvciA9IGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogUk9MRV9UWVBFLCB2YWx1ZTogcm9sZSB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVUZXN0TmFtZVNlbGVjdG9yID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogVEVTVF9OQU1FX1RZUEUsIHZhbHVlOiBpZCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVUZXh0U2VsZWN0b3IgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFRFWFRfVFlQRSwgdmFsdWU6IHRleHQgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmYXVsdE9uQ2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICAgIDogXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIixcbiAgICAgICAgcmVjcmVhdGVNZXNzYWdlID1cbiAgICAgICAgICBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIHVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICtcbiAgICAgICAgICAoKGVycm9yQm91bmRhcnlOYW1lIHx8IFwiQW5vbnltb3VzXCIpICsgXCIuXCIpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgICA/IGJpbmRUb0NvbnNvbGUoXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBbXCIlb1xcblxcbiVzXFxuXFxuJXNcXG5cIiwgZXJyb3IsIGNvbXBvbmVudE5hbWVNZXNzYWdlLCByZWNyZWF0ZU1lc3NhZ2VdLFxuICAgICAgICAgICAgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgKSgpXG4gICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgcmVjcmVhdGVNZXNzYWdlXG4gICAgICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25VbmNhdWdodEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgPyBcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICAgIDogXCJBbiBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLlwiLFxuICAgICAgICBcIkNvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcblZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuXCJcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmVycmVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMzIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbigpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICBmbihhLCBiLCBjLCBkKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5maW5kQWxsTm9kZXMgPSBmaW5kQWxsTm9kZXM7XG4gICAgZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgc2VsZWN0b3JzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgaG9zdFJvb3QgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKVxuICAgICAgICBob3N0Um9vdC5wdXNoKGdldEJvdW5kaW5nUmVjdChzZWxlY3RvcnNbaV0pKTtcbiAgICAgIGZvciAoc2VsZWN0b3JzID0gaG9zdFJvb3QubGVuZ3RoIC0gMTsgMCA8IHNlbGVjdG9yczsgc2VsZWN0b3JzLS0pIHtcbiAgICAgICAgaSA9IGhvc3RSb290W3NlbGVjdG9yc107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHRhcmdldExlZnQgPSBpLngsXG4gICAgICAgICAgICB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyBpLndpZHRoLFxuICAgICAgICAgICAgdGFyZ2V0VG9wID0gaS55LFxuICAgICAgICAgICAgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0VG9wICsgaS5oZWlnaHQsXG4gICAgICAgICAgICBqID0gc2VsZWN0b3JzIC0gMTtcbiAgICAgICAgICAwIDw9IGo7XG4gICAgICAgICAgai0tXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoc2VsZWN0b3JzICE9PSBqKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJSZWN0ID0gaG9zdFJvb3Rbal0sXG4gICAgICAgICAgICAgIG90aGVyTGVmdCA9IG90aGVyUmVjdC54LFxuICAgICAgICAgICAgICBvdGhlclJpZ2h0ID0gb3RoZXJMZWZ0ICsgb3RoZXJSZWN0LndpZHRoLFxuICAgICAgICAgICAgICBvdGhlclRvcCA9IG90aGVyUmVjdC55LFxuICAgICAgICAgICAgICBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA+PSBvdGhlckxlZnQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID49IG90aGVyVG9wICYmXG4gICAgICAgICAgICAgIHRhcmdldFJpZ2h0IDw9IG90aGVyUmlnaHQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0Qm90dG9tIDw9IG90aGVyQm90dG9tXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ICE9PSBvdGhlckxlZnQgfHxcbiAgICAgICAgICAgICAgICBpLndpZHRoICE9PSBvdGhlclJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgICAgICBvdGhlckJvdHRvbSA8IHRhcmdldFRvcCB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9wID4gdGFyZ2V0Qm90dG9tXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvdGhlclRvcCA+IHRhcmdldFRvcCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LmhlaWdodCArPSBvdGhlclRvcCAtIHRhcmdldFRvcCksXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC55ID0gdGFyZ2V0VG9wKSk7XG4gICAgICAgICAgICAgIG90aGVyQm90dG9tIDwgdGFyZ2V0Qm90dG9tICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcCk7XG4gICAgICAgICAgICAgIGhvc3RSb290LnNwbGljZShzZWxlY3RvcnMsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG9wICE9PSBvdGhlclRvcCB8fFxuICAgICAgICAgICAgICAgIGkuaGVpZ2h0ICE9PSBvdGhlclJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldExlZnQgfHxcbiAgICAgICAgICAgICAgICBvdGhlckxlZnQgPiB0YXJnZXRSaWdodFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3RoZXJMZWZ0ID4gdGFyZ2V0TGVmdCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LndpZHRoICs9IG90aGVyTGVmdCAtIHRhcmdldExlZnQpLFxuICAgICAgICAgICAgICAgIChvdGhlclJlY3QueCA9IHRhcmdldExlZnQpKTtcbiAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldFJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0KTtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0Um9vdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBmaWJlciA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50LnJlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIGNvbXBvbmVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbihcIixcIik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBjb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjb21wb25lbnQgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoY29tcG9uZW50LnN0YXRlTm9kZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgICAgIGZpYmVyID1cbiAgICAgICAgbnVsbCAhPT0gZmliZXIgPyBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGZpYmVyKSA6IG51bGw7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZmliZXIgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoZmliZXIuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50ID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IGNvbXBvbmVudCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoY29tcG9uZW50Lm1vZGUgJiA4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmliZXIubW9kZSAmIDhcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGVcIixcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiBJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlXCIsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb21wb25lbnQuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGVuZGluZ0VmZmVjdHM7XG4gICAgZXhwb3J0cy5mbHVzaFN5bmNGcm9tUmVjb25jaWxlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gMTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICgoc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbikpXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmZsdXNoU3luY1dvcmsgPSBmbHVzaFN5bmNXb3JrO1xuICAgIGV4cG9ydHMuZm9jdXNXaXRoaW4gPSBmdW5jdGlvbiAoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIHNlbGVjdG9ycyA9IGZpbmRQYXRocyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIHNlbGVjdG9ycyA9IEFycmF5LmZyb20oc2VsZWN0b3JzKTtcbiAgICAgIGZvciAoaG9zdFJvb3QgPSAwOyBob3N0Um9vdCA8IHNlbGVjdG9ycy5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBzZWxlY3RvcnNbaG9zdFJvb3QrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnO1xuICAgICAgICBpZiAoIWlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZykgJiZcbiAgICAgICAgICAgIHNldEZvY3VzSWZGb2N1c2FibGUoZmliZXIuc3RhdGVOb2RlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChmaWJlciksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIG1heFNlbGVjdG9ySW5kZXggPSAwLFxuICAgICAgICBtYXRjaGVkTmFtZXMgPSBbXTtcbiAgICAgIGhvc3RSb290ID0gW2ZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCksIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgICBzZWxlY3RvckluZGV4ID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmICgoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHwgIWlzSGlkZGVuU3VidHJlZShmaWJlcikpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSAmJlxuICAgICAgICAgICAgICAobWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikpLFxuICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4ICYmXG4gICAgICAgICAgICAgICAgKG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4KSksXG4gICAgICAgICAgICBzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aClcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgIGhvc3RSb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGhvc3RSb290ID0gW107XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGg7XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCsrXG4gICAgICAgIClcbiAgICAgICAgICBob3N0Um9vdC5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3JzW21heFNlbGVjdG9ySW5kZXhdKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgXCJmaW5kQWxsTm9kZXMgd2FzIGFibGUgdG8gbWF0Y2ggcGFydCBvZiB0aGUgc2VsZWN0b3I6XFxuICBcIiArXG4gICAgICAgICAgKG1hdGNoZWROYW1lcy5qb2luKFwiID4gXCIpICtcbiAgICAgICAgICAgIFwiXFxuXFxuTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuICBcIikgK1xuICAgICAgICAgIGhvc3RSb290LmpvaW4oXCIgPiBcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyLmNoaWxkKSByZXR1cm4gbnVsbDtcbiAgICAgIHN3aXRjaCAoY29udGFpbmVyLmNoaWxkLnRhZykge1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXJuYWxzID0ge1xuICAgICAgICBidW5kbGVUeXBlOiAxLFxuICAgICAgICB2ZXJzaW9uOiByZW5kZXJlclZlcnNpb24sXG4gICAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IHJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICAgICAgcmVjb25jaWxlclZlcnNpb246IFwiMTkuMi4wXCJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSBleHRyYURldlRvb2xzQ29uZmlnICYmXG4gICAgICAgIChpbnRlcm5hbHMucmVuZGVyZXJDb25maWcgPSBleHRyYURldlRvb2xzQ29uZmlnKTtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZSA9IG92ZXJyaWRlSG9va1N0YXRlO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wcyA9IG92ZXJyaWRlUHJvcHM7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlVXBkYXRlID0gc2NoZWR1bGVVcGRhdGU7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSZXRyeSA9IHNjaGVkdWxlUmV0cnk7XG4gICAgICBpbnRlcm5hbHMuc2V0RXJyb3JIYW5kbGVyID0gc2V0RXJyb3JIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLnNldFN1c3BlbnNlSGFuZGxlciA9IHNldFN1c3BlbnNlSGFuZGxlcjtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVJlZnJlc2ggPSBzY2hlZHVsZVJlZnJlc2g7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSb290ID0gc2NoZWR1bGVSb290O1xuICAgICAgaW50ZXJuYWxzLnNldFJlZnJlc2hIYW5kbGVyID0gc2V0UmVmcmVzaEhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuZ2V0Q3VycmVudEZpYmVyID0gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHM7XG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzQWxyZWFkeVJlbmRlcmluZyA9IGlzQWxyZWFkeVJlbmRlcmluZztcbiAgICBleHBvcnRzLm9ic2VydmVWaXNpYmxlUmVjdHMgPSBmdW5jdGlvbiAoXG4gICAgICBob3N0Um9vdCxcbiAgICAgIHNlbGVjdG9ycyxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgZnVuY3Rpb24gY29tbWl0SG9vaygpIHtcbiAgICAgICAgdmFyIG5leHRJbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgICBpbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIDAgPiBuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgJiYgdW5vYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0SW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAwID4gaW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgJiYgb2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIGNhbGxiYWNrID0gc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcihpbnN0YW5jZVJvb3RzLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICB2YXIgZGlzY29ubmVjdCA9IGNhbGxiYWNrLmRpc2Nvbm5lY3QsXG4gICAgICAgIG9ic2VydmUgPSBjYWxsYmFjay5vYnNlcnZlLFxuICAgICAgICB1bm9ic2VydmUgPSBjYWxsYmFjay51bm9ic2VydmU7XG4gICAgICBjb21taXRIb29rcy5wdXNoKGNvbW1pdEhvb2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGNvbW1pdEhvb2tzLmluZGV4T2YoY29tbWl0SG9vayk7XG4gICAgICAgICAgMCA8PSBpbmRleCAmJiBjb21taXRIb29rcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2hvdWxkRXJyb3IgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zaG91bGRTdXNwZW5kID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zdGFydEhvc3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKFxuICAgICAgZm9ybUZpYmVyLFxuICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgYWN0aW9uLFxuICAgICAgZm9ybURhdGFcbiAgICApIHtcbiAgICAgIGlmICg1ICE9PSBmb3JtRmliZXIudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBmb3JtIGluc3RhbmNlIHRvIGJlIGEgSG9zdENvbXBvbmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5xdWV1ZTtcbiAgICAgIHN0YXJ0SG9zdEFjdGlvblRpbWVyKGZvcm1GaWJlcik7XG4gICAgICBzdGFydFRyYW5zaXRpb24oXG4gICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIG51bGwgPT09IGFjdGlvblxuICAgICAgICAgID8gbm9vcFxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwicmVxdWVzdEZvcm1SZXNldCB3YXMgY2FsbGVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciBzdGF0ZUhvb2sgPSBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpO1xuICAgICAgICAgICAgICBudWxsID09PSBzdGF0ZUhvb2submV4dCAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZUhvb2sgPSBmb3JtRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUpO1xuICAgICAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICAgICAgZm9ybUZpYmVyLFxuICAgICAgICAgICAgICAgIHN0YXRlSG9vay5uZXh0LnF1ZXVlLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZvcm1GaWJlcilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihmb3JtRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIGxhbmUsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH07XG4gICAgZXhwb3J0cy51cGRhdGVDb250YWluZXJTeW5jID0gdXBkYXRlQ29udGFpbmVyU3luYztcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfSksXG4gIChtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHMpLFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIiQkJGNvbmZpZyIsImZpbmRIb29rIiwiZmliZXIiLCJpZCIsIm1lbW9pemVkU3RhdGUiLCJuZXh0IiwiY29weVdpdGhTZXRJbXBsIiwib2JqIiwicGF0aCIsImluZGV4IiwidmFsdWUiLCJsZW5ndGgiLCJrZXkiLCJ1cGRhdGVkIiwiaXNBcnJheUltcGwiLCJzbGljZSIsImFzc2lnbiIsImNvcHlXaXRoUmVuYW1lIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJjb25zb2xlIiwid2FybiIsImkiLCJjb3B5V2l0aFJlbmFtZUltcGwiLCJvbGRLZXkiLCJzcGxpY2UiLCJjb3B5V2l0aERlbGV0ZUltcGwiLCJzaG91bGRTdXNwZW5kSW1wbCIsInNob3VsZEVycm9ySW1wbCIsImNyZWF0ZUZpYmVyIiwidGFnIiwicGVuZGluZ1Byb3BzIiwibW9kZSIsIkZpYmVyTm9kZSIsInNjaGVkdWxlUm9vdCIsInJvb3QiLCJlbGVtZW50IiwiY29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsInVwZGF0ZUNvbnRhaW5lclN5bmMiLCJmbHVzaFN5bmNXb3JrIiwic2NoZWR1bGVSZWZyZXNoIiwidXBkYXRlIiwicmVzb2x2ZUZhbWlseSIsInN0YWxlRmFtaWxpZXMiLCJ1cGRhdGVkRmFtaWxpZXMiLCJmbHVzaFBlbmRpbmdFZmZlY3RzIiwic2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseSIsImN1cnJlbnQiLCJzZXRSZWZyZXNoSGFuZGxlciIsImhhbmRsZXIiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJlcnJvciIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIm5vb3AiLCJ3YXJuRm9yTWlzc2luZ0tleSIsInNldFRvU29ydGVkU3RyaW5nIiwic2V0IiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsInNvcnQiLCJqb2luIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsInJldHVybiIsImZsYWdzIiwiYXNzZXJ0SXNNb3VudGVkIiwiRXJyb3IiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImEiLCJiIiwicGFyZW50QSIsInBhcmVudEIiLCJjaGlsZCIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJzdGF0ZU5vZGUiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfQUNUSVZJVFlfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIl9jb250ZXh0IiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsImlubmVyVHlwZSIsInJlbmRlciIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIl9wYXlsb2FkIiwiX2luaXQiLCJ4IiwiZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlciIsIl9kZWJ1Z0luZm8iLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJwb3AiLCJjdXJzb3IiLCJpbmRleCRqc2NvbXAkMCIsImZpYmVyU3RhY2siLCJ2YWx1ZVN0YWNrIiwiY2x6MzJGYWxsYmFjayIsImxvZyQxIiwiTE4yIiwiZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMiLCJsYW5lcyIsInBlbmRpbmdTeW5jTGFuZXMiLCJnZXROZXh0TGFuZXMiLCJ3aXBMYW5lcyIsInJvb3RIYXNQZW5kaW5nQ29tbWl0IiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIndhcm1MYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nIiwicmVuZGVyTGFuZXMiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJsYW5lIiwiY3VycmVudFRpbWUiLCJjbGFpbU5leHRSZXRyeUxhbmUiLCJuZXh0UmV0cnlMYW5lIiwiY3JlYXRlTGFuZU1hcCIsImluaXRpYWwiLCJsYW5lTWFwIiwibWFya1Jvb3RVcGRhdGVkJDEiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RGaW5pc2hlZCIsImZpbmlzaGVkTGFuZXMiLCJyZW1haW5pbmdMYW5lcyIsInNwYXduZWRMYW5lIiwidXBkYXRlZExhbmVzIiwic3VzcGVuZGVkUmV0cnlMYW5lcyIsInByZXZpb3VzbHlQZW5kaW5nTGFuZXMiLCJleHBpcmVkTGFuZXMiLCJlbnRhbmdsZWRMYW5lcyIsImVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIiwic2hlbGxTdXNwZW5kQ291bnRlciIsImVudGFuZ2xlbWVudHMiLCJleHBpcmF0aW9uVGltZXMiLCJoaWRkZW5VcGRhdGVzIiwiY2x6MzIiLCJoaWRkZW5VcGRhdGVzRm9yTGFuZSIsIm1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lIiwic3Bhd25lZExhbmVJbmRleCIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmUiLCJnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uQnlMYW5lIiwiYWRkRmliZXJUb0xhbmVzTWFwIiwiaXNEZXZUb29sc1ByZXNlbnQiLCJwZW5kaW5nVXBkYXRlcnNMYW5lTWFwIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJoYXMiLCJjbGVhciIsImxhbmVzVG9FdmVudFByaW9yaXR5IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwicmVuZGVyZXJJRCIsImluamVjdCIsImluamVjdGVkSG9vayIsImVyciIsImNoZWNrRENFIiwic2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMiLCJuZXdJc1N0cmljdE1vZGUiLCJsb2ciLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInNldFN0cmljdE1vZGUiLCJoYXNMb2dnZWRFcnJvciIsImlzIiwieSIsImdldEFycmF5S2luZCIsImtpbmQiLCJhZGRPYmplY3RUb1Byb3BlcnRpZXMiLCJvYmplY3QiLCJwcm9wZXJ0aWVzIiwiaW5kZW50IiwicHJlZml4IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYWRkVmFsdWVUb1Byb3BlcnRpZXMiLCJwcm9wZXJ0eU5hbWUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJ0eXBlTmFtZSIsInByb3BzIiwicHJvcHNLZXlzIiwiT2JqZWN0Iiwia2V5cyIsInByb3BzTGVuZ3RoIiwicmVwZWF0IiwicHJvcEtleSIsImNoaWxkcmVuIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwicmVhc29uIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIlN0cmluZyIsImFkZE9iamVjdERpZmZUb1Byb3BlcnRpZXMiLCJwcmV2IiwiaXNEZWVwbHlFcXVhbCIsIl9rZXkiLCJuZXh0VmFsdWUiLCJwcmV2S2luZCIsIm5leHRLaW5kIiwiRnVuY3Rpb24iLCJzZXRDdXJyZW50VHJhY2tGcm9tTGFuZXMiLCJjdXJyZW50VHJhY2siLCJsb2dDb21wb25lbnRUcmlnZ2VyIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRyaWdnZXIiLCJzdXBwb3J0c1VzZXJUaW1pbmciLCJyZXVzYWJsZUNvbXBvbmVudE9wdGlvbnMiLCJzdGFydCIsImVuZCIsInJldXNhYmxlQ29tcG9uZW50RGV2VG9vbERldGFpbHMiLCJjb2xvciIsInRvb2x0aXBUZXh0IiwiX2RlYnVnVGFzayIsInJ1biIsInBlcmZvcm1hbmNlIiwibWVhc3VyZSIsImJpbmQiLCJsb2dDb21wb25lbnRSZWFwcGVhcmVkIiwibG9nQ29tcG9uZW50UmVuZGVyIiwid2FzSHlkcmF0ZWQiLCJjb21taXR0ZWRMYW5lcyIsInNlbGZUaW1lIiwiYWN0dWFsRHVyYXRpb24iLCJtZW1vaXplZFByb3BzIiwicmVzdWFibGVDaGFuZ2VkUHJvcHNFbnRyeSIsImFscmVhZHlXYXJuZWRGb3JEZWVwRXF1YWxpdHkiLCJyZXVzYWJsZURlZXBseUVxdWFsUHJvcHNFbnRyeSIsInRpbWVTdGFtcCIsImxvZ0NvbXBvbmVudEVycm9yZWQiLCJlcnJvcnMiLCJkZWJ1Z1Rhc2siLCJjYXB0dXJlZFZhbHVlIiwic291cmNlIiwibWVzc2FnZSIsImRldGFpbCIsImRldnRvb2xzIiwidHJhY2siLCJsb2dDb21wb25lbnRFZmZlY3QiLCJsb2dSZW5kZXJQaGFzZSIsImxvZ1N1c3BlbmRlZFJlbmRlclBoYXNlIiwibG9nU3VzcGVuZGVkV2l0aERlbGF5UGhhc2UiLCJsb2dSZWNvdmVyZWRSZW5kZXJQaGFzZSIsInJlY292ZXJhYmxlRXJyb3JzIiwiaHlkcmF0aW9uRmFpbGVkIiwidHJhY2tHcm91cCIsImxvZ0Vycm9yZWRSZW5kZXJQaGFzZSIsImxvZ1N1c3BlbmRlZENvbW1pdFBoYXNlIiwibG9nQ29tbWl0RXJyb3JlZCIsInBhc3NpdmUiLCJkaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsImluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsImdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJncm91cEVuZCIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJmb3JtYXRPd25lclN0YWNrIiwicHJldlByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJzdGFjayIsInN0YXJ0c1dpdGgiLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm1hdGNoIiwidHJpbSIsInN1ZmZpeCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsInJlZW50cnkiLCJmcmFtZSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJnZXQiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIkgiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsIlJlZmxlY3QiLCJjb250cm9sIiwieCQwIiwieCQxIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJpbmNsdWRlcyIsIl9mcmFtZSIsInJlcGxhY2UiLCJkZXNjcmliZUZpYmVyIiwiY2hpbGRGaWJlciIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIndvcmtJblByb2dyZXNzIiwicHJldmlvdXMiLCJkZWJ1Z0luZm8iLCJlbnRyeSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsImVudiIsImxvY2F0aW9uIiwiZGVidWdMb2NhdGlvbiIsImNoaWxkU3RhY2siLCJpZHgiLCJsYXN0TGluZSIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZVdpdGhvdXRMaW5lTnVtYmVyIiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIiLCJleGlzdGluZyIsIkNhcHR1cmVkU3RhY2tzIiwicHVzaFRyZWVGb3JrIiwidG90YWxDaGlsZHJlbiIsIndhcm5JZk5vdEh5ZHJhdGluZyIsImZvcmtTdGFjayIsImZvcmtTdGFja0luZGV4IiwidHJlZUZvcmtDb3VudCIsInRyZWVGb3JrUHJvdmlkZXIiLCJwdXNoVHJlZUlkIiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0SWQiLCJ0cmVlQ29udGV4dE92ZXJmbG93IiwidHJlZUNvbnRleHRQcm92aWRlciIsImJhc2VJZFdpdGhMZWFkaW5nQml0IiwiYmFzZUxlbmd0aCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwicHVzaE1hdGVyaWFsaXplZFRyZWVJZCIsInBvcFRyZWVDb250ZXh0IiwiZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQiLCJvdmVyZmxvdyIsInJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCIsInN1c3BlbmRlZENvbnRleHQiLCJpc0h5ZHJhdGluZyIsInJlcXVpcmVkQ29udGV4dCIsImMiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwiaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciIsIm5leHRDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBvcEhvc3RDb250ZXh0IiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJIb3N0VHJhbnNpdGlvbkNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJfY3VycmVudFZhbHVlMiIsImZpbmROb3RhYmxlTm9kZSIsInNlcnZlclByb3BzIiwic2VydmVyVGFpbCIsImRpc3RhbmNlRnJvbUxlYWYiLCJpbmRlbnRhdGlvbiIsImFkZGVkIiwicmVtb3ZlZCIsImRlc2NyaWJlRmliZXJUeXBlIiwiZGVzY3JpYmVUZXh0Tm9kZSIsImNvbnRlbnQiLCJtYXhMZW5ndGgiLCJuZWVkc0VzY2FwaW5nIiwidGVzdCIsImRlc2NyaWJlVGV4dERpZmYiLCJjbGllbnRUZXh0IiwiZmlyc3REaWZmIiwiY2hhckNvZGVBdCIsIm9iamVjdE5hbWUiLCJtIiwicDAiLCJkZXNjcmliZVZhbHVlIiwicHJvcE5hbWUiLCJqc29uUHJvcE5hbWUiLCJkZXNjcmliZVByb3BWYWx1ZSIsImRlc2NyaWJlRXhwYW5kZWRFbGVtZW50Iiwicm93UHJlZml4IiwicmVtYWluaW5nUm93TGVuZ3RoIiwicHJvcFZhbHVlIiwiZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZiIsImNsaWVudE9iamVjdCIsInNlcnZlck9iamVjdCIsInJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMiLCJjbGllbnRQcm9wVmFsdWUiLCJfcHJvcE5hbWUiLCJkZXNjcmliZUVsZW1lbnREaWZmIiwiY2xpZW50UHJvcHMiLCJzZXJ2ZXJQcm9wTmFtZXMiLCJNYXAiLCJwcm9wTmFtZSRqc2NvbXAkMCIsInRvTG93ZXJDYXNlIiwiX3Byb3BOYW1lMiIsIm1heExlbmd0aCRqc2NvbXAkMCIsInNlcnZlclByb3BOYW1lIiwiZGVsZXRlIiwiZGVzY3JpYmVTaWJsaW5nRmliZXIiLCJkZXNjcmliZU5vZGUiLCJza2lwVG9Ob2RlIiwic2VydmVyQ29tcG9uZW50TmFtZSIsImRlc2NyaWJlRGlmZiIsInJvb3ROb2RlIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsIl9kZWJ1Z093bmVyIiwiZGVidWdTdGFjayIsIl9kZWJ1Z1N0YWNrIiwiZm9ybWF0dGVkU3RhY2siLCJvd25lclN0YWNrIiwib3duZXIiLCJydW5XaXRoRmliZXJJbkRFViIsImNhbGxiYWNrIiwiYXJnMCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJwcmV2aW91c0ZpYmVyIiwic2V0Q3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudFN0YWNrIiwiaXNSZW5kZXJpbmciLCJidWlsZEh5ZHJhdGlvbkRpZmZOb2RlIiwiaHlkcmF0aW9uRGlmZlJvb3RERVYiLCJzaWJsaW5ncyIsIndhcm5JZkh5ZHJhdGluZyIsIndhcm5Ob25IeWRyYXRlZEluc3RhbmNlIiwicmVqZWN0ZWRDYW5kaWRhdGUiLCJkaWRTdXNwZW5kT3JFcnJvckRFViIsImRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MiLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJmcm9tVGV4dCIsImFyZ3VtZW50cyIsImRpZmYiLCJkaWZmUm9vdCIsInF1ZXVlSHlkcmF0aW9uRXJyb3IiLCJIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJob3N0Q29udGV4dCIsInN1cHBvcnRzSHlkcmF0aW9uIiwiaHlkcmF0ZUluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwicm9vdE9yU2luZ2xldG9uQ29udGV4dCIsInBvcEh5ZHJhdGlvblN0YXRlIiwic3VwcG9ydHNTaW5nbGV0b25zIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJ3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzIiwiZGVoeWRyYXRlZCIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJBY3Rpdml0eUluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nQWZ0ZXJTaW5nbGV0b24iLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJuZXh0SW5zdGFuY2UiLCJkaWZmTm9kZSIsImRlc2NyaXB0aW9uIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsInVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlIiwicXVldWVkRXJyb3JzIiwiaHlkcmF0aW9uRXJyb3JzIiwid29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMiLCJhcHBseSIsImVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MiLCJyZXNldENvbnRleHREZXBlbmRlbmNpZXMiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIiwiaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInB1c2hQcm92aWRlciIsInByb3ZpZGVyRmliZXIiLCJ2YWx1ZUN1cnNvciIsInJlbmRlcmVyQ3Vyc29yREVWIiwiX2N1cnJlbnRSZW5kZXJlciIsInJlbmRlcmVyU2lnaWwiLCJyZW5kZXJlcjJDdXJzb3JERVYiLCJfY3VycmVudFJlbmRlcmVyMiIsInBvcFByb3ZpZGVyIiwiY3VycmVudFZhbHVlIiwic2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aCIsInByb3BhZ2F0aW9uUm9vdCIsImNoaWxkTGFuZXMiLCJwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyIsImNvbnRleHRzIiwiZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIiwibGlzdCIsImRlcGVuZGVuY2llcyIsIm5leHRGaWJlciIsImZpcnN0Q29udGV4dCIsImRlcGVuZGVuY3kiLCJwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyIsImlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0IiwiY3VycmVudFBhcmVudCIsIm9iamVjdElzIiwiY2hlY2tJZkNvbnRleHRDaGFuZ2VkIiwiY3VycmVudERlcGVuZGVuY2llcyIsIm1lbW9pemVkVmFsdWUiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsInJlYWRDb250ZXh0IiwicmVhZENvbnRleHRGb3JDb25zdW1lciIsInJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24iLCJjb25zdW1lciIsIl9kZWJ1Z1RoZW5hYmxlU3RhdGUiLCJjcmVhdGVDYWNoZSIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXJMb2NhbCIsImRhdGEiLCJyZWZDb3VudCIsInJldGFpbkNhY2hlIiwiY2FjaGUiLCJzaWduYWwiLCJhYm9ydGVkIiwicmVsZWFzZUNhY2hlIiwic2NoZWR1bGVDYWxsYmFjayQyIiwiTm9ybWFsUHJpb3JpdHkiLCJhYm9ydCIsInN0YXJ0VXBkYXRlVGltZXJCeUxhbmUiLCJtZXRob2QiLCJibG9ja2luZ1VwZGF0ZVRpbWUiLCJub3ciLCJibG9ja2luZ1VwZGF0ZVRhc2siLCJjcmVhdGVUYXNrIiwiYmxvY2tpbmdVcGRhdGVNZXRob2ROYW1lIiwiYmxvY2tpbmdVcGRhdGVDb21wb25lbnROYW1lIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwiY29tcG9uZW50RWZmZWN0U3Bhd25lZFVwZGF0ZSIsImJsb2NraW5nVXBkYXRlVHlwZSIsInJlc29sdmVFdmVudFRpbWVTdGFtcCIsInJlc29sdmVFdmVudFR5cGUiLCJibG9ja2luZ0V2ZW50UmVwZWF0VGltZSIsImJsb2NraW5nRXZlbnRUeXBlIiwiYmxvY2tpbmdFdmVudFRpbWUiLCJ0cmFuc2l0aW9uVXBkYXRlVGltZSIsInRyYW5zaXRpb25VcGRhdGVUYXNrIiwidHJhbnNpdGlvblVwZGF0ZU1ldGhvZE5hbWUiLCJ0cmFuc2l0aW9uVXBkYXRlQ29tcG9uZW50TmFtZSIsInRyYW5zaXRpb25TdGFydFRpbWUiLCJ0cmFuc2l0aW9uRXZlbnRSZXBlYXRUaW1lIiwidHJhbnNpdGlvbkV2ZW50VHlwZSIsInRyYW5zaXRpb25FdmVudFRpbWUiLCJzdGFydEhvc3RBY3Rpb25UaW1lciIsIm5ld0V2ZW50VGltZSIsIm5ld0V2ZW50VHlwZSIsInB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJwcmV2RWZmZWN0RHVyYXRpb24iLCJwcm9maWxlckVmZmVjdER1cmF0aW9uIiwicG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwiZWxhcHNlZFRpbWUiLCJidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJyZXNldENvbXBvbmVudEVmZmVjdFRpbWVycyIsImNvbXBvbmVudEVmZmVjdEVuZFRpbWUiLCJjb21wb25lbnRFZmZlY3RTdGFydFRpbWUiLCJwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQiLCJwcmV2RWZmZWN0U3RhcnQiLCJwb3BDb21wb25lbnRFZmZlY3RTdGFydCIsInB1c2hDb21wb25lbnRFZmZlY3REdXJhdGlvbiIsImNvbXBvbmVudEVmZmVjdER1cmF0aW9uIiwicG9wQ29tcG9uZW50RWZmZWN0RHVyYXRpb24iLCJwdXNoQ29tcG9uZW50RWZmZWN0RXJyb3JzIiwicHJldkVycm9ycyIsImNvbXBvbmVudEVmZmVjdEVycm9ycyIsInB1c2hDb21wb25lbnRFZmZlY3REaWRTcGF3blVwZGF0ZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsInByb2ZpbGVyU3RhcnRUaW1lIiwiYWN0dWFsU3RhcnRUaW1lIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbiIsInNlbGZCYXNlRHVyYXRpb24iLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbiIsInJlY29yZEVmZmVjdER1cmF0aW9uIiwicmVjb3JkRWZmZWN0RXJyb3IiLCJlcnJvckluZm8iLCJjb21taXRFcnJvcnMiLCJzdGFydEVmZmVjdFRpbWVyIiwidHJhbnNmZXJBY3R1YWxEdXJhdGlvbiIsIm5vb3AkMSIsImVuc3VyZVJvb3RJc1NjaGVkdWxlZCIsImxhc3RTY2hlZHVsZWRSb290IiwiZmlyc3RTY2hlZHVsZWRSb290IiwibWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrIiwiYWN0UXVldWUiLCJkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QiLCJzY2hlZHVsZUltbWVkaWF0ZVJvb3RTY2hlZHVsZVRhc2siLCJkaWRTY2hlZHVsZU1pY3JvdGFzayIsImZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsIiwic3luY1RyYW5zaXRpb25MYW5lcyIsIm9ubHlMZWdhY3kiLCJpc0ZsdXNoaW5nV29yayIsImRpZFBlcmZvcm1Tb21lV29yayIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290IiwiY2FuY2VsUGVuZGluZ0NvbW1pdCIsInRpbWVvdXRIYW5kbGUiLCJub1RpbWVvdXQiLCJwcm9jZXNzUm9vdFNjaGVkdWxlSW5JbW1lZGlhdGVUYXNrIiwidHJhY2tTY2hlZHVsZXJFdmVudCIsInByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzayIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwic2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbiIsIm5vdyQxIiwic2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayIsInBlbmRpbmdFZmZlY3RzU3RhdHVzIiwiTk9fUEVORElOR19FRkZFQ1RTIiwiUEVORElOR19QQVNTSVZFX1BIQVNFIiwiZXhwaXJhdGlvblRpbWUiLCJjYWxsYmFja05vZGUiLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiIsIlN1c3BlbmRlZE9uRGF0YSIsIlN1c3BlbmRlZE9uQWN0aW9uIiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja1ByaW9yaXR5IiwiZmFrZUFjdENhbGxiYWNrTm9kZSQxIiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSQxIiwiSWRsZVByaW9yaXR5IiwicGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrIiwic2NoZWR1bGVDYWxsYmFjayQzIiwiZGlkVGltZW91dCIsIm5lc3RlZFVwZGF0ZVNjaGVkdWxlZCIsImN1cnJlbnRVcGRhdGVJc05lc3RlZCIsIm9yaWdpbmFsQ2FsbGJhY2tOb2RlIiwicGVuZGluZ0RlbGF5ZWRDb21taXRSZWFzb24iLCJJTU1FRElBVEVfQ09NTUlUIiwiREVMQVlFRF9QQVNTSVZFX0NPTU1JVCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIiwicGVyZm9ybVdvcmtPblJvb3QiLCJjYW5jZWxDYWxsYmFjayQxIiwic3VwcG9ydHNNaWNyb3Rhc2tzIiwic2NoZWR1bGVNaWNyb3Rhc2siLCJleGVjdXRpb25Db250ZXh0IiwiUmVuZGVyQ29udGV4dCIsIkNvbW1pdENvbnRleHQiLCJOb0NvbnRleHQiLCJJbW1lZGlhdGVQcmlvcml0eSIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsImFjdGlvblNjb3BlTGFuZSIsImN1cnJlbnRFbnRhbmdsZWRMYW5lIiwibmV4dFRyYW5zaXRpb25VcGRhdGVMYW5lIiwiZW50YW5nbGVBc3luY0FjdGlvbiIsInRyYW5zaXRpb24iLCJ0aGVuYWJsZSIsImN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMiLCJlbnRhbmdsZWRMaXN0ZW5lcnMiLCJjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50IiwiY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwidGhlbiIsInJlc29sdmUiLCJwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlIiwibGlzdGVuZXJzIiwiY2hhaW5UaGVuYWJsZVZhbHVlIiwicmVzdWx0IiwidGhlbmFibGVXaXRoT3ZlcnJpZGUiLCJwZWVrQ2FjaGVGcm9tUG9vbCIsImNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciIsInJlc3VtZWRDYWNoZSIsInBvb2xlZENhY2hlIiwicHVzaFRyYW5zaXRpb24iLCJvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyIsInByZXZDYWNoZVBvb2wiLCJwb29sIiwiZ2V0U3VzcGVuZGVkQ2FjaGUiLCJjYWNoZUZyb21Qb29sIiwiQ2FjaGVDb250ZXh0Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiY3VycmVudEtleSIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UiLCJ0aGVuYWJsZXMiLCJpc1RoZW5hYmxlUmVzb2x2ZWQiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJkaWRVc2VQcm9taXNlIiwidHJhY2tlZFRoZW5hYmxlcyIsImlvSW5mbyIsImF3YWl0ZWQiLCJjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCIsImZ1bGZpbGxlZFZhbHVlIiwiZnVsZmlsbGVkVGhlbmFibGUiLCJyZWplY3RlZFRoZW5hYmxlIiwic3VzcGVuZGVkVGhlbmFibGUiLCJuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViIsIlN1c3BlbnNlRXhjZXB0aW9uIiwicmVzb2x2ZUxhenkiLCJsYXp5VHlwZSIsImNhbGxMYXp5SW5pdEluREVWIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJyZWplY3RlZFJlYXNvbiIsIlN1c3BlbnNlQWN0aW9uRXhjZXB0aW9uIiwicHVzaERlYnVnSW5mbyIsInByZXZpb3VzRGVidWdJbmZvIiwiY3VycmVudERlYnVnSW5mbyIsImNvbmNhdCIsImdldEN1cnJlbnREZWJ1Z1Rhc2siLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJyZXR1cm5GaWJlciIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJlcnJvcmVkS2V5IiwidW53cmFwVGhlbmFibGUiLCJ0aGVuYWJsZUluZGV4Q291bnRlciQxIiwidGhlbmFibGVTdGF0ZSQxIiwiY29lcmNlUmVmIiwicmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlSW1wbCIsIm5ld0NoaWxkIiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIndhcm5PbkZ1bmN0aW9uVHlwZUltcGwiLCJpbnZhbGlkQ2hpbGQiLCJwYXJlbnROYW1lIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwid2Fybk9uU3ltYm9sVHlwZUltcGwiLCJvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nIiwid2Fybk9uU3ltYm9sVHlwZSIsImNyZWF0ZUNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGlvbnMiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwidGV4dENvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwidXBkYXRlRWxlbWVudCIsImVsZW1lbnRUeXBlIiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJfb3duZXIiLCJ1cGRhdGVQb3J0YWwiLCJwb3J0YWwiLCJjb250YWluZXJJbmZvIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfcHJldkRlYnVnSW5mbyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJfcHJldkRlYnVnSW5mbzciLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwiU2V0IiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwic3RlcCIsImRvbmUiLCJyZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwiLCJwcmV2RGVidWdJbmZvIiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsImVudHJpZXMiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZmlyc3RDaGlsZEZpYmVyIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMiLCJlbmRJbmRleCIsImNvbmN1cnJlbnRRdWV1ZXNJbmRleCIsImNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyIsImNvbmN1cnJlbnRRdWV1ZXMiLCJxdWV1ZSIsInBlbmRpbmciLCJtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsImVucXVldWVVcGRhdGUkMSIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZSIsImdldFJvb3RGb3JVcGRhdGVkRmliZXIiLCJlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUiLCJzb3VyY2VGaWJlciIsImlzSGlkZGVuIiwiX3Zpc2liaWxpdHkiLCJPZmZzY3JlZW5WaXNpYmxlIiwibmVzdGVkVXBkYXRlQ291bnQiLCJORVNURURfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Iiwicm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsIk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJ1cGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwiaGlkZGVuQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiY2xvbmVVcGRhdGVRdWV1ZSIsImNyZWF0ZVVwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwicGF5bG9hZCIsImVucXVldWVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY29tcG9uZW50TmFtZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJjbG9uZSIsInN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJpbnN0YW5jZSRqc2NvbXAkMCIsImhhc0ZvcmNlVXBkYXRlIiwicGVuZGluZ1F1ZXVlIiwibGFzdFBlbmRpbmdVcGRhdGUiLCJmaXJzdFBlbmRpbmdVcGRhdGUiLCJuZXdTdGF0ZSIsImlzSGlkZGVuVXBkYXRlIiwicGFydGlhbFN0YXRlIiwibmV4dFByb3BzIiwiaW5zdGFuY2UiLCJSZXBsYWNlU3RhdGUiLCJuZXh0U3RhdGUiLCJDYXB0dXJlVXBkYXRlIiwiRm9yY2VVcGRhdGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMiLCJjYWxsQ2FsbGJhY2siLCJjb21taXRIaWRkZW5DYWxsYmFja3MiLCJjb21taXRDYWxsYmFja3MiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yIiwiY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciIsImJhc2VMYW5lcyIsInJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2siLCJwb3BIaWRkZW5Db250ZXh0IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwic3VzcGVuc2VTdGFja0N1cnNvciIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwic3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IiLCJzaGVsbEJvdW5kYXJ5IiwicHVzaERlaHlkcmF0ZWRBY3Rpdml0eVN1c3BlbnNlSGFuZGxlciIsInB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIiLCJyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2siLCJwb3BTdXNwZW5zZUhhbmRsZXIiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJzdGF0ZSIsImlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmciLCJpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayIsInJldmVhbE9yZGVyIiwibW91bnRIb29rVHlwZXNEZXYiLCJob29rTmFtZSIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwidXBkYXRlSG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciIsImRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCIsInRhYmxlIiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsIndhcm5PblVzZUZvcm1TdGF0ZUluRGV2IiwiZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsImlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzIiwicmVuZGVyV2l0aEhvb2tzIiwiQ29tcG9uZW50Iiwic2Vjb25kQXJnIiwibmV4dFJlbmRlckxhbmVzIiwiX2RlYnVnSG9va1R5cGVzIiwiZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsInNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWIiwiTm9Nb2RlIiwiY2FsbENvbXBvbmVudEluREVWIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzIiwicmVuZGVyV2l0aEhvb2tzQWdhaW4iLCJmaW5pc2hSZW5kZXJpbmdIb29rcyIsIkNvbnRleHRPbmx5RGlzcGF0Y2hlciIsImRpZFJlbmRlclRvb0Zld0hvb2tzIiwiY3VycmVudEhvb2siLCJ3b3JrSW5Qcm9ncmVzc0hvb2siLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJkaWRSZWNlaXZlVXBkYXRlIiwiZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2giLCJudW1iZXJPZlJlUmVuZGVycyIsIlJFX1JFTkRFUl9MSU1JVCIsImxhc3RFZmZlY3QiLCJldmVudHMiLCJzdG9yZXMiLCJtZW1vQ2FjaGUiLCJIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50IiwiZGlzcGF0Y2hlciIsIm1heWJlVGhlbmFibGUiLCJ1c2VTdGF0ZSIsInVzZVRoZW5hYmxlIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJsb2NhbElkQ291bnRlciIsImJhaWxvdXRIb29rcyIsInJlc2V0SG9va3NPblVud2luZCIsIm1vdW50V29ya0luUHJvZ3Jlc3NIb29rIiwiYmFzZVF1ZXVlIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwibmV4dEN1cnJlbnRIb29rIiwibmV4dFdvcmtJblByb2dyZXNzSG9vayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJ1c2UiLCJ1c2FibGUiLCJ1c2VNZW1vQ2FjaGUiLCJtYXAiLCJBcnJheSIsIlJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwiLCJiYXNpY1N0YXRlUmVkdWNlciIsImFjdGlvbiIsIm1vdW50UmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiaW5pdCIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsInVwZGF0ZVJlZHVjZXJJbXBsIiwiYmFzZUZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwicmV2ZXJ0TGFuZSIsImdlc3R1cmUiLCJoYXNFYWdlclN0YXRlIiwiZWFnZXJTdGF0ZSIsInJlcmVuZGVyUmVkdWNlciIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsIm1vdW50U3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaFNpbXBsZUVmZmVjdCIsIkhhc0VmZmVjdCIsIlBhc3NpdmUiLCJkZXN0cm95IiwidXBkYXRlU3RvcmVJbnN0YW5jZSIsInVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlIiwiaXNIeWRyYXRpbmckanNjb21wJDAiLCJjYWNoZWRTbmFwc2hvdCIsImNyZWF0ZSIsInVwZGF0ZUVmZmVjdEltcGwiLCJyZW5kZXJlZFNuYXBzaG90IiwiaW5zdCIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJmb3JjZVN0b3JlUmVyZW5kZXIiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsIm1vdW50U3RhdGVJbXBsIiwiaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsIm1vdW50T3B0aW1pc3RpYyIsInBhc3N0aHJvdWdoIiwiZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUiLCJ1cGRhdGVPcHRpbWlzdGljIiwidXBkYXRlT3B0aW1pc3RpY0ltcGwiLCJyZXJlbmRlck9wdGltaXN0aWMiLCJkaXNwYXRjaEFjdGlvblN0YXRlIiwiYWN0aW9uUXVldWUiLCJzZXRQZW5kaW5nU3RhdGUiLCJzZXRTdGF0ZSIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJhY3Rpb25Ob2RlIiwiaXNUcmFuc2l0aW9uIiwibGlzdGVuZXIiLCJUIiwicnVuQWN0aW9uU3RhdGVBY3Rpb24iLCJwcmV2U3RhdGUiLCJwcmV2VHJhbnNpdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJyZXR1cm5WYWx1ZSIsIm9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwiUyIsImhhbmRsZUFjdGlvblJldHVyblZhbHVlIiwib25BY3Rpb25FcnJvciIsInR5cGVzIiwiZXJyb3IkMiIsImFzeW5jVHJhbnNpdGlvbnMiLCJyZWxlYXNlQXN5bmNUcmFuc2l0aW9uIiwib25BY3Rpb25TdWNjZXNzIiwibm90aWZ5QWN0aW9uTGlzdGVuZXJzIiwibGFzdCIsImFjdGlvblN0YXRlUmVkdWNlciIsIm9sZFN0YXRlIiwibW91bnRBY3Rpb25TdGF0ZSIsImluaXRpYWxTdGF0ZVByb3AiLCJzc3JGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJpc01hdGNoaW5nIiwibWFya2VySW5zdGFuY2UiLCJjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyIiwiaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyIsInVwZGF0ZUFjdGlvblN0YXRlIiwic3RhdGVIb29rIiwidXBkYXRlQWN0aW9uU3RhdGVJbXBsIiwiY3VycmVudFN0YXRlSG9vayIsImFjdGlvblN0YXRlQWN0aW9uRWZmZWN0IiwicmVyZW5kZXJBY3Rpb25TdGF0ZSIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwibW91bnRFZmZlY3RJbXBsIiwiZmliZXJGbGFncyIsImhvb2tGbGFncyIsInVzZUVmZmVjdEV2ZW50SW1wbCIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwibW91bnRFdmVudCIsImltcGwiLCJ1cGRhdGVFdmVudCIsIm5leHRJbXBsIiwibW91bnRMYXlvdXRFZmZlY3QiLCJMYXlvdXQiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2xlYW51cCIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsIm1vdW50RGVmZXJyZWRWYWx1ZUltcGwiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwidXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwiLCJyZXJlbmRlckRlZmVycmVkVmFsdWUiLCJyZXF1ZXN0RGVmZXJyZWRMYW5lIiwicHJldlZhbHVlIiwic3RhcnRUcmFuc2l0aW9uIiwicGVuZGluZ1N0YXRlIiwiZmluaXNoZWRTdGF0ZSIsInByZXZpb3VzUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJ0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUiLCJkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsImVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsIiwiZm9ybUZpYmVyIiwiZXhpc3RpbmdTdGF0ZUhvb2siLCJpbml0aWFsUmVzZXRTdGF0ZSIsIm1vdW50VHJhbnNpdGlvbiIsInVwZGF0ZVRyYW5zaXRpb24iLCJib29sZWFuT3JUaGVuYWJsZSIsInJlcmVuZGVyVHJhbnNpdGlvbiIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJpZFdpdGhMZWFkaW5nQml0IiwiZ2xvYmFsQ2xpZW50SWRDb3VudGVyIiwibW91bnRSZWZyZXNoIiwicmVmcmVzaENhY2hlIiwic2VlZEtleSIsInByb3ZpZGVyIiwicmVmcmVzaFVwZGF0ZSIsImFyZ3MiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJwcmV2RGlzcGF0Y2hlciIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiY3VycmVudFN0YXRlIiwidGhyb3dJZkR1cmluZ1JlbmRlciIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY3RvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwicmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMiLCJiYXNlUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJsb2dVbmNhdWdodEVycm9yIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ0aHJvd25FcnJvcnMiLCJvblVuY2F1Z2h0RXJyb3IiLCJjb21wb25lbnRTdGFjayIsImUiLCJzZXRUaW1lb3V0IiwibG9nQ2F1Z2h0RXJyb3IiLCJib3VuZGFyeSIsIm9uQ2F1Z2h0RXJyb3IiLCJlcnJvckJvdW5kYXJ5IiwiY3JlYXRlUm9vdEVycm9yVXBkYXRlIiwiY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSIsImluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsImxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIiwiY2FsbENvbXBvbmVudERpZENhdGNoSW5ERVYiLCJ0aHJvd0V4Y2VwdGlvbiIsInJvb3RSZW5kZXJMYW5lcyIsInJlc3RvcmVQZW5kaW5nVXBkYXRlcnMiLCJyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIlJvb3RJblByb2dyZXNzIiwiUm9vdFN1c3BlbmRlZCIsIm5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSIsImF0dGFjaFBpbmdMaXN0ZW5lciIsInRyYW5zaXRpb25zIiwibWFya2VySW5zdGFuY2VzIiwicmV0cnlRdWV1ZSIsImNhdXNlIiwiUm9vdFN1c3BlbmRlZFdpdGhEZWxheSIsIlJvb3RFcnJvcmVkIiwid29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibW91bnRDaGlsZEZpYmVycyIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwidXBkYXRlRm9yd2FyZFJlZiIsInByb3BzV2l0aG91dFJlZiIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50Iiwic2hvdWxkQ29uc3RydWN0IiwiY29tcGFyZSIsInJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMiLCJjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsInByZXZQcm9wcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwiX3BlbmRpbmdNYXJrZXJzIiwiX3JldHJ5Q2FjaGUiLCJfdHJhbnNpdGlvbnMiLCJkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudCIsImNhY2hlUG9vbCIsImJhaWxvdXRPZmZzY3JlZW5Db21wb25lbnQiLCJuZXh0QmFzZUxhbmVzIiwicmVtYWluaW5nQ2hpbGRMYW5lcyIsIm1vdW50QWN0aXZpdHlDaGlsZHJlbiIsImhpZGRlblByb3AiLCJoaWRkZW4iLCJtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJyZXRyeUFjdGl2aXR5Q29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsInVwZGF0ZUFjdGl2aXR5Q29tcG9uZW50IiwiZGlkU3VzcGVuZCIsImNhbkh5ZHJhdGVBY3Rpdml0eUluc3RhbmNlIiwidHJlZUNvbnRleHQiLCJyZXRyeUxhbmUiLCJjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQiLCJhY3Rpdml0eUluc3RhbmNlIiwibWFya1JlbmRlckRlcml2ZWRDYXVzZSIsIlNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQWN0aXZpdHlJbnN0YW5jZSIsIm1hcmtSZWYiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJjb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMiLCJyZXBsYXlGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZUNsYXNzQ29tcG9uZW50IiwiX2luc3RhbmNlIiwidXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsImNvbnRleHRUeXBlIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiX3JlYWN0SW50ZXJuYWxzIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJuZXdBcGlOYW1lIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsInJlZnMiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwiY29tcG9uZW50RGlkTW91bnQiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJvbGRDb250ZXh0IiwiY2FsbFJlbmRlckluREVWIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsIm1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwicHJpbWFyeVRyZWVEaWREZWZlciIsIndvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG93RmFsbGJhY2siLCJKU0NvbXBpbGVyX3RlbXAiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsIm5leHRQcmltYXJ5Q2hpbGRyZW4iLCJmYWxsYmFjayIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwicmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmciLCJnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMiLCJkaWdlc3QiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJzdWJ0cmVlRmxhZ3MiLCJwcmltYXJ5Q2hpbGRyZW4iLCJvZmZzY3JlZW5Qcm9wcyIsInNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlciIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsImlzQmFja3dhcmRzIiwidGFpbCIsImxhc3RDb250ZW50Um93IiwidGFpbE1vZGUiLCJyZW5kZXJTdGF0ZSIsInJlbmRlcmluZyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInN1c3BlbnNlQ29udGV4dCIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJfaSIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwiZWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJkaWRTdXNwZW5kQmVmb3JlIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwicHJldlNpYmxpbmciLCJyZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyIsImlzRGVoeWRyYXRlZCIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyIiwic3VwcG9ydHNSZXNvdXJjZXMiLCJnZXRSZXNvdXJjZSIsImNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlIiwicmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlIiwiZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU2luZ2xldG9uIiwidmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsInZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciIsInBvb2xlZENhY2hlTGFuZXMiLCJtYXJrVXBkYXRlIiwibWFya0Nsb25lZCIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJkb2VzUmVxdWlyZUNsb25lIiwiY29tcGxldGVkV29yayIsImFwcGVuZEFsbENoaWxkcmVuIiwibmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwic3VwcG9ydHNNdXRhdGlvbiIsImFwcGVuZEluaXRpYWxDaGlsZCIsIl9ub2RlIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lSGlkZGVuVGV4dEluc3RhbmNlIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwiaGFzT2Zmc2NyZWVuQ29tcG9uZW50Q2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwiY3VycmVudEluc3RhbmNlIiwiX29sZFByb3BzIiwiY3VycmVudEhvc3RDb250ZXh0IiwiY2xvbmVJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkIiwibWF5U3VzcGVuZENvbW1pdCIsIm1heVN1c3BlbmRDb21taXRPblVwZGF0ZSIsIm1heVN1c3BlbmRDb21taXRJblN5bmNSZW5kZXIiLCJwcmVsb2FkSW5zdGFuY2UiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwiU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwicmVzb3VyY2UiLCJtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQiLCJwcmVsb2FkUmVzb3VyY2UiLCJzY2hlZHVsZVJldHJ5RWZmZWN0Iiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwiaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIiwibGFzdFRhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJkaWRCYWlsb3V0IiwibmV3Q2hpbGRMYW5lcyIsIl90cmVlQmFzZUR1cmF0aW9uIiwiX2NoaWxkMiIsInRyZWVCYXNlRHVyYXRpb24iLCJjb21wbGV0ZVdvcmsiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRSZXNvdXJjZSIsImZpbmFsaXplSHlkcmF0ZWRDaGlsZHJlbiIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoeWRyYXRlQWN0aXZpdHlJbnN0YW5jZSIsImh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicmVzZXRXb3JrSW5Qcm9ncmVzcyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJ1bndpbmRXb3JrIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwic2hvdWxkUHJvZmlsZSIsImNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzIiwiZmluaXNoZWRXb3JrIiwiY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCIsImNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQiLCJmaXJzdEVmZmVjdCIsIkluc2VydGlvbiIsIk5vRmxhZ3MiLCJpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJjYWxsQ3JlYXRlSW5ERVYiLCJhZGRlbmR1bSIsIm4iLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvciIsImNhbGxEZXN0cm95SW5ERVYiLCJjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMiLCJjb21taXRDbGFzc1NuYXBzaG90IiwicmVzb2x2ZWRQcmV2UHJvcHMiLCJzbmFwc2hvdCIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViIsImNvbW1pdEF0dGFjaFJlZiIsImluc3RhbmNlVG9Vc2UiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInNhZmVseUF0dGFjaFJlZiIsInNhZmVseURldGFjaFJlZiIsImVycm9yJDMiLCJjb21taXRQcm9maWxlciIsImNvbW1pdFN0YXJ0VGltZSIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZSIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uUG9zdENvbW1pdCIsImNvbW1pdEhvc3RNb3VudCIsImNvbW1pdE1vdW50IiwiY29tbWl0SG9zdFVwZGF0ZSIsImNvbW1pdFVwZGF0ZSIsImlzSG9zdFBhcmVudCIsImlzU2luZ2xldG9uU2NvcGUiLCJnZXRIb3N0U2libGluZyIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJiZWZvcmUiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImNvbW1pdFBsYWNlbWVudCIsImhvc3RQYXJlbnRGaWJlciIsInBhcmVudEZpYmVyIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbiIsInJlcGxhY2VDb250YWluZXJDaGlsZHJlbiIsImNvbW1pdEhvc3RTaW5nbGV0b25BY3F1aXNpdGlvbiIsInNpbmdsZXRvbiIsImFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSIsImlzSHlkcmF0aW5nUGFyZW50IiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzIiwiZmlyc3RDaGlsZCIsInByZXBhcmVGb3JDb21taXQiLCJuZXh0RWZmZWN0IiwiY2xlYXJDb250YWluZXIiLCJjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyIiwiZmluaXNoZWRSb290IiwicHJldkVmZmVjdEVycm9ycyIsInByZXZFZmZlY3REaWRTcGF3blVwZGF0ZSIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzIiwiY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYiLCJjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYiLCJjb21taXRIeWRyYXRlZEluc3RhbmNlIiwiY29tbWl0QWN0aXZpdHlIeWRyYXRpb25DYWxsYmFja3MiLCJjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMiLCJkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMiLCJjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyIiwiZGVsZXRlZEZpYmVyIiwib25Db21taXRGaWJlclVubW91bnQiLCJyZWxlYXNlUmVzb3VyY2UiLCJ1bm1vdW50SG9pc3RhYmxlIiwicHJldkhvc3RQYXJlbnQiLCJob3N0UGFyZW50IiwicHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsImhvc3RQYXJlbnRJc0NvbnRhaW5lciIsInJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlbW92ZUNoaWxkIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY29tbWl0SHlkcmF0ZWRBY3Rpdml0eUluc3RhbmNlIiwiY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwiZ2V0UmV0cnlDYWNoZSIsInJldHJ5Q2FjaGUiLCJQb3NzaWJseVdlYWtTZXQiLCJhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzIiwid2FrZWFibGVzIiwid2FrZWFibGUiLCJpblByb2dyZXNzTGFuZXMiLCJpblByb2dyZXNzUm9vdCIsInJldHJ5IiwicmVzb2x2ZVJldHJ5V2FrZWFibGUiLCJyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzIiwicm9vdCRqc2NvbXAkMCIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMiLCJob2lzdGFibGVSb290IiwiY3VycmVudEhvaXN0YWJsZVJvb3QiLCJoeWRyYXRlSG9pc3RhYmxlIiwibW91bnRIb2lzdGFibGUiLCJhY3F1aXJlUmVzb3VyY2UiLCJuZWVkc0Zvcm1SZXNldCIsImNvbW1pdFRleHRVcGRhdGUiLCJwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzIiwicHJldmlvdXNIb2lzdGFibGVSb290IiwiZ2V0SG9pc3RhYmxlUm9vdCIsImNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyIiwicmVjdXJzaXZlbHlSZXNldEZvcm1zIiwiZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSIsIndhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsImhpZGVJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsImhpZGVEZWh5ZHJhdGVkQm91bmRhcnkiLCJ1bmhpZGVEZWh5ZHJhdGVkQm91bmRhcnkiLCJyZXNldEZvcm1JbnN0YW5jZSIsImRpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZWFwcGVhckxheW91dEVmZmVjdHMiLCJpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzIiwiY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyIsInByZXZpb3VzQ2FjaGUiLCJjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0dGVkVHJhbnNpdGlvbnMiLCJuZXh0U2libGluZyIsImNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIiLCJwcmV2RGVlcEVxdWFsaXR5IiwiaW5IeWRyYXRlZFN1YnRyZWUiLCJwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbiIsIndhc0luSHlkcmF0ZWRTdWJ0cmVlIiwiT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQiLCJyZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJyZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyIsIl9pbnN0YW5jZTIiLCJmaW5pc2hlZFJvb3QkanNjb21wJDAiLCJjb21taXR0ZWRMYW5lcyRqc2NvbXAkMCIsImNvbW1pdHRlZFRyYW5zaXRpb25zJGpzY29tcCQwIiwiZW5kVGltZSRqc2NvbXAkMCIsInJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdCIsInN1c3BlbmRlZFN0YXRlIiwic3VzcGVuc2V5Q29tbWl0RmxhZyIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwic3VzcGVuZFJlc291cmNlIiwic3VzcGVuZEluc3RhbmNlIiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbiIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IkanNjb21wJDAiLCJmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QiLCJob3N0Um9vdCIsIm1heWJlRmliZXIiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZmluZEZpYmVyUm9vdCIsIm1hdGNoU2VsZWN0b3IiLCJmaWJlciRqc2NvbXAkMCIsInNlbGVjdG9yIiwiQ09NUE9ORU5UX1RZUEUiLCJIQVNfUFNFVURPX0NMQVNTX1RZUEUiLCJ0YWckanNjb21wJDAiLCJzZWxlY3RvckluZGV4Iiwic2VsZWN0b3IkanNjb21wJDAiLCJpc0hpZGRlblN1YnRyZWUiLCJST0xFX1RZUEUiLCJtYXRjaEFjY2Vzc2liaWxpdHlSb2xlIiwiVEVYVF9UWVBFIiwiZ2V0VGV4dENvbnRlbnQiLCJURVNUX05BTUVfVFlQRSIsInNlbGVjdG9yVG9TdHJpbmciLCJmaW5kUGF0aHMiLCJzZWxlY3RvcnMiLCJtYXRjaGluZ0ZpYmVycyIsImZpbmRBbGxOb2RlcyIsInN1cHBvcnRzVGVzdFNlbGVjdG9ycyIsImZyb20iLCJvbkNvbW1pdFJvb3QiLCJjb21taXRIb29rcyIsImNvbW1pdEhvb2siLCJpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsInJlc29sdmVVcGRhdGVQcmlvcml0eSIsIm5leHRUcmFuc2l0aW9uRGVmZXJyZWRMYW5lIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyIsInByZXBhcmVGcmVzaFN0YWNrIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsIndhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFViIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwiZm9yY2VTeW5jIiwieWllbGRlZEZpYmVyIiwieWllbGRFbmRUaW1lIiwieWllbGRSZWFzb24iLCJTdXNwZW5kZWRPbkltbWVkaWF0ZSIsInlpZWxkU3RhcnRUaW1lIiwicmVuZGVyUm9vdENvbmN1cnJlbnQiLCJyZW5kZXJSb290U3luYyIsInJlbmRlcldhc0NvbmN1cnJlbnQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyIsImlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyIsInJlbmRlclN0YXJ0VGltZSIsIndvcmtJblByb2dyZXNzVXBkYXRlVGFzayIsImZpbmFsaXplUmVuZGVyIiwiZXJyb3JSZXRyeUxhbmVzIiwid2FzUm9vdERlaHlkcmF0ZWQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIiLCJSb290RmF0YWxFcnJvcmVkIiwiUm9vdFN1c3BlbmRlZEF0VGhlU2hlbGwiLCJibG9ja2luZ1N1c3BlbmRlZFRpbWUiLCJ0cmFuc2l0aW9uU3VzcGVuZGVkVGltZSIsIndvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyIsIlJvb3RDb21wbGV0ZWQiLCJjb21taXRSb290Iiwid29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsInBlbmRpbmdFZmZlY3RzTGFuZXMiLCJzY2hlZHVsZVRpbWVvdXQiLCJjb21taXRSb290V2hlblJlYWR5IiwiZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIiwiZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIiwiZXhpdFN0YXR1cyIsInN1c3BlbmRlZENvbW1pdFJlYXNvbiIsImNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSIsImNvbXBsZXRlZFJlbmRlckVuZFRpbWUiLCJzdGFydFN1c3BlbmRpbmdDb21taXQiLCJnbG9iYWxNb3N0UmVjZW50VHJhbnNpdGlvblRpbWUiLCJ3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5IiwiZ2V0U3VzcGVuZGVkQ29tbWl0UmVhc29uIiwiY2hlY2siLCJkaWRBdHRlbXB0RW50aXJlVHJlZSIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwicmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrIiwiTm90U3VzcGVuZGVkIiwiZmluYWxpemF0aW9uVGltZSIsImJsb2NraW5nQ2xhbXBUaW1lIiwidHJhbnNpdGlvbkNsYW1wVGltZSIsInByZXZpb3VzUmVuZGVyU3RhcnRUaW1lIiwibGFiZWwiLCJldmVudFRpbWUiLCJldmVudFR5cGUiLCJldmVudElzUmVwZWF0IiwiaXNTcGF3bmVkVXBkYXRlIiwiaXNQaW5nZWRVcGRhdGUiLCJjb2xvciRqc2NvbXAkMCIsInRyYW5zaXRpb25VcGRhdGVUeXBlIiwiY2FuY2VsVGltZW91dCIsIndvcmtJblByb2dyZXNzVGhyb3duVmFsdWUiLCJnZXRDdXJyZW50VGltZSIsImxhc3RSZXNldFRpbWUiLCJyZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJoYW5kbGVUaHJvdyIsInRocm93blZhbHVlIiwiU3VzcGVuZGVkT25JbnN0YW5jZSIsIlN1c3BlbmRlZE9uSHlkcmF0aW9uIiwiU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlIiwiU3VzcGVuZGVkT25FcnJvciIsImVycm9yZWRXb3JrIiwicHVzaERpc3BhdGNoZXIiLCJwdXNoQXN5bmNEaXNwYXRjaGVyIiwicHJldkFzeW5jRGlzcGF0Y2hlciIsIkEiLCJEZWZhdWx0QXN5bmNEaXNwYXRjaGVyIiwic2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmciLCJwcmV2RXhlY3V0aW9uQ29udGV4dCIsInVuaXRPZldvcmsiLCJ0aHJvd0FuZFVud2luZFdvcmtMb29wIiwid29ya0xvb3BTeW5jIiwidGhyb3duVmFsdWUkNCIsInBlcmZvcm1Vbml0T2ZXb3JrIiwiUkVOREVSX1RJTUVPVVRfTVMiLCJyZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrIiwiU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlIiwiU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSIsImhvc3RGaWJlciIsImNvbXBsZXRlVW5pdE9mV29yayIsIndvcmtMb29wQ29uY3VycmVudEJ5U2NoZWR1bGVyIiwidGhyb3duVmFsdWUkNSIsInNob3VsZFlpZWxkIiwicmVwbGF5QmVnaW5Xb3JrIiwiaXNQcm9maWxpbmdNb2RlIiwic3VzcGVuZGVkUmVhc29uIiwidW53aW5kVW5pdE9mV29yayIsInNraXBTaWJsaW5ncyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInBlbmRpbmdGaW5pc2hlZFdvcmsiLCJwZW5kaW5nRWZmZWN0c1Jvb3QiLCJwZW5kaW5nRWZmZWN0c1JlbWFpbmluZ0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyIsInBlbmRpbmdSZWNvdmVyYWJsZUVycm9ycyIsInBlbmRpbmdFZmZlY3RzUmVuZGVyRW5kVGltZSIsInBlbmRpbmdTdXNwZW5kZWRDb21taXRSZWFzb24iLCJwZW5kaW5nU3VzcGVuZGVkVmlld1RyYW5zaXRpb25SZWFzb24iLCJzY2hlZHVsZUNhbGxiYWNrIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsIlBFTkRJTkdfTVVUQVRJT05fUEhBU0UiLCJmbHVzaE11dGF0aW9uRWZmZWN0cyIsImZsdXNoTGF5b3V0RWZmZWN0cyIsImZsdXNoU3Bhd25lZFdvcmsiLCJyb290TXV0YXRpb25IYXNFZmZlY3QiLCJyZXNldEFmdGVyQ29tbWl0IiwiUEVORElOR19MQVlPVVRfUEhBU0UiLCJzdXNwZW5kZWRWaWV3VHJhbnNpdGlvblJlYXNvbiIsImNvbW1pdEVuZFRpbWUiLCJhbmltYXRpbmdUYXNrIiwicm9vdEhhc0xheW91dEVmZmVjdCIsIl9wcmV2aW91c1ByaW9yaXR5IiwiX3ByZXZFeGVjdXRpb25Db250ZXh0IiwiQUJPUlRFRF9WSUVXX1RSQU5TSVRJT05fQ09NTUlUIiwiUEVORElOR19BRlRFUl9NVVRBVElPTl9QSEFTRSIsIlBFTkRJTkdfU1BBV05FRF9XT1JLIiwic3RhcnRWaWV3VHJhbnNpdGlvblN0YXJ0VGltZSIsImFib3J0ZWRWaWV3VHJhbnNpdGlvbiIsIkFOSU1BVElPTl9TVEFSVEVEX0NPTU1JVCIsInJlcXVlc3RQYWludCIsInJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMiLCJyZWxlYXNlUm9vdFBvb2xlZENhY2hlIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5Iiwib25SZWNvdmVyYWJsZUVycm9yIiwicmVjb3ZlcmFibGVFcnJvciIsIm1ha2VFcnJvckluZm8iLCJmbHVzaEh5ZHJhdGlvbkV2ZW50cyIsInJlbmRlclByaW9yaXR5IiwicHJpb3JpdHkiLCJwYXNzaXZlRWZmZWN0U3RhcnRUaW1lIiwiZGVsYXllZFVudGlsUGFpbnQiLCJmaW5pc2hlZFdvcmskanNjb21wJDAiLCJwYXNzaXZlRWZmZWN0c0VuZFRpbWUiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsInBpbmdDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsInRocmVhZElEcyIsInBpbmdTdXNwZW5kZWRSb290IiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsInN1c3BlbnNlU3RhdGUiLCJyZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwiaXNJblN0cmljdE1vZGUiLCJpc1N0cmljdE1vZGVGaWJlciIsImRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyIiwiZG91YmxlSW52b2tlRWZmZWN0cyIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQiLCJzY2hlZHVsaW5nRmliZXIiLCJwcmlvcml0eUxldmVsIiwiZmFrZUFjdENhbGxiYWNrTm9kZSIsImZhbWlseSIsInByZXZUeXBlIiwibmVlZHNDb21wYXJlRmFtaWxpZXMiLCIkJHR5cGVvZk5leHRUeXBlIiwiV2Vha1NldCIsImZhaWxlZEJvdW5kYXJpZXMiLCJfZmliZXIiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsInByZXZlbnRFeHRlbnNpb25zIiwiaXNSZWFjdENvbXBvbmVudCIsImZpYmVyVGFnIiwicmVzb2x2ZWRUeXBlIiwiaXNIb3N0SG9pc3RhYmxlVHlwZSIsImlzSG9zdFNpbmdsZXRvblR5cGUiLCJlbGVtZW50cyIsImRlaHlkcmF0ZWROb2RlIiwiRmliZXJSb290Tm9kZSIsImh5ZHJhdGUiLCJvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJoeWRyYXRpb25DYWxsYmFja3MiLCJpc1N0cmljdE1vZGUiLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsInVwZGF0ZUNvbnRhaW5lckltcGwiLCJvblNjaGVkdWxlRmliZXJSb290IiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsIm1hcmtSZXRyeUxhbmVJbXBsIiwibWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlN5bWJvbCIsImZvciIsIml0ZXJhdG9yIiwiaXNBcnJheSIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsInJlbmRlcmVyVmVyc2lvbiIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJleHRyYURldlRvb2xzQ29uZmlnIiwiY2xvbmVNdXRhYmxlSW5zdGFuY2UiLCJjbG9uZU11dGFibGVUZXh0SW5zdGFuY2UiLCJ3YXJuc0lmTm90QWN0aW5nIiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJzdXNwZW5kT25BY3RpdmVWaWV3VHJhbnNpdGlvbiIsImJpbmRUb0NvbnNvbGUiLCJnZXRCb3VuZGluZ1JlY3QiLCJzZXRGb2N1c0lmRm9jdXNhYmxlIiwic2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciIsImNhbmNlbFZpZXdUcmFuc2l0aW9uTmFtZSIsImNhbmNlbFJvb3RWaWV3VHJhbnNpdGlvbk5hbWUiLCJyZXN0b3JlUm9vdFZpZXdUcmFuc2l0aW9uTmFtZSIsImNsb25lUm9vdFZpZXdUcmFuc2l0aW9uQ29udGFpbmVyIiwicmVtb3ZlUm9vdFZpZXdUcmFuc2l0aW9uQ2xvbmUiLCJtZWFzdXJlQ2xvbmVkSW5zdGFuY2UiLCJoYXNJbnN0YW5jZUNoYW5nZWQiLCJoYXNJbnN0YW5jZUFmZmVjdGVkUGFyZW50Iiwic3RhcnRWaWV3VHJhbnNpdGlvbiIsInN0YXJ0R2VzdHVyZVRyYW5zaXRpb24iLCJzdG9wVmlld1RyYW5zaXRpb24iLCJnZXRDdXJyZW50R2VzdHVyZU9mZnNldCIsImNyZWF0ZVZpZXdUcmFuc2l0aW9uSW5zdGFuY2UiLCJjcmVhdGVGcmFnbWVudEluc3RhbmNlIiwidXBkYXRlRnJhZ21lbnRJbnN0YW5jZUZpYmVyIiwiY29tbWl0TmV3Q2hpbGRUb0ZyYWdtZW50SW5zdGFuY2UiLCJkZWxldGVDaGlsZEZyb21GcmFnbWVudEluc3RhbmNlIiwiY2xlYXJBY3Rpdml0eUJvdW5kYXJ5IiwiY2xlYXJBY3Rpdml0eUJvdW5kYXJ5RnJvbUNvbnRhaW5lciIsImZyZWV6ZSIsIk1hdGgiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX25vdyIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsImxvY2FsUGVyZm9ybWFuY2UiLCJsb2NhbERhdGUiLCJEYXRlIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJyZXBvcnRFcnJvciIsIndpbmRvdyIsIkVycm9yRXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsInByb2Nlc3MiLCJlbWl0IiwiX19yZWFjdERpc2FibGVkTG9nIiwiV2Vha01hcCIsIkFib3J0Q29udHJvbGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJDb25zdW1lciIsIlByb3ZpZGVyIiwiX3RocmVhZENvdW50IiwicHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwic29ydGVkTmFtZXMiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic3RyaWN0Um9vdCIsImZpYmVyQXJyYXkiLCJmaXJzdEZpYmVyIiwidW5pcXVlTmFtZXMiLCJjYWxsQ29tcG9uZW50IiwicmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lIiwid2FzUmVuZGVyaW5nIiwiY2FsbFJlbmRlciIsImNhbGxDb21wb25lbnREaWRNb3VudCIsImNhbGxDb21wb25lbnREaWRVcGRhdGUiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2giLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ3JlYXRlIiwiZWZmZWN0IiwiY2FsbERlc3Ryb3kiLCJjYWxsTGF6eUluaXQiLCJsYXp5Iiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY29tcG9uZW50S2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXJBcHBlbmRpeCIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlSWQiLCJ1c2VGb3JtU3RhdGUiLCJ1c2VBY3Rpb25TdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJ1c2VDYWNoZVJlZnJlc2giLCJ1c2VFZmZlY3RFdmVudCIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiY2FjaGVGb3JUeXBlIiwiY2FjaGVTaWduYWwiLCJnZXRPd25lciIsInN5bWJvbEZvciIsIkluZmluaXR5Iiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2NoZWR1bGVSZXRyeSIsInNldEVycm9ySGFuZGxlciIsInNldFN1c3BlbnNlSGFuZGxlciIsIm5ld1Nob3VsZEVycm9ySW1wbCIsIm5ld1Nob3VsZFN1c3BlbmRJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJiYXRjaGVkVXBkYXRlcyIsImNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yIiwiY29tcG9uZW50IiwiY3JlYXRlQ29udGFpbmVyIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IiLCJjcmVhdGVIeWRyYXRpb25Db250YWluZXIiLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwiY3JlYXRlUG9ydGFsIiwiZSQ2IiwidG9TdHJpbmdUYWciLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImNyZWF0ZVRleHRTZWxlY3RvciIsInRleHQiLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwicmVjcmVhdGVNZXNzYWdlIiwiZW52aXJvbm1lbnROYW1lIiwiZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvciIsImRlZmF1bHRPblVuY2F1Z2h0RXJyb3IiLCJkZWZlcnJlZFVwZGF0ZXMiLCJkaXNjcmV0ZVVwZGF0ZXMiLCJkIiwiZmluZEJvdW5kaW5nUmVjdHMiLCJ0YXJnZXRMZWZ0IiwidGFyZ2V0UmlnaHQiLCJ3aWR0aCIsInRhcmdldFRvcCIsInRhcmdldEJvdHRvbSIsImhlaWdodCIsImoiLCJvdGhlclJlY3QiLCJvdGhlckxlZnQiLCJvdGhlclJpZ2h0Iiwib3RoZXJUb3AiLCJvdGhlckJvdHRvbSIsImZpbmRIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsImZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyIsIm1ldGhvZE5hbWUiLCJmbHVzaFN5bmNGcm9tUmVjb25jaWxlciIsImZvY3VzV2l0aGluIiwiZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uIiwibWF4U2VsZWN0b3JJbmRleCIsIm1hdGNoZWROYW1lcyIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImluamVjdEludG9EZXZUb29scyIsImJ1bmRsZVR5cGUiLCJ2ZXJzaW9uIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJyZWNvbmNpbGVyVmVyc2lvbiIsInJlbmRlcmVyQ29uZmlnIiwiZ2V0Q3VycmVudEZpYmVyIiwib2JzZXJ2ZVZpc2libGVSZWN0cyIsIm9wdGlvbnMiLCJuZXh0SW5zdGFuY2VSb290cyIsImluc3RhbmNlUm9vdHMiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInNob3VsZEVycm9yIiwic2hvdWxkU3VzcGVuZCIsInN0YXJ0SG9zdFRyYW5zaXRpb24iLCJmb3JtRGF0YSIsInVwZGF0ZUNvbnRhaW5lciIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RcXENvbmNlcnQgVGlja2V0aW5nXFxUaWNrZXRpbmdVaVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1yZWNvbmNpbGVyXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJEOlxccHJvamVjdFxcQ29uY2VydCBUaWNrZXRpbmdcXFRpY2tldGluZ1VpXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      needsPaint = !1;\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0),\n            isMessageLoopRunning ||\n              ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return needsPaint\n        ? !0\n        : exports.unstable_now() - startTime < frameInterval\n          ? !1\n          : !0;\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      needsPaint = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_requestPaint = function () {\n      needsPaint = !0;\n    };\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0),\n            isMessageLoopRunning ||\n              ((isMessageLoopRunning = !0),\n              schedulePerformWorkUntilDeadline())));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxrQ0FBa0M7QUFDdEMsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSwwQkFBMEI7QUFDOUIsSUFBSSxxQ0FBcUM7QUFDekMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0EsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJEOlxccHJvamVjdFxcQ29uY2VydCBUaWNrZXRpbmdcXFRpY2tldGluZ1VpXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXG5vZGVfbW9kdWxlc1xcc2NoZWR1bGVyXFxjanNcXHNjaGVkdWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICAgICAgbmVlZHNQYWludCA9ICExO1xuICAgICAgaWYgKGlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExO1xuICAgICAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCAmJlxuICAgICAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLFxuICAgICAgICAgICAgICAodGFza1RpbWVvdXRJRCA9IC0xKSk7XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFRhc2sgJiZcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSAmJiBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUYXNrKSBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgICAgICAoaXNQZXJmb3JtaW5nV29yayA9ICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBoYXNNb3JlV29ya1xuICAgICAgICAgICAgPyBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpXG4gICAgICAgICAgICA6IChpc01lc3NhZ2VMb29wUnVubmluZyA9ICExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IChpbmRleCAtIDEpID4+PiAxLFxuICAgICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuICAgICAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgICAgICAoaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlKSxcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHBhcmVudCksXG4gICAgICAgICAgICAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gMCA9PT0gaGVhcC5sZW5ndGggPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmICgwID09PSBoZWFwLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgICAgICBsYXN0ID0gaGVhcC5wb3AoKTtcbiAgICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgICAgYTogZm9yIChcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBoZWFwLmxlbmd0aCwgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxlZnRJbmRleCA9IDIgKiAoaW5kZXggKyAxKSAtIDEsXG4gICAgICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDEsXG4gICAgICAgICAgICByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07XG4gICAgICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICAgICAgcmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGVmdClcbiAgICAgICAgICAgICAgPyAoKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCkpXG4gICAgICAgICAgICAgIDogKChoZWFwW2luZGV4XSA9IGxlZnQpLFxuICAgICAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSBsZWZ0SW5kZXgpKTtcbiAgICAgICAgICBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsYXN0KSlcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICAgICAgcmV0dXJuIDAgIT09IGRpZmYgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gdGltZXIuY2FsbGJhY2spIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgICAgZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKVxuICAgICAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgICAgICh0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZSksXG4gICAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZClcbiAgICAgICAgaWYgKG51bGwgIT09IHBlZWsodGFza1F1ZXVlKSlcbiAgICAgICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICAgICAgICAgICAoKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITApLCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgICAgIHJldHVybiBuZWVkc1BhaW50XG4gICAgICAgID8gITBcbiAgICAgICAgOiBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lIDwgZnJhbWVJbnRlcnZhbFxuICAgICAgICAgID8gITFcbiAgICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XG4gICAgICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gICAgICB9LCBtcyk7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSB2b2lkIDA7XG4gICAgaWYgKFxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZS5ub3dcbiAgICApIHtcbiAgICAgIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gICAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYWxEYXRlID0gRGF0ZSxcbiAgICAgICAgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG4gICAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRhc2tRdWV1ZSA9IFtdLFxuICAgICAgdGltZXJRdWV1ZSA9IFtdLFxuICAgICAgdGFza0lkQ291bnRlciA9IDEsXG4gICAgICBjdXJyZW50VGFzayA9IG51bGwsXG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IDMsXG4gICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITEsXG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExLFxuICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExLFxuICAgICAgbmVlZHNQYWludCA9ICExLFxuICAgICAgbG9jYWxTZXRUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiBudWxsLFxuICAgICAgbG9jYWxDbGVhclRpbWVvdXQgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjbGVhclRpbWVvdXQgPyBjbGVhclRpbWVvdXQgOiBudWxsLFxuICAgICAgbG9jYWxTZXRJbW1lZGlhdGUgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygc2V0SW1tZWRpYXRlID8gc2V0SW1tZWRpYXRlIDogbnVsbCxcbiAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITEsXG4gICAgICB0YXNrVGltZW91dElEID0gLTEsXG4gICAgICBmcmFtZUludGVydmFsID0gNSxcbiAgICAgIHN0YXJ0VGltZSA9IC0xO1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSlcbiAgICAgIHZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgICAgIH07XG4gICAgZWxzZSBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLFxuICAgICAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICAgICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IDU7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IDE7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IDQ7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IDM7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuICAgIGV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xuICAgIGV4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgdGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKGZwcykge1xuICAgICAgMCA+IGZwcyB8fCAxMjUgPCBmcHNcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIlxuICAgICAgICAgIClcbiAgICAgICAgOiAoZnJhbWVJbnRlcnZhbCA9IDAgPCBmcHMgPyBNYXRoLmZsb29yKDFlMyAvIGZwcykgOiA1KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX25leHQgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBuZWVkc1BhaW50ID0gITA7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gMztcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrID0gZnVuY3Rpb24gKFxuICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG51bGwgIT09IG9wdGlvbnNcbiAgICAgICAgPyAoKG9wdGlvbnMgPSBvcHRpb25zLmRlbGF5KSxcbiAgICAgICAgICAob3B0aW9ucyA9XG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiAwIDwgb3B0aW9uc1xuICAgICAgICAgICAgICA/IGN1cnJlbnRUaW1lICsgb3B0aW9uc1xuICAgICAgICAgICAgICA6IGN1cnJlbnRUaW1lKSlcbiAgICAgICAgOiAob3B0aW9ucyA9IGN1cnJlbnRUaW1lKTtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRpbWVvdXQgPSAyNTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aW1lb3V0ID0gMTA3Mzc0MTgyMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRpbWVvdXQgPSAxZTQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGltZW91dCA9IDVlMztcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBvcHRpb25zICsgdGltZW91dDtcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSB7XG4gICAgICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgc3RhcnRUaW1lOiBvcHRpb25zLFxuICAgICAgICBleHBpcmF0aW9uVGltZTogdGltZW91dCxcbiAgICAgICAgc29ydEluZGV4OiAtMVxuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPiBjdXJyZW50VGltZVxuICAgICAgICA/ICgocHJpb3JpdHlMZXZlbC5zb3J0SW5kZXggPSBvcHRpb25zKSxcbiAgICAgICAgICBwdXNoKHRpbWVyUXVldWUsIHByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgIG51bGwgPT09IHBlZWsodGFza1F1ZXVlKSAmJlxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCA9PT0gcGVlayh0aW1lclF1ZXVlKSAmJlxuICAgICAgICAgICAgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWRcbiAgICAgICAgICAgICAgPyAobG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksICh0YXNrVGltZW91dElEID0gLTEpKVxuICAgICAgICAgICAgICA6IChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITApLFxuICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIG9wdGlvbnMgLSBjdXJyZW50VGltZSkpKVxuICAgICAgICA6ICgocHJpb3JpdHlMZXZlbC5zb3J0SW5kZXggPSB0aW1lb3V0KSxcbiAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgfHxcbiAgICAgICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgICAgICgoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICAgICAgICAgICAoKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITApLFxuICAgICAgICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpKSkpO1xuICAgICAgcmV0dXJuIHByaW9yaXR5TGV2ZWw7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gc2hvdWxkWWllbGRUb0hvc3Q7XG4gICAgZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1S0FBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0XFxDb25jZXJ0IFRpY2tldGluZ1xcVGlja2V0aW5nVWlcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcbm9kZV9tb2R1bGVzXFxzY2hlZHVsZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\n");

/***/ })

};
;