"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   authApi: () => (/* binding */ authApi),\n/* harmony export */   cartApi: () => (/* binding */ cartApi),\n/* harmony export */   categoriesApi: () => (/* binding */ categoriesApi),\n/* harmony export */   certificateApi: () => (/* binding */ certificateApi),\n/* harmony export */   coursesApi: () => (/* binding */ coursesApi),\n/* harmony export */   getToken: () => (/* binding */ getToken),\n/* harmony export */   removeToken: () => (/* binding */ removeToken),\n/* harmony export */   setToken: () => (/* binding */ setToken),\n/* harmony export */   studentApi: () => (/* binding */ studentApi),\n/* harmony export */   videoApi: () => (/* binding */ videoApi),\n/* harmony export */   wishlistApi: () => (/* binding */ wishlistApi)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// API service layer for connecting frontend to backend\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';\nclass ApiError extends Error {\n    constructor(message, status, data = null){\n        super(message);\n        this.name = 'ApiError';\n        this.status = status;\n        this.data = data;\n    }\n}\n// Token management\nconst getToken = ()=>{\n    if (true) {\n        return localStorage.getItem('aiq-token');\n    }\n    return null;\n};\nconst setToken = (token)=>{\n    if (true) {\n        localStorage.setItem('aiq-token', token);\n    }\n};\nconst removeToken = ()=>{\n    if (true) {\n        localStorage.removeItem('aiq-token');\n    }\n};\n// Base API request function\nconst apiRequest = async function(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    const token = getToken();\n    const config = {\n        headers: {\n            'Content-Type': 'application/json',\n            ...options.headers\n        },\n        ...options\n    };\n    // Add authentication header if token exists\n    if (token) {\n        config.headers.Authorization = \"Bearer \".concat(token);\n    }\n    try {\n        const response = await fetch(url, config);\n        let data;\n        try {\n            data = await response.json();\n        } catch (e) {\n            data = null;\n        }\n        if (!response.ok) {\n            // Handle 401 Unauthorized specifically\n            if (response.status === 401) {\n                // Token might be expired, remove it\n                removeToken();\n                if (true) {\n                    localStorage.removeItem('aiq-user');\n                }\n            }\n            throw new ApiError((data === null || data === void 0 ? void 0 : data.message) || \"HTTP error! status: \".concat(response.status), response.status, data);\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        throw new ApiError('Network error occurred', 0);\n    }\n};\n// Auth API\nconst authApi = {\n    // Login\n    async login (payload) {\n        const data = await apiRequest('/auth/login', {\n            method: 'POST',\n            body: JSON.stringify(payload)\n        });\n        if (data.token) {\n            setToken(data.token);\n        }\n        return data;\n    },\n    // Register\n    async register (payload) {\n        const data = await apiRequest('/auth/register', {\n            method: 'POST',\n            body: JSON.stringify({\n                name: payload.name,\n                email: payload.email,\n                password: payload.password\n            })\n        });\n        if (data.token) {\n            setToken(data.token);\n        }\n        return data;\n    },\n    // Get current user profile\n    async getProfile () {\n        return await apiRequest('/auth/profile');\n    },\n    // Update profile\n    async updateProfile (profileData) {\n        return await apiRequest('/auth/profile', {\n            method: 'PUT',\n            body: JSON.stringify(profileData)\n        });\n    },\n    // Update instructor profile\n    async updateInstructorProfile (instructorData) {\n        return await apiRequest('/auth/instructor-profile', {\n            method: 'PUT',\n            body: JSON.stringify(instructorData)\n        });\n    },\n    // Logout\n    logout () {\n        removeToken();\n        if (true) {\n            localStorage.removeItem('aiq-user');\n        }\n    }\n};\n// Courses API\nconst coursesApi = {\n    // Get all published courses (for students to browse)\n    async getPublished () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        // Convert params to URLSearchParams\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/courses?\".concat(queryParams));\n    },\n    // Get instructor dashboard stats\n    async getDashboardStats () {\n        return await apiRequest('/courses/instructor/dashboard-stats');\n    },\n    // Get instructor's courses\n    async getMyCourses () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams(params);\n        return await apiRequest(\"/courses/instructor/my-courses?\".concat(queryParams));\n    },\n    // Create draft course\n    async createDraft (formData) {\n        return await apiRequest('/courses/draft', {\n            method: 'POST',\n            headers: {},\n            body: formData\n        });\n    },\n    // Update course basic info\n    async updateBasicInfo (courseId, formData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/basic-info\"), {\n            method: 'PUT',\n            headers: {},\n            body: formData\n        });\n    },\n    // Get course details\n    async getCourse (courseId) {\n        return await apiRequest(\"/courses/\".concat(courseId));\n    },\n    // Get course by ID (alias for getCourse)\n    async getById (courseId) {\n        return await this.getCourse(courseId);\n    },\n    // Update course\n    async update (courseId, formData) {\n        return await this.updateBasicInfo(courseId, formData);\n    },\n    // Add section to course\n    async addSection (courseId, sectionData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections\"), {\n            method: 'POST',\n            body: JSON.stringify(sectionData)\n        });\n    },\n    // Add lecture to section\n    async addLecture (courseId, sectionId, lectureData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections/\").concat(sectionId, \"/lectures\"), {\n            method: 'POST',\n            body: JSON.stringify(lectureData)\n        });\n    },\n    // Update lecture\n    async updateLecture (courseId, sectionId, lectureId, lectureData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections/\").concat(sectionId, \"/lectures/\").concat(lectureId), {\n            method: 'PUT',\n            body: JSON.stringify(lectureData)\n        });\n    },\n    // Publish/unpublish course\n    async togglePublish (courseId) {\n        let publish = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        return await apiRequest(\"/courses/\".concat(courseId, \"/publish\"), {\n            method: 'PATCH',\n            body: JSON.stringify({\n                publish\n            })\n        });\n    },\n    // Delete course\n    async deleteCourse (courseId) {\n        return await apiRequest(\"/courses/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Delete lecture (immediately from MongoDB + api.video)\n    async deleteLecture (courseId, sectionId, lectureId) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections/\").concat(sectionId, \"/lectures/\").concat(lectureId), {\n            method: 'DELETE'\n        });\n    },\n    // Test SSE connection\n    testSSE () {\n        return new Promise((resolve)=>{\n            console.log('ðŸ§ª Testing SSE connection...');\n            const sseUrl = \"\".concat(API_BASE_URL, \"/courses/test-sse\");\n            const eventSource = new EventSource(sseUrl);\n            let messageCount = 0;\n            eventSource.onopen = ()=>{\n                console.log('âœ… SSE test connection opened successfully');\n            };\n            eventSource.onmessage = (event)=>{\n                console.log('ðŸ“© SSE test message received:', event.data);\n                messageCount++;\n                try {\n                    const data = JSON.parse(event.data);\n                    if (data.complete) {\n                        console.log('âœ… SSE test completed successfully, received', messageCount, 'messages');\n                        eventSource.close();\n                        resolve(true);\n                    }\n                } catch (error) {\n                    console.error('âŒ SSE test message parse error:', error);\n                }\n            };\n            eventSource.onerror = (error)=>{\n                console.error('âŒ SSE test connection error:', error);\n                eventSource.close();\n                resolve(false);\n            };\n            // Timeout after 10 seconds\n            setTimeout(()=>{\n                console.warn('â±ï¸ SSE test timeout');\n                eventSource.close();\n                resolve(false);\n            }, 10000);\n        });\n    },\n    // Test CORS connectivity to backend\n    async testCORS () {\n        try {\n            console.log('ðŸ§ª Testing CORS connectivity to:', \"\".concat(API_BASE_URL, \"/courses/cors-test\"));\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/courses/cors-test\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            const data = await response.json();\n            console.log('âœ… CORS Test Response:', data);\n            return data;\n        } catch (error) {\n            console.error('âŒ CORS Test Failed:', error);\n            throw error;\n        }\n    },\n    // Simple video upload to api.video with progress tracking\n    async uploadVideo (courseId, sectionIndex, lectureIndex, videoFile, thumbnailFile, onProgress) {\n        const formData = new FormData();\n        formData.append('video', videoFile);\n        formData.append('courseId', courseId);\n        formData.append('sectionIndex', sectionIndex.toString());\n        formData.append('lectureIndex', lectureIndex.toString());\n        if (thumbnailFile) {\n            formData.append('thumbnail', thumbnailFile);\n        }\n        const token = getToken();\n        // Hybrid progress tracking: Try SSE first, fall back to polling\n        // Simple milestone-based progress tracking\n        const progressKey = \"\".concat(courseId, \"-\").concat(sectionIndex, \"-\").concat(lectureIndex);\n        let progressMilestones = [\n            20,\n            40,\n            60,\n            80,\n            90,\n            100\n        ];\n        let currentMilestoneIndex = 0;\n        // Start progress tracking by periodically checking backend\n        let progressCheckInterval = null;\n        let progressCompleted = false;\n        if (onProgress) {\n            console.log('ðŸ“¹ Starting milestone-based progress tracking...');\n            onProgress(0); // Start at 0%\n            progressCheckInterval = setInterval(async ()=>{\n                if (progressCompleted) {\n                    clearInterval(progressCheckInterval);\n                    return;\n                }\n                try {\n                    const response = await fetch(\"\".concat(API_BASE_URL, \"/courses/progress-milestone/\").concat(progressKey), {\n                        headers: {\n                            'Authorization': \"Bearer \".concat(token)\n                        }\n                    });\n                    if (response.ok) {\n                        const data = await response.json();\n                        if (data.milestone && data.milestone > (progressMilestones[currentMilestoneIndex - 1] || 0)) {\n                            console.log('ðŸ“¹ Progress milestone reached:', data.milestone + '%');\n                            onProgress(data.milestone);\n                            if (data.milestone >= 100) {\n                                progressCompleted = true;\n                                clearInterval(progressCheckInterval);\n                            }\n                        }\n                    }\n                } catch (error) {\n                    console.warn('ðŸ“¹ Progress milestone check failed:', error);\n                }\n            }, 1000); // Check every second for milestone updates\n        }\n        try {\n            console.log('ðŸ“¹ Starting video upload...');\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/courses/upload-video\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token)\n                },\n                body: formData\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                throw new ApiError(data.message || 'Upload failed', response.status, data);\n            }\n            // Clean up progress tracking and ensure 100%\n            progressCompleted = true;\n            if (progressCheckInterval) {\n                clearInterval(progressCheckInterval);\n            }\n            if (onProgress) {\n                console.log('ðŸ“¹ Upload completed - setting progress to 100%');\n                onProgress(100);\n            }\n            return data;\n        } catch (error) {\n            // Clean up progress tracking on error\n            progressCompleted = true;\n            if (progressCheckInterval) {\n                clearInterval(progressCheckInterval);\n            }\n            if (error instanceof ApiError) {\n                throw error;\n            }\n            throw new ApiError('Network error during upload', 0, null);\n        }\n    },\n    // Upload video for lecture (legacy - complex route)\n    async uploadLectureVideo (courseId, sectionId, lectureId, videoFile, thumbnailFile) {\n        const formData = new FormData();\n        formData.append('video', videoFile);\n        if (thumbnailFile) {\n            formData.append('thumbnail', thumbnailFile);\n        }\n        const token = getToken();\n        return await fetch(\"\".concat(API_BASE_URL, \"/courses/\").concat(courseId, \"/sections/\").concat(sectionId, \"/lectures/\").concat(lectureId, \"/upload-video\"), {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(token)\n            },\n            body: formData\n        }).then(async (response)=>{\n            const data = await response.json();\n            if (!response.ok) {\n                throw new ApiError(data.message || 'Upload failed', response.status, data);\n            }\n            return data;\n        });\n    }\n};\n// Categories API\nconst categoriesApi = {\n    async getAll () {\n        return await apiRequest('/categories');\n    }\n};\n// Student/Learner API\nconst studentApi = {\n    // Get student's enrollments\n    async getMyEnrollments () {\n        return await apiRequest('/enrollments/my-enrollments');\n    },\n    // Get student's enrolled courses with progress\n    async getMyCourses () {\n        return await apiRequest('/enrollments/my-courses');\n    },\n    // Enroll in a course\n    async enrollInCourse (courseId) {\n        return await apiRequest(\"/enrollments/enroll/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Get course progress\n    async getCourseProgress (courseId) {\n        return await apiRequest(\"/progress/course/\".concat(courseId));\n    },\n    // Mark lesson as complete\n    async markLessonComplete (courseId, sectionId, lectureId, timeSpent) {\n        return await apiRequest('/progress/lesson-complete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                courseId,\n                sectionId,\n                lectureId,\n                timeSpent: timeSpent || 0\n            })\n        });\n    },\n    // Unmark lesson as complete\n    async unmarkLessonComplete (courseId, sectionId, lectureId, timeSpent) {\n        return await apiRequest('/progress/lesson-uncomplete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                courseId,\n                sectionId,\n                lectureId,\n                timeSpent: timeSpent || 0\n            })\n        });\n    },\n    // Get student dashboard overview\n    async getDashboardOverview () {\n        return await apiRequest('/progress/overview');\n    },\n    // Get specific enrollment details\n    async getEnrollmentDetails (courseId) {\n        return await apiRequest(\"/enrollments/my-enrollment/\".concat(courseId));\n    }\n};\n// Certificate API\nconst certificateApi = {\n    // Get user's certificates\n    async getCertificates () {\n        try {\n            return await apiRequest('/certificates');\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate list error:', error.status, error.message);\n            // For any certificate API error, just return empty list\n            // This prevents dashboard loading issues\n            return {\n                success: true,\n                certificates: [],\n                serviceUnavailable: error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))\n            };\n        }\n    },\n    // Get certificate by course ID\n    async getCertificateByCourse (courseId) {\n        try {\n            return await apiRequest(\"/certificates/course/\".concat(courseId));\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate API error:', error.status, error.message);\n            if (error.status === 404) {\n                return {\n                    success: false,\n                    message: 'Certificate not found',\n                    certificate: null\n                };\n            } else if (error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))) {\n                return {\n                    success: false,\n                    message: 'Certificate access denied',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 0 || error.status === 500) {\n                return {\n                    success: false,\n                    message: 'Certificate service unavailable',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            }\n            // For any other error, return a generic unavailable response\n            return {\n                success: false,\n                message: 'Certificate temporarily unavailable',\n                certificate: null,\n                serviceUnavailable: true\n            };\n        }\n    },\n    // Generate certificate for completed course\n    async generateCertificate (courseId) {\n        try {\n            return await apiRequest(\"/certificates/generate/\".concat(courseId), {\n                method: 'POST'\n            });\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate generation error:', error.status, error.message);\n            if (error.status === 404) {\n                return {\n                    success: false,\n                    message: 'Certificate generation not available',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))) {\n                return {\n                    success: false,\n                    message: 'Certificate generation access denied',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 0 || error.status === 500) {\n                return {\n                    success: false,\n                    message: 'Certificate service unavailable',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            }\n            // For any other error, return a generic unavailable response\n            return {\n                success: false,\n                message: 'Certificate generation temporarily unavailable',\n                certificate: null,\n                serviceUnavailable: true\n            };\n        }\n    },\n    // Get certificate by ID\n    async getCertificate (certificateId) {\n        return await apiRequest(\"/certificates/\".concat(certificateId));\n    },\n    // Download certificate\n    async downloadCertificate (certificateId) {\n        return await apiRequest(\"/certificates/\".concat(certificateId, \"/download\"));\n    },\n    // Get certificate image with custom text overlays\n    async getCertificateImage (certificateId) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/certificates/\").concat(certificateId, \"/image\"), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getToken())\n            }\n        });\n        if (!response.ok) {\n            throw new ApiError('Failed to fetch certificate image', response.status);\n        }\n        return await response.blob();\n    }\n};\n// Video API\nconst videoApi = {\n    // Get video details from api.video\n    async getVideoDetails (videoId) {\n        return await apiRequest(\"/videos/\".concat(videoId));\n    }\n};\n// Cart API\nconst cartApi = {\n    // Get user's cart\n    async getCart () {\n        return await apiRequest('/cart');\n    },\n    // Add course to cart\n    async addToCart (courseId) {\n        return await apiRequest(\"/cart/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Remove course from cart\n    async removeFromCart (courseId) {\n        return await apiRequest(\"/cart/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Check if course is in cart\n    async checkInCart (courseId) {\n        return await apiRequest(\"/cart/check/\".concat(courseId));\n    },\n    // Clear entire cart\n    async clearCart () {\n        return await apiRequest('/cart', {\n            method: 'DELETE'\n        });\n    }\n};\n// Wishlist API\nconst wishlistApi = {\n    // Get user's wishlist\n    async getWishlist () {\n        return await apiRequest('/wishlist');\n    },\n    // Add course to wishlist\n    async addToWishlist (courseId) {\n        return await apiRequest(\"/wishlist/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Remove course from wishlist\n    async removeFromWishlist (courseId) {\n        return await apiRequest(\"/wishlist/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Check if course is in wishlist\n    async checkInWishlist (courseId) {\n        return await apiRequest(\"/wishlist/check/\".concat(courseId));\n    }\n};\n// Export helper functions\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNOUMsV0FBd0IsZUFBd0IsT0FBVDhDO0lBQ3hEO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1vRjtRQUNGLE9BQU8sTUFBTWxJLFdBQXdCLFNBQVM7WUFDMUNnQixRQUFRO1FBQ1o7SUFDSjtBQUNKLEVBQUU7QUFFRixlQUFlO0FBQ1IsTUFBTW1ILGNBQWM7SUFDdkIsc0JBQXNCO0lBQ3RCLE1BQU1DO1FBQ0YsT0FBTyxNQUFNcEksV0FBd0I7SUFDekM7SUFFQSx5QkFBeUI7SUFDekIsTUFBTXFJLGVBQWN2RixRQUFnQjtRQUNoQyxPQUFPLE1BQU05QyxXQUF3QixhQUFzQixPQUFUOEMsV0FBWTtZQUMxRDlCLFFBQVE7UUFDWjtJQUNKO0lBRUEsOEJBQThCO0lBQzlCLE1BQU1zSCxvQkFBbUJ4RixRQUFnQjtRQUNyQyxPQUFPLE1BQU05QyxXQUF3QixhQUFzQixPQUFUOEMsV0FBWTtZQUMxRDlCLFFBQVE7UUFDWjtJQUNKO0lBRUEsaUNBQWlDO0lBQ2pDLE1BQU11SCxpQkFBZ0J6RixRQUFnQjtRQUNsQyxPQUFPLE1BQU05QyxXQUF3QixtQkFBNEIsT0FBVDhDO0lBQzVEO0FBQ0osRUFBRTtBQUVGLDBCQUEwQjtBQUMyQiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RcXENvbmNlcnQgVGlja2V0aW5nXFxUaWNrZXRpbmdVaVxcc3JjXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgc2VydmljZSBsYXllciBmb3IgY29ubmVjdGluZyBmcm9udGVuZCB0byBiYWNrZW5kXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpJztcblxuaW50ZXJmYWNlIEFwaVJlc3BvbnNlPFQgPSBhbnk+IHtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIHRva2VuPzogc3RyaW5nO1xuICAgIHVzZXI/OiBhbnk7XG4gICAgZGF0YT86IFQ7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5jbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICBkYXRhOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBkYXRhOiBhbnkgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG5cbi8vIFRva2VuIG1hbmFnZW1lbnRcbmNvbnN0IGdldFRva2VuID0gKCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FpcS10b2tlbicpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHNldFRva2VuID0gKHRva2VuOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FpcS10b2tlbicsIHRva2VuKTtcbiAgICB9XG59O1xuXG5jb25zdCByZW1vdmVUb2tlbiA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FpcS10b2tlbicpO1xuICAgIH1cbn07XG5cbi8vIEJhc2UgQVBJIHJlcXVlc3QgZnVuY3Rpb25cbmNvbnN0IGFwaVJlcXVlc3QgPSBhc3luYyA8VCA9IGFueT4oZW5kcG9pbnQ6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgJiB7IGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0gPSB7fSk6IFByb21pc2U8VD4gPT4ge1xuICAgIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFX1VSTH0ke2VuZHBvaW50fWA7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgY29uc3QgY29uZmlnOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gQWRkIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBpZiB0b2tlbiBleGlzdHNcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgKGNvbmZpZy5oZWFkZXJzIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgY29uZmlnKTtcblxuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIDQwMSBVbmF1dGhvcml6ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBtaWdodCBiZSBleHBpcmVkLCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICByZW1vdmVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWlxLXVzZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihcbiAgICAgICAgICAgICAgICBkYXRhPy5tZXNzYWdlIHx8IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKCdOZXR3b3JrIGVycm9yIG9jY3VycmVkJywgMCk7XG4gICAgfVxufTtcblxuLy8gQXV0aCBBUElcbmV4cG9ydCBjb25zdCBhdXRoQXBpID0ge1xuICAgIC8vIExvZ2luXG4gICAgYXN5bmMgbG9naW4ocGF5bG9hZCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkYXRhLnRva2VuKSB7XG4gICAgICAgICAgICBzZXRUb2tlbihkYXRhLnRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvLyBSZWdpc3RlclxuICAgIGFzeW5jIHJlZ2lzdGVyKHBheWxvYWQpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2F1dGgvcmVnaXN0ZXInLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbmFtZTpwYXlsb2FkLm5hbWUsIGVtYWlsOnBheWxvYWQuZW1haWwsIHBhc3N3b3JkOnBheWxvYWQucGFzc3dvcmQgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkYXRhLnRva2VuKSB7XG4gICAgICAgICAgICBzZXRUb2tlbihkYXRhLnRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgY3VycmVudCB1c2VyIHByb2ZpbGVcbiAgICBhc3luYyBnZXRQcm9maWxlKCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvYXV0aC9wcm9maWxlJyk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBwcm9maWxlXG4gICAgYXN5bmMgdXBkYXRlUHJvZmlsZShwcm9maWxlRGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvYXV0aC9wcm9maWxlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2ZpbGVEYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBpbnN0cnVjdG9yIHByb2ZpbGVcbiAgICBhc3luYyB1cGRhdGVJbnN0cnVjdG9yUHJvZmlsZShpbnN0cnVjdG9yRGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvYXV0aC9pbnN0cnVjdG9yLXByb2ZpbGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW5zdHJ1Y3RvckRhdGEpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTG9nb3V0XG4gICAgbG9nb3V0KCk6IHZvaWQge1xuICAgICAgICByZW1vdmVUb2tlbigpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhaXEtdXNlcicpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbi8vIENvdXJzZXMgQVBJXG5leHBvcnQgY29uc3QgY291cnNlc0FwaSA9IHtcbiAgICAvLyBHZXQgYWxsIHB1Ymxpc2hlZCBjb3Vyc2VzIChmb3Igc3R1ZGVudHMgdG8gYnJvd3NlKVxuICAgIGFzeW5jIGdldFB1Ymxpc2hlZChwYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgICAgICAgLy8gQ29udmVydCBwYXJhbXMgdG8gVVJMU2VhcmNoUGFyYW1zXG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcz8ke3F1ZXJ5UGFyYW1zfWApO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgaW5zdHJ1Y3RvciBkYXNoYm9hcmQgc3RhdHNcbiAgICBhc3luYyBnZXREYXNoYm9hcmRTdGF0cygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2NvdXJzZXMvaW5zdHJ1Y3Rvci9kYXNoYm9hcmQtc3RhdHMnKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGluc3RydWN0b3IncyBjb3Vyc2VzXG4gICAgYXN5bmMgZ2V0TXlDb3Vyc2VzKHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy9pbnN0cnVjdG9yL215LWNvdXJzZXM/JHtxdWVyeVBhcmFtc31gKTtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGRyYWZ0IGNvdXJzZVxuICAgIGFzeW5jIGNyZWF0ZURyYWZ0KGZvcm1EYXRhOiBGb3JtRGF0YSk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvY291cnNlcy9kcmFmdCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSwgLy8gRm9ybURhdGEgZm9yIGZpbGUgdXBsb2Fkc1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGNvdXJzZSBiYXNpYyBpbmZvXG4gICAgYXN5bmMgdXBkYXRlQmFzaWNJbmZvKGNvdXJzZUlkOiBzdHJpbmcsIGZvcm1EYXRhOiBGb3JtRGF0YSk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy8ke2NvdXJzZUlkfS9iYXNpYy1pbmZvYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsIC8vIEZvcm1EYXRhIGZvciBmaWxlIHVwbG9hZHNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCBjb3Vyc2UgZGV0YWlsc1xuICAgIGFzeW5jIGdldENvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jb3Vyc2VzLyR7Y291cnNlSWR9YCk7XG4gICAgfSxcblxuICAgIC8vIEdldCBjb3Vyc2UgYnkgSUQgKGFsaWFzIGZvciBnZXRDb3Vyc2UpXG4gICAgYXN5bmMgZ2V0QnlJZChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDb3Vyc2UoY291cnNlSWQpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgY291cnNlXG4gICAgYXN5bmMgdXBkYXRlKGNvdXJzZUlkOiBzdHJpbmcsIGZvcm1EYXRhOiBGb3JtRGF0YSk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBkYXRlQmFzaWNJbmZvKGNvdXJzZUlkLCBmb3JtRGF0YSk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBzZWN0aW9uIHRvIGNvdXJzZVxuICAgIGFzeW5jIGFkZFNlY3Rpb24oY291cnNlSWQ6IHN0cmluZywgc2VjdGlvbkRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXMvJHtjb3Vyc2VJZH0vc2VjdGlvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNlY3Rpb25EYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBsZWN0dXJlIHRvIHNlY3Rpb25cbiAgICBhc3luYyBhZGRMZWN0dXJlKGNvdXJzZUlkOiBzdHJpbmcsIHNlY3Rpb25JZDogc3RyaW5nLCBsZWN0dXJlRGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy8ke2NvdXJzZUlkfS9zZWN0aW9ucy8ke3NlY3Rpb25JZH0vbGVjdHVyZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGxlY3R1cmVEYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBsZWN0dXJlXG4gICAgYXN5bmMgdXBkYXRlTGVjdHVyZShjb3Vyc2VJZDogc3RyaW5nLCBzZWN0aW9uSWQ6IHN0cmluZywgbGVjdHVyZUlkOiBzdHJpbmcsIGxlY3R1cmVEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jb3Vyc2VzLyR7Y291cnNlSWR9L3NlY3Rpb25zLyR7c2VjdGlvbklkfS9sZWN0dXJlcy8ke2xlY3R1cmVJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobGVjdHVyZURhdGEpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHVibGlzaC91bnB1Ymxpc2ggY291cnNlXG4gICAgYXN5bmMgdG9nZ2xlUHVibGlzaChjb3Vyc2VJZDogc3RyaW5nLCBwdWJsaXNoOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy8ke2NvdXJzZUlkfS9wdWJsaXNoYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBwdWJsaXNoIH0pLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVsZXRlIGNvdXJzZVxuICAgIGFzeW5jIGRlbGV0ZUNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jb3Vyc2VzLyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERlbGV0ZSBsZWN0dXJlIChpbW1lZGlhdGVseSBmcm9tIE1vbmdvREIgKyBhcGkudmlkZW8pXG4gICAgYXN5bmMgZGVsZXRlTGVjdHVyZShjb3Vyc2VJZDogc3RyaW5nLCBzZWN0aW9uSWQ6IHN0cmluZywgbGVjdHVyZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXMvJHtjb3Vyc2VJZH0vc2VjdGlvbnMvJHtzZWN0aW9uSWR9L2xlY3R1cmVzLyR7bGVjdHVyZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0IFNTRSBjb25uZWN0aW9uXG4gICAgdGVzdFNTRSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+nqiBUZXN0aW5nIFNTRSBjb25uZWN0aW9uLi4uJyk7XG4gICAgICAgICAgICBjb25zdCBzc2VVcmwgPSBgJHtBUElfQkFTRV9VUkx9L2NvdXJzZXMvdGVzdC1zc2VgO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2Uoc3NlVXJsKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICBldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTU0UgdGVzdCBjb25uZWN0aW9uIG9wZW5lZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OpIFNTRSB0ZXN0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUNvdW50Kys7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU1NFIHRlc3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgcmVjZWl2ZWQnLCBtZXNzYWdlQ291bnQsICdtZXNzYWdlcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU1NFIHRlc3QgbWVzc2FnZSBwYXJzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXZlbnRTb3VyY2Uub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTU0UgdGVzdCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVGltZW91dCBhZnRlciAxMCBzZWNvbmRzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KPse+4jyBTU0UgdGVzdCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFRlc3QgQ09SUyBjb25uZWN0aXZpdHkgdG8gYmFja2VuZFxuICAgIGFzeW5jIHRlc3RDT1JTKCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6eqIFRlc3RpbmcgQ09SUyBjb25uZWN0aXZpdHkgdG86JywgYCR7QVBJX0JBU0VfVVJMfS9jb3Vyc2VzL2NvcnMtdGVzdGApO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2NvdXJzZXMvY29ycy10ZXN0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ09SUyBUZXN0IFJlc3BvbnNlOicsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQ09SUyBUZXN0IEZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBTaW1wbGUgdmlkZW8gdXBsb2FkIHRvIGFwaS52aWRlbyB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG4gICAgYXN5bmMgdXBsb2FkVmlkZW8oXG4gICAgICAgIGNvdXJzZUlkOiBzdHJpbmcsXG4gICAgICAgIHNlY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICBsZWN0dXJlSW5kZXg6IG51bWJlcixcbiAgICAgICAgdmlkZW9GaWxlOiBGaWxlLFxuICAgICAgICB0aHVtYm5haWxGaWxlPzogRmlsZSxcbiAgICAgICAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkXG4gICAgKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3ZpZGVvJywgdmlkZW9GaWxlKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdjb3Vyc2VJZCcsIGNvdXJzZUlkKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdzZWN0aW9uSW5kZXgnLCBzZWN0aW9uSW5kZXgudG9TdHJpbmcoKSk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbGVjdHVyZUluZGV4JywgbGVjdHVyZUluZGV4LnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIGlmICh0aHVtYm5haWxGaWxlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3RodW1ibmFpbCcsIHRodW1ibmFpbEZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgICAgIC8vIEh5YnJpZCBwcm9ncmVzcyB0cmFja2luZzogVHJ5IFNTRSBmaXJzdCwgZmFsbCBiYWNrIHRvIHBvbGxpbmdcbiAgICAgICAgLy8gU2ltcGxlIG1pbGVzdG9uZS1iYXNlZCBwcm9ncmVzcyB0cmFja2luZ1xuICAgICAgICBjb25zdCBwcm9ncmVzc0tleSA9IGAke2NvdXJzZUlkfS0ke3NlY3Rpb25JbmRleH0tJHtsZWN0dXJlSW5kZXh9YDtcbiAgICAgICAgbGV0IHByb2dyZXNzTWlsZXN0b25lcyA9IFsyMCwgNDAsIDYwLCA4MCwgOTAsIDEwMF07XG4gICAgICAgIGxldCBjdXJyZW50TWlsZXN0b25lSW5kZXggPSAwO1xuXG4gICAgICAgIC8vIFN0YXJ0IHByb2dyZXNzIHRyYWNraW5nIGJ5IHBlcmlvZGljYWxseSBjaGVja2luZyBiYWNrZW5kXG4gICAgICAgIGxldCBwcm9ncmVzc0NoZWNrSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBwcm9ncmVzc0NvbXBsZXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TuSBTdGFydGluZyBtaWxlc3RvbmUtYmFzZWQgcHJvZ3Jlc3MgdHJhY2tpbmcuLi4nKTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MoMCk7IC8vIFN0YXJ0IGF0IDAlXG5cbiAgICAgICAgICAgIHByb2dyZXNzQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwcm9ncmVzc0NoZWNrSW50ZXJ2YWwhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9jb3Vyc2VzL3Byb2dyZXNzLW1pbGVzdG9uZS8ke3Byb2dyZXNzS2V5fWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm1pbGVzdG9uZSAmJiBkYXRhLm1pbGVzdG9uZSA+IChwcm9ncmVzc01pbGVzdG9uZXNbY3VycmVudE1pbGVzdG9uZUluZGV4IC0gMV0gfHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TuSBQcm9ncmVzcyBtaWxlc3RvbmUgcmVhY2hlZDonLCBkYXRhLm1pbGVzdG9uZSArICclJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhkYXRhLm1pbGVzdG9uZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5taWxlc3RvbmUgPj0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwcm9ncmVzc0NoZWNrSW50ZXJ2YWwhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ/Cfk7kgUHJvZ3Jlc3MgbWlsZXN0b25lIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7IC8vIENoZWNrIGV2ZXJ5IHNlY29uZCBmb3IgbWlsZXN0b25lIHVwZGF0ZXNcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TuSBTdGFydGluZyB2aWRlbyB1cGxvYWQuLi4nKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9jb3Vyc2VzL3VwbG9hZC12aWRlb2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKGRhdGEubWVzc2FnZSB8fCAnVXBsb2FkIGZhaWxlZCcsIHJlc3BvbnNlLnN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHByb2dyZXNzIHRyYWNraW5nIGFuZCBlbnN1cmUgMTAwJVxuICAgICAgICAgICAgcHJvZ3Jlc3NDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk7kgVXBsb2FkIGNvbXBsZXRlZCAtIHNldHRpbmcgcHJvZ3Jlc3MgdG8gMTAwJScpO1xuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoMTAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBwcm9ncmVzcyB0cmFja2luZyBvbiBlcnJvclxuICAgICAgICAgICAgcHJvZ3Jlc3NDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKCdOZXR3b3JrIGVycm9yIGR1cmluZyB1cGxvYWQnLCAwLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBVcGxvYWQgdmlkZW8gZm9yIGxlY3R1cmUgKGxlZ2FjeSAtIGNvbXBsZXggcm91dGUpXG4gICAgYXN5bmMgdXBsb2FkTGVjdHVyZVZpZGVvKFxuICAgICAgICBjb3Vyc2VJZDogc3RyaW5nLFxuICAgICAgICBzZWN0aW9uSWQ6IHN0cmluZyxcbiAgICAgICAgbGVjdHVyZUlkOiBzdHJpbmcsXG4gICAgICAgIHZpZGVvRmlsZTogRmlsZSxcbiAgICAgICAgdGh1bWJuYWlsRmlsZT86IEZpbGVcbiAgICApOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgndmlkZW8nLCB2aWRlb0ZpbGUpO1xuXG4gICAgICAgIGlmICh0aHVtYm5haWxGaWxlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3RodW1ibmFpbCcsIHRodW1ibmFpbEZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9jb3Vyc2VzLyR7Y291cnNlSWR9L3NlY3Rpb25zLyR7c2VjdGlvbklkfS9sZWN0dXJlcy8ke2xlY3R1cmVJZH0vdXBsb2FkLXZpZGVvYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgfSkudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKGRhdGEubWVzc2FnZSB8fCAnVXBsb2FkIGZhaWxlZCcsIHJlc3BvbnNlLnN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5cbi8vIENhdGVnb3JpZXMgQVBJXG5leHBvcnQgY29uc3QgY2F0ZWdvcmllc0FwaSA9IHtcbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9jYXRlZ29yaWVzJyk7XG4gICAgfSxcbn07XG5cbi8vIFN0dWRlbnQvTGVhcm5lciBBUElcbmV4cG9ydCBjb25zdCBzdHVkZW50QXBpID0ge1xuICAgIC8vIEdldCBzdHVkZW50J3MgZW5yb2xsbWVudHNcbiAgICBhc3luYyBnZXRNeUVucm9sbG1lbnRzKCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvZW5yb2xsbWVudHMvbXktZW5yb2xsbWVudHMnKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHN0dWRlbnQncyBlbnJvbGxlZCBjb3Vyc2VzIHdpdGggcHJvZ3Jlc3NcbiAgICBhc3luYyBnZXRNeUNvdXJzZXMoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9lbnJvbGxtZW50cy9teS1jb3Vyc2VzJyk7XG4gICAgfSxcblxuICAgIC8vIEVucm9sbCBpbiBhIGNvdXJzZVxuICAgIGFzeW5jIGVucm9sbEluQ291cnNlKGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2Vucm9sbG1lbnRzL2Vucm9sbC8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgY291cnNlIHByb2dyZXNzXG4gICAgYXN5bmMgZ2V0Q291cnNlUHJvZ3Jlc3MoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvcHJvZ3Jlc3MvY291cnNlLyR7Y291cnNlSWR9YCk7XG4gICAgfSxcblxuICAgIC8vIE1hcmsgbGVzc29uIGFzIGNvbXBsZXRlXG4gICAgYXN5bmMgbWFya0xlc3NvbkNvbXBsZXRlKGNvdXJzZUlkOiBzdHJpbmcsIHNlY3Rpb25JZDogc3RyaW5nLCBsZWN0dXJlSWQ6IHN0cmluZywgdGltZVNwZW50PzogbnVtYmVyKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9wcm9ncmVzcy9sZXNzb24tY29tcGxldGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VJZCxcbiAgICAgICAgICAgICAgICBzZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgbGVjdHVyZUlkLFxuICAgICAgICAgICAgICAgIHRpbWVTcGVudDogdGltZVNwZW50IHx8IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBVbm1hcmsgbGVzc29uIGFzIGNvbXBsZXRlXG4gICAgYXN5bmMgdW5tYXJrTGVzc29uQ29tcGxldGUoY291cnNlSWQ6IHN0cmluZywgc2VjdGlvbklkOiBzdHJpbmcsIGxlY3R1cmVJZDogc3RyaW5nLCB0aW1lU3BlbnQ/OiBudW1iZXIpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL3Byb2dyZXNzL2xlc3Nvbi11bmNvbXBsZXRlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgY291cnNlSWQsXG4gICAgICAgICAgICAgICAgc2VjdGlvbklkLFxuICAgICAgICAgICAgICAgIGxlY3R1cmVJZCxcbiAgICAgICAgICAgICAgICB0aW1lU3BlbnQ6IHRpbWVTcGVudCB8fCAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHN0dWRlbnQgZGFzaGJvYXJkIG92ZXJ2aWV3XG4gICAgYXN5bmMgZ2V0RGFzaGJvYXJkT3ZlcnZpZXcoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9wcm9ncmVzcy9vdmVydmlldycpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgc3BlY2lmaWMgZW5yb2xsbWVudCBkZXRhaWxzXG4gICAgYXN5bmMgZ2V0RW5yb2xsbWVudERldGFpbHMoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvZW5yb2xsbWVudHMvbXktZW5yb2xsbWVudC8ke2NvdXJzZUlkfWApO1xuICAgIH0sXG59O1xuXG4vLyBDZXJ0aWZpY2F0ZSBBUElcbmV4cG9ydCBjb25zdCBjZXJ0aWZpY2F0ZUFwaSA9IHtcbiAgICAvLyBHZXQgdXNlcidzIGNlcnRpZmljYXRlc1xuICAgIGFzeW5jIGdldENlcnRpZmljYXRlcygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9jZXJ0aWZpY2F0ZXMnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHZhcmlvdXMgY2VydGlmaWNhdGUgQVBJIHVuYXZhaWxhYmlsaXR5IHNjZW5hcmlvc1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDZXJ0aWZpY2F0ZSBsaXN0IGVycm9yOicsIGVycm9yLnN0YXR1cywgZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIC8vIEZvciBhbnkgY2VydGlmaWNhdGUgQVBJIGVycm9yLCBqdXN0IHJldHVybiBlbXB0eSBsaXN0XG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGRhc2hib2FyZCBsb2FkaW5nIGlzc3Vlc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlczogW10sXG4gICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiBlcnJvci5zdGF0dXMgPT09IDQwMyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnSW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0ZvcmJpZGRlbicpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBjZXJ0aWZpY2F0ZSBieSBjb3Vyc2UgSURcbiAgICBhc3luYyBnZXRDZXJ0aWZpY2F0ZUJ5Q291cnNlKGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jZXJ0aWZpY2F0ZXMvY291cnNlLyR7Y291cnNlSWR9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB2YXJpb3VzIGNlcnRpZmljYXRlIEFQSSB1bmF2YWlsYWJpbGl0eSBzY2VuYXJpb3NcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2VydGlmaWNhdGUgQVBJIGVycm9yOicsIGVycm9yLnN0YXR1cywgZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgbm90IGZvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnSW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0ZvcmJpZGRlbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBhY2Nlc3MgZGVuaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YXR1cyA9PT0gMCB8fCBlcnJvci5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgc2VydmljZSB1bmF2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3IgYW55IG90aGVyIGVycm9yLCByZXR1cm4gYSBnZW5lcmljIHVuYXZhaWxhYmxlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGNlcnRpZmljYXRlIGZvciBjb21wbGV0ZWQgY291cnNlXG4gICAgYXN5bmMgZ2VuZXJhdGVDZXJ0aWZpY2F0ZShjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2VydGlmaWNhdGVzL2dlbmVyYXRlLyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHZhcmlvdXMgY2VydGlmaWNhdGUgQVBJIHVuYXZhaWxhYmlsaXR5IHNjZW5hcmlvc1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDZXJ0aWZpY2F0ZSBnZW5lcmF0aW9uIGVycm9yOicsIGVycm9yLnN0YXR1cywgZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgZ2VuZXJhdGlvbiBub3QgYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAzIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRm9yYmlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGdlbmVyYXRpb24gYWNjZXNzIGRlbmllZCcsXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDAgfHwgZXJyb3Iuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIHNlcnZpY2UgdW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIGFueSBvdGhlciBlcnJvciwgcmV0dXJuIGEgZ2VuZXJpYyB1bmF2YWlsYWJsZSByZXNwb25zZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgZ2VuZXJhdGlvbiB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBjZXJ0aWZpY2F0ZSBieSBJRFxuICAgIGFzeW5jIGdldENlcnRpZmljYXRlKGNlcnRpZmljYXRlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2VydGlmaWNhdGVzLyR7Y2VydGlmaWNhdGVJZH1gKTtcbiAgICB9LFxuXG4gICAgLy8gRG93bmxvYWQgY2VydGlmaWNhdGVcbiAgICBhc3luYyBkb3dubG9hZENlcnRpZmljYXRlKGNlcnRpZmljYXRlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2VydGlmaWNhdGVzLyR7Y2VydGlmaWNhdGVJZH0vZG93bmxvYWRgKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGNlcnRpZmljYXRlIGltYWdlIHdpdGggY3VzdG9tIHRleHQgb3ZlcmxheXNcbiAgICBhc3luYyBnZXRDZXJ0aWZpY2F0ZUltYWdlKGNlcnRpZmljYXRlSWQ6IHN0cmluZyk6IFByb21pc2U8QmxvYj4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vY2VydGlmaWNhdGVzLyR7Y2VydGlmaWNhdGVJZH0vaW1hZ2VgLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7Z2V0VG9rZW4oKX1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY2VydGlmaWNhdGUgaW1hZ2UnLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICB9LFxufTtcblxuLy8gVmlkZW8gQVBJXG5leHBvcnQgY29uc3QgdmlkZW9BcGkgPSB7XG4gICAgLy8gR2V0IHZpZGVvIGRldGFpbHMgZnJvbSBhcGkudmlkZW9cbiAgICBhc3luYyBnZXRWaWRlb0RldGFpbHModmlkZW9JZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC92aWRlb3MvJHt2aWRlb0lkfWApO1xuICAgIH0sXG59O1xuXG4vLyBDYXJ0IEFQSVxuZXhwb3J0IGNvbnN0IGNhcnRBcGkgPSB7XG4gICAgLy8gR2V0IHVzZXIncyBjYXJ0XG4gICAgYXN5bmMgZ2V0Q2FydCgpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2NhcnQnKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGNvdXJzZSB0byBjYXJ0XG4gICAgYXN5bmMgYWRkVG9DYXJ0KGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NhcnQvJHtjb3Vyc2VJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGNvdXJzZSBmcm9tIGNhcnRcbiAgICBhc3luYyByZW1vdmVGcm9tQ2FydChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jYXJ0LyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgY291cnNlIGlzIGluIGNhcnRcbiAgICBhc3luYyBjaGVja0luQ2FydChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jYXJ0L2NoZWNrLyR7Y291cnNlSWR9YCk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGVudGlyZSBjYXJ0XG4gICAgYXN5bmMgY2xlYXJDYXJ0KCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvY2FydCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5cbi8vIFdpc2hsaXN0IEFQSVxuZXhwb3J0IGNvbnN0IHdpc2hsaXN0QXBpID0ge1xuICAgIC8vIEdldCB1c2VyJ3Mgd2lzaGxpc3RcbiAgICBhc3luYyBnZXRXaXNobGlzdCgpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL3dpc2hsaXN0Jyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBjb3Vyc2UgdG8gd2lzaGxpc3RcbiAgICBhc3luYyBhZGRUb1dpc2hsaXN0KGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3dpc2hsaXN0LyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBjb3Vyc2UgZnJvbSB3aXNobGlzdFxuICAgIGFzeW5jIHJlbW92ZUZyb21XaXNobGlzdChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC93aXNobGlzdC8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIGNvdXJzZSBpcyBpbiB3aXNobGlzdFxuICAgIGFzeW5jIGNoZWNrSW5XaXNobGlzdChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC93aXNobGlzdC9jaGVjay8ke2NvdXJzZUlkfWApO1xuICAgIH0sXG59O1xuXG4vLyBFeHBvcnQgaGVscGVyIGZ1bmN0aW9uc1xuZXhwb3J0IHsgQXBpRXJyb3IsIGdldFRva2VuLCBzZXRUb2tlbiwgcmVtb3ZlVG9rZW4gfTsiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBcGlFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwiZGF0YSIsIm5hbWUiLCJnZXRUb2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRUb2tlbiIsInRva2VuIiwic2V0SXRlbSIsInJlbW92ZVRva2VuIiwicmVtb3ZlSXRlbSIsImFwaVJlcXVlc3QiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJ1cmwiLCJjb25maWciLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJqc29uIiwiZSIsIm9rIiwiZXJyb3IiLCJhdXRoQXBpIiwibG9naW4iLCJwYXlsb2FkIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWdpc3RlciIsImVtYWlsIiwicGFzc3dvcmQiLCJnZXRQcm9maWxlIiwidXBkYXRlUHJvZmlsZSIsInByb2ZpbGVEYXRhIiwidXBkYXRlSW5zdHJ1Y3RvclByb2ZpbGUiLCJpbnN0cnVjdG9yRGF0YSIsImxvZ291dCIsImNvdXJzZXNBcGkiLCJnZXRQdWJsaXNoZWQiLCJwYXJhbXMiLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidW5kZWZpbmVkIiwiYXBwZW5kIiwidG9TdHJpbmciLCJnZXREYXNoYm9hcmRTdGF0cyIsImdldE15Q291cnNlcyIsImNyZWF0ZURyYWZ0IiwiZm9ybURhdGEiLCJ1cGRhdGVCYXNpY0luZm8iLCJjb3Vyc2VJZCIsImdldENvdXJzZSIsImdldEJ5SWQiLCJ1cGRhdGUiLCJhZGRTZWN0aW9uIiwic2VjdGlvbkRhdGEiLCJhZGRMZWN0dXJlIiwic2VjdGlvbklkIiwibGVjdHVyZURhdGEiLCJ1cGRhdGVMZWN0dXJlIiwibGVjdHVyZUlkIiwidG9nZ2xlUHVibGlzaCIsInB1Ymxpc2giLCJkZWxldGVDb3Vyc2UiLCJkZWxldGVMZWN0dXJlIiwidGVzdFNTRSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY29uc29sZSIsImxvZyIsInNzZVVybCIsImV2ZW50U291cmNlIiwiRXZlbnRTb3VyY2UiLCJtZXNzYWdlQ291bnQiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJldmVudCIsInBhcnNlIiwiY29tcGxldGUiLCJjbG9zZSIsIm9uZXJyb3IiLCJzZXRUaW1lb3V0Iiwid2FybiIsInRlc3RDT1JTIiwidXBsb2FkVmlkZW8iLCJzZWN0aW9uSW5kZXgiLCJsZWN0dXJlSW5kZXgiLCJ2aWRlb0ZpbGUiLCJ0aHVtYm5haWxGaWxlIiwib25Qcm9ncmVzcyIsIkZvcm1EYXRhIiwicHJvZ3Jlc3NLZXkiLCJwcm9ncmVzc01pbGVzdG9uZXMiLCJjdXJyZW50TWlsZXN0b25lSW5kZXgiLCJwcm9ncmVzc0NoZWNrSW50ZXJ2YWwiLCJwcm9ncmVzc0NvbXBsZXRlZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm1pbGVzdG9uZSIsInVwbG9hZExlY3R1cmVWaWRlbyIsInRoZW4iLCJjYXRlZ29yaWVzQXBpIiwiZ2V0QWxsIiwic3R1ZGVudEFwaSIsImdldE15RW5yb2xsbWVudHMiLCJlbnJvbGxJbkNvdXJzZSIsImdldENvdXJzZVByb2dyZXNzIiwibWFya0xlc3NvbkNvbXBsZXRlIiwidGltZVNwZW50IiwidW5tYXJrTGVzc29uQ29tcGxldGUiLCJnZXREYXNoYm9hcmRPdmVydmlldyIsImdldEVucm9sbG1lbnREZXRhaWxzIiwiY2VydGlmaWNhdGVBcGkiLCJnZXRDZXJ0aWZpY2F0ZXMiLCJzdWNjZXNzIiwiY2VydGlmaWNhdGVzIiwic2VydmljZVVuYXZhaWxhYmxlIiwiaW5jbHVkZXMiLCJnZXRDZXJ0aWZpY2F0ZUJ5Q291cnNlIiwiY2VydGlmaWNhdGUiLCJnZW5lcmF0ZUNlcnRpZmljYXRlIiwiZ2V0Q2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZUlkIiwiZG93bmxvYWRDZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlSW1hZ2UiLCJibG9iIiwidmlkZW9BcGkiLCJnZXRWaWRlb0RldGFpbHMiLCJ2aWRlb0lkIiwiY2FydEFwaSIsImdldENhcnQiLCJhZGRUb0NhcnQiLCJyZW1vdmVGcm9tQ2FydCIsImNoZWNrSW5DYXJ0IiwiY2xlYXJDYXJ0Iiwid2lzaGxpc3RBcGkiLCJnZXRXaXNobGlzdCIsImFkZFRvV2lzaGxpc3QiLCJyZW1vdmVGcm9tV2lzaGxpc3QiLCJjaGVja0luV2lzaGxpc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});