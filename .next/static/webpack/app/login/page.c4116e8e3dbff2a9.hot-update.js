"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   authApi: () => (/* binding */ authApi),\n/* harmony export */   cartApi: () => (/* binding */ cartApi),\n/* harmony export */   certificateApi: () => (/* binding */ certificateApi),\n/* harmony export */   citiesApi: () => (/* binding */ citiesApi),\n/* harmony export */   getToken: () => (/* binding */ getToken),\n/* harmony export */   removeToken: () => (/* binding */ removeToken),\n/* harmony export */   setToken: () => (/* binding */ setToken),\n/* harmony export */   showsApi: () => (/* binding */ showsApi),\n/* harmony export */   studentApi: () => (/* binding */ studentApi),\n/* harmony export */   theatersApi: () => (/* binding */ theatersApi),\n/* harmony export */   videoApi: () => (/* binding */ videoApi),\n/* harmony export */   wishlistApi: () => (/* binding */ wishlistApi)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// API service layer for connecting frontend to backend\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';\nclass ApiError extends Error {\n    constructor(message, status, data = null){\n        super(message);\n        this.name = 'ApiError';\n        this.status = status;\n        this.data = data;\n    }\n}\n// Token management\nconst getToken = ()=>{\n    if (true) {\n        return localStorage.getItem('aiq-token');\n    }\n    return null;\n};\nconst setToken = (token)=>{\n    if (true) {\n        localStorage.setItem('aiq-token', token);\n    }\n};\nconst removeToken = ()=>{\n    if (true) {\n        localStorage.removeItem('aiq-token');\n    }\n};\n// Base API request function\nconst apiRequest = async function(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    const token = getToken();\n    const config = {\n        headers: {\n            'Content-Type': 'application/json',\n            ...options.headers\n        },\n        ...options\n    };\n    // Add authentication header if token exists\n    if (token) {\n        config.headers.Authorization = \"Bearer \".concat(token);\n    }\n    try {\n        const response = await fetch(url, config);\n        let data;\n        try {\n            data = await response.json();\n        } catch (e) {\n            data = null;\n        }\n        if (!response.ok) {\n            // Handle 401 Unauthorized specifically\n            if (response.status === 401) {\n                // Token might be expired, remove it\n                removeToken();\n                if (true) {\n                    localStorage.removeItem('aiq-user');\n                }\n            }\n            throw new ApiError((data === null || data === void 0 ? void 0 : data.message) || \"HTTP error! status: \".concat(response.status), response.status, data);\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        throw new ApiError('Network error occurred', 0);\n    }\n};\n// Auth API\nconst authApi = {\n    // Login\n    async login (payload) {\n        const data = await apiRequest('/auth/login', {\n            method: 'POST',\n            body: JSON.stringify(payload)\n        });\n        if (data.token) {\n            setToken(data.token);\n        }\n        return data;\n    },\n    // Register\n    async register (payload) {\n        const data = await apiRequest('/auth/register', {\n            method: 'POST',\n            body: JSON.stringify(payload)\n        });\n        if (data.token) {\n            setToken(data.token);\n        }\n        return data;\n    },\n    // Get current user profile\n    async getProfile () {\n        return await apiRequest('/auth/profile');\n    },\n    // Update profile\n    async updateProfile (profileData) {\n        return await apiRequest('/auth/profile', {\n            method: 'PUT',\n            body: JSON.stringify(profileData)\n        });\n    },\n    // Update instructor profile\n    async updateInstructorProfile (instructorData) {\n        return await apiRequest('/auth/instructor-profile', {\n            method: 'PUT',\n            body: JSON.stringify(instructorData)\n        });\n    },\n    // Logout\n    logout () {\n        removeToken();\n        if (true) {\n            localStorage.removeItem('aiq-user');\n        }\n    }\n};\n// City API\nconst citiesApi = {\n    //  Get all cities (public endpoint)\n    async getAll () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/cities?\".concat(queryParams));\n    },\n    //  Get single city by ID\n    async getById (id) {\n        return await apiRequest(\"/cities/\".concat(id));\n    },\n    //  Create new city (Admin only)\n    async create (data) {\n        const token = getToken();\n        return await apiRequest(\"/cities\", {\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n    },\n    // Update existing city\n    async update (id, data) {\n        const token = getToken();\n        return await apiRequest(\"/cities/\".concat(id), {\n            method: \"PUT\",\n            headers: {\n                Authorization: \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n    },\n    // Delete city\n    async delete (id) {\n        const token = getToken();\n        return await apiRequest(\"/cities/\".concat(id), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"Bearer \".concat(token)\n            }\n        });\n    }\n};\n// theater\nconst theatersApi = {\n    //  Get all theaters (public)\n    async getAll () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/theaters?\".concat(queryParams));\n    },\n    //  Get a theater by ID\n    async getById (id) {\n        return await apiRequest(\"/theaters/\".concat(id));\n    },\n    //  Create a new theater (admin only)\n    async create (theaterData) {\n        const token = getToken();\n        return await apiRequest(\"/theaters\", {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(theaterData)\n        });\n    },\n    //  Update theater (admin only)\n    async update (id, updateData) {\n        const token = getToken();\n        return await apiRequest(\"/theaters/\".concat(id), {\n            method: \"PUT\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(updateData)\n        });\n    },\n    //  Delete theater (admin only)\n    async delete (id) {\n        const token = getToken();\n        return await apiRequest(\"/theaters/\".concat(id), {\n            method: \"DELETE\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(token)\n            }\n        });\n    }\n};\nconst showsApi = {\n    //  Get all shows (public)\n    async getAll () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/shows?\".concat(queryParams));\n    },\n    //  Get show by ID\n    async getById (id) {\n        return await apiRequest(\"/shows/\".concat(id));\n    },\n    //  Create new show (admin only)\n    async create (showData) {\n        const token = getToken();\n        return await apiRequest(\"/shows\", {\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(showData)\n        });\n    },\n    //  Update show (admin only)\n    async update (id, updateData) {\n        const token = getToken();\n        return await apiRequest(\"/shows/\".concat(id), {\n            method: \"PUT\",\n            headers: {\n                Authorization: \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(updateData)\n        });\n    },\n    //  Delete show (admin only)\n    async delete (id) {\n        const token = getToken();\n        return await apiRequest(\"/shows/\".concat(id), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"Bearer \".concat(token)\n            }\n        });\n    }\n};\n// Student/Learner API\nconst studentApi = {\n    // Get student's enrollments\n    async getMyEnrollments () {\n        return await apiRequest('/enrollments/my-enrollments');\n    },\n    // Get student's enrolled courses with progress\n    async getMyCourses () {\n        return await apiRequest('/enrollments/my-courses');\n    },\n    // Enroll in a course\n    async enrollInCourse (courseId) {\n        return await apiRequest(\"/enrollments/enroll/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Get course progress\n    async getCourseProgress (courseId) {\n        return await apiRequest(\"/progress/course/\".concat(courseId));\n    },\n    // Mark lesson as complete\n    async markLessonComplete (courseId, sectionId, lectureId, timeSpent) {\n        return await apiRequest('/progress/lesson-complete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                courseId,\n                sectionId,\n                lectureId,\n                timeSpent: timeSpent || 0\n            })\n        });\n    },\n    // Unmark lesson as complete\n    async unmarkLessonComplete (courseId, sectionId, lectureId, timeSpent) {\n        return await apiRequest('/progress/lesson-uncomplete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                courseId,\n                sectionId,\n                lectureId,\n                timeSpent: timeSpent || 0\n            })\n        });\n    },\n    // Get student dashboard overview\n    async getDashboardOverview () {\n        return await apiRequest('/progress/overview');\n    },\n    // Get specific enrollment details\n    async getEnrollmentDetails (courseId) {\n        return await apiRequest(\"/enrollments/my-enrollment/\".concat(courseId));\n    }\n};\n// Certificate API\nconst certificateApi = {\n    // Get user's certificates\n    async getCertificates () {\n        try {\n            return await apiRequest('/certificates');\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate list error:', error.status, error.message);\n            // For any certificate API error, just return empty list\n            // This prevents dashboard loading issues\n            return {\n                success: true,\n                certificates: [],\n                serviceUnavailable: error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))\n            };\n        }\n    },\n    // Get certificate by course ID\n    async getCertificateByCourse (courseId) {\n        try {\n            return await apiRequest(\"/certificates/course/\".concat(courseId));\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate API error:', error.status, error.message);\n            if (error.status === 404) {\n                return {\n                    success: false,\n                    message: 'Certificate not found',\n                    certificate: null\n                };\n            } else if (error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))) {\n                return {\n                    success: false,\n                    message: 'Certificate access denied',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 0 || error.status === 500) {\n                return {\n                    success: false,\n                    message: 'Certificate service unavailable',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            }\n            // For any other error, return a generic unavailable response\n            return {\n                success: false,\n                message: 'Certificate temporarily unavailable',\n                certificate: null,\n                serviceUnavailable: true\n            };\n        }\n    },\n    // Generate certificate for completed course\n    async generateCertificate (courseId) {\n        try {\n            return await apiRequest(\"/certificates/generate/\".concat(courseId), {\n                method: 'POST'\n            });\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate generation error:', error.status, error.message);\n            if (error.status === 404) {\n                return {\n                    success: false,\n                    message: 'Certificate generation not available',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))) {\n                return {\n                    success: false,\n                    message: 'Certificate generation access denied',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 0 || error.status === 500) {\n                return {\n                    success: false,\n                    message: 'Certificate service unavailable',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            }\n            // For any other error, return a generic unavailable response\n            return {\n                success: false,\n                message: 'Certificate generation temporarily unavailable',\n                certificate: null,\n                serviceUnavailable: true\n            };\n        }\n    },\n    // Get certificate by ID\n    async getCertificate (certificateId) {\n        return await apiRequest(\"/certificates/\".concat(certificateId));\n    },\n    // Download certificate\n    async downloadCertificate (certificateId) {\n        return await apiRequest(\"/certificates/\".concat(certificateId, \"/download\"));\n    },\n    // Get certificate image with custom text overlays\n    async getCertificateImage (certificateId) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/certificates/\").concat(certificateId, \"/image\"), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getToken())\n            }\n        });\n        if (!response.ok) {\n            throw new ApiError('Failed to fetch certificate image', response.status);\n        }\n        return await response.blob();\n    }\n};\n// Video API\nconst videoApi = {\n    // Get video details from api.video\n    async getVideoDetails (videoId) {\n        return await apiRequest(\"/videos/\".concat(videoId));\n    }\n};\n// Cart API\nconst cartApi = {\n    // Get user's cart\n    async getCart () {\n        return await apiRequest('/cart');\n    },\n    // Add course to cart\n    async addToCart (courseId) {\n        return await apiRequest(\"/cart/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Remove course from cart\n    async removeFromCart (courseId) {\n        return await apiRequest(\"/cart/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Check if course is in cart\n    async checkInCart (courseId) {\n        return await apiRequest(\"/cart/check/\".concat(courseId));\n    },\n    // Clear entire cart\n    async clearCart () {\n        return await apiRequest('/cart', {\n            method: 'DELETE'\n        });\n    }\n};\n// Wishlist API\nconst wishlistApi = {\n    // Get user's wishlist\n    async getWishlist () {\n        return await apiRequest('/wishlist');\n    },\n    // Add course to wishlist\n    async addToWishlist (courseId) {\n        return await apiRequest(\"/wishlist/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Remove course from wishlist\n    async removeFromWishlist (courseId) {\n        return await apiRequest(\"/wishlist/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Check if course is in wishlist\n    async checkInWishlist (courseId) {\n        return await apiRequest(\"/wishlist/check/\".concat(courseId));\n    }\n};\n// Export helper functions\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU10RixXQUF3QixTQUFTO1lBQzFDZ0IsUUFBUTtRQUNaO0lBQ0o7QUFDSixFQUFFO0FBRUYsZUFBZTtBQUNSLE1BQU11RSxjQUFjO0lBQ3ZCLHNCQUFzQjtJQUN0QixNQUFNQztRQUNGLE9BQU8sTUFBTXhGLFdBQXdCO0lBQ3pDO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU15RixlQUFjcEMsUUFBZ0I7UUFDaEMsT0FBTyxNQUFNckQsV0FBd0IsYUFBc0IsT0FBVHFELFdBQVk7WUFDMURyQyxRQUFRO1FBQ1o7SUFDSjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNMEUsb0JBQW1CckMsUUFBZ0I7UUFDckMsT0FBTyxNQUFNckQsV0FBd0IsYUFBc0IsT0FBVHFELFdBQVk7WUFDMURyQyxRQUFRO1FBQ1o7SUFDSjtJQUVBLGlDQUFpQztJQUNqQyxNQUFNMkUsaUJBQWdCdEMsUUFBZ0I7UUFDbEMsT0FBTyxNQUFNckQsV0FBd0IsbUJBQTRCLE9BQVRxRDtJQUM1RDtBQUNKLEVBQUU7QUFFRiwwQkFBMEI7QUFDMkIiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0XFxDb25jZXJ0IFRpY2tldGluZ1xcVGlja2V0aW5nVWlcXHNyY1xcbGliXFxhcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVBJIHNlcnZpY2UgbGF5ZXIgZm9yIGNvbm5lY3RpbmcgZnJvbnRlbmQgdG8gYmFja2VuZFxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaSc7XG5cbmludGVyZmFjZSBBcGlSZXNwb25zZTxUID0gYW55PiB7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgICB0b2tlbj86IHN0cmluZztcbiAgICB1c2VyPzogYW55O1xuICAgIGRhdGE/OiBUO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgZGF0YTogYW55O1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgZGF0YTogYW55ID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuXG4vLyBUb2tlbiBtYW5hZ2VtZW50XG5jb25zdCBnZXRUb2tlbiA9ICgpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhaXEtdG9rZW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBzZXRUb2tlbiA9ICh0b2tlbjogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhaXEtdG9rZW4nLCB0b2tlbik7XG4gICAgfVxufTtcblxuY29uc3QgcmVtb3ZlVG9rZW4gPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhaXEtdG9rZW4nKTtcbiAgICB9XG59O1xuXG4vLyBCYXNlIEFQSSByZXF1ZXN0IGZ1bmN0aW9uXG5jb25zdCBhcGlSZXF1ZXN0ID0gYXN5bmMgPFQgPSBhbnk+KGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ICYgeyBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB9ID0ge30pOiBQcm9taXNlPFQ+ID0+IHtcbiAgICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgIGNvbnN0IGNvbmZpZzogUmVxdWVzdEluaXQgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIC8vIEFkZCBhdXRoZW50aWNhdGlvbiBoZWFkZXIgaWYgdG9rZW4gZXhpc3RzXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAgIChjb25maWcuaGVhZGVycyBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KS5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSA0MDEgVW5hdXRob3JpemVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gbWlnaHQgYmUgZXhwaXJlZCwgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FpcS11c2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoXG4gICAgICAgICAgICAgICAgZGF0YT8ubWVzc2FnZSB8fCBgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcignTmV0d29yayBlcnJvciBvY2N1cnJlZCcsIDApO1xuICAgIH1cbn07XG5cbi8vIEF1dGggQVBJXG5leHBvcnQgY29uc3QgYXV0aEFwaSA9IHtcbiAgICAvLyBMb2dpblxuICAgIGFzeW5jIGxvZ2luKHBheWxvYWQpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2F1dGgvbG9naW4nLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGF0YS50b2tlbikge1xuICAgICAgICAgICAgc2V0VG9rZW4oZGF0YS50b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLy8gUmVnaXN0ZXJcbiAgICBhc3luYyByZWdpc3RlcihwYXlsb2FkKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9hdXRoL3JlZ2lzdGVyJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGEudG9rZW4pIHtcbiAgICAgICAgICAgIHNldFRva2VuKGRhdGEudG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8vIEdldCBjdXJyZW50IHVzZXIgcHJvZmlsZVxuICAgIGFzeW5jIGdldFByb2ZpbGUoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9hdXRoL3Byb2ZpbGUnKTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIHByb2ZpbGVcbiAgICBhc3luYyB1cGRhdGVQcm9maWxlKHByb2ZpbGVEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9hdXRoL3Byb2ZpbGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJvZmlsZURhdGEpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGluc3RydWN0b3IgcHJvZmlsZVxuICAgIGFzeW5jIHVwZGF0ZUluc3RydWN0b3JQcm9maWxlKGluc3RydWN0b3JEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9hdXRoL2luc3RydWN0b3ItcHJvZmlsZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnN0cnVjdG9yRGF0YSksXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBMb2dvdXRcbiAgICBsb2dvdXQoKTogdm9pZCB7XG4gICAgICAgIHJlbW92ZVRva2VuKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FpcS11c2VyJyk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuLy8gQ2l0eSBBUElcbmV4cG9ydCBjb25zdCBjaXRpZXNBcGkgPSB7XG4gICAgLy8gIEdldCBhbGwgY2l0aWVzIChwdWJsaWMgZW5kcG9pbnQpXG4gICAgYXN5bmMgZ2V0QWxsKHBhcmFtczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2l0aWVzPyR7cXVlcnlQYXJhbXN9YCk7XG4gICAgfSxcblxuICAgIC8vICBHZXQgc2luZ2xlIGNpdHkgYnkgSURcbiAgICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NpdGllcy8ke2lkfWApO1xuICAgIH0sXG5cbiAgICAvLyAgQ3JlYXRlIG5ldyBjaXR5IChBZG1pbiBvbmx5KVxuICAgIGFzeW5jIGNyZWF0ZShkYXRhOiB7IG5hbWU6IHN0cmluZzsgc3RhdGU6IHN0cmluZzsgY291bnRyeT86IHN0cmluZyB9KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihcIi9jaXRpZXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjaXR5XG4gICAgYXN5bmMgdXBkYXRlKFxuICAgICAgICBpZDogc3RyaW5nLFxuICAgICAgICBkYXRhOiB7IG5hbWU/OiBzdHJpbmc7IHN0YXRlPzogc3RyaW5nOyBjb3VudHJ5Pzogc3RyaW5nOyBpc0FjdGl2ZT86IGJvb2xlYW4gfVxuICAgICk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NpdGllcy8ke2lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERlbGV0ZSBjaXR5XG4gICAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jaXRpZXMvJHtpZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcblxuXG5cbi8vIHRoZWF0ZXJcbmV4cG9ydCBjb25zdCB0aGVhdGVyc0FwaSA9IHtcbiAgLy8gIEdldCBhbGwgdGhlYXRlcnMgKHB1YmxpYylcbiAgYXN5bmMgZ2V0QWxsKHBhcmFtczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChwYXJhbXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHBhcmFtc1trZXldLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvdGhlYXRlcnM/JHtxdWVyeVBhcmFtc31gKTtcbiAgfSxcblxuICAvLyAgR2V0IGEgdGhlYXRlciBieSBJRFxuICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvdGhlYXRlcnMvJHtpZH1gKTtcbiAgfSxcblxuICAvLyAgQ3JlYXRlIGEgbmV3IHRoZWF0ZXIgKGFkbWluIG9ubHkpXG4gIGFzeW5jIGNyZWF0ZSh0aGVhdGVyRGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG5cbiAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oXCIvdGhlYXRlcnNcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0aGVhdGVyRGF0YSksXG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gIFVwZGF0ZSB0aGVhdGVyIChhZG1pbiBvbmx5KVxuICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgdXBkYXRlRGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG5cbiAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC90aGVhdGVycy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcbiAgICB9KTtcbiAgfSxcblxuICAvLyAgRGVsZXRlIHRoZWF0ZXIgKGFkbWluIG9ubHkpXG4gIGFzeW5jIGRlbGV0ZShpZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3RoZWF0ZXJzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufTtcblxuXG5cbmV4cG9ydCBjb25zdCBzaG93c0FwaSA9IHtcbiAgLy8gIEdldCBhbGwgc2hvd3MgKHB1YmxpYylcbiAgYXN5bmMgZ2V0QWxsKHBhcmFtczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChwYXJhbXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHBhcmFtc1trZXldLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvc2hvd3M/JHtxdWVyeVBhcmFtc31gKTtcbiAgfSxcblxuICAvLyAgR2V0IHNob3cgYnkgSURcbiAgYXN5bmMgZ2V0QnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3Nob3dzLyR7aWR9YCk7XG4gIH0sXG5cbiAgLy8gIENyZWF0ZSBuZXcgc2hvdyAoYWRtaW4gb25seSlcbiAgYXN5bmMgY3JlYXRlKHNob3dEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihcIi9zaG93c1wiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2hvd0RhdGEpLFxuICAgIH0pO1xuICB9LFxuXG4gIC8vICBVcGRhdGUgc2hvdyAoYWRtaW4gb25seSlcbiAgYXN5bmMgdXBkYXRlKGlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvc2hvd3MvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcbiAgICB9KTtcbiAgfSxcblxuICAvLyAgRGVsZXRlIHNob3cgKGFkbWluIG9ubHkpXG4gIGFzeW5jIGRlbGV0ZShpZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3Nob3dzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG59O1xuXG5cblxuXG5cblxuXG5cblxuLy8gU3R1ZGVudC9MZWFybmVyIEFQSVxuZXhwb3J0IGNvbnN0IHN0dWRlbnRBcGkgPSB7XG4gICAgLy8gR2V0IHN0dWRlbnQncyBlbnJvbGxtZW50c1xuICAgIGFzeW5jIGdldE15RW5yb2xsbWVudHMoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9lbnJvbGxtZW50cy9teS1lbnJvbGxtZW50cycpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgc3R1ZGVudCdzIGVucm9sbGVkIGNvdXJzZXMgd2l0aCBwcm9ncmVzc1xuICAgIGFzeW5jIGdldE15Q291cnNlcygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2Vucm9sbG1lbnRzL215LWNvdXJzZXMnKTtcbiAgICB9LFxuXG4gICAgLy8gRW5yb2xsIGluIGEgY291cnNlXG4gICAgYXN5bmMgZW5yb2xsSW5Db3Vyc2UoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvZW5yb2xsbWVudHMvZW5yb2xsLyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCBjb3Vyc2UgcHJvZ3Jlc3NcbiAgICBhc3luYyBnZXRDb3Vyc2VQcm9ncmVzcyhjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9wcm9ncmVzcy9jb3Vyc2UvJHtjb3Vyc2VJZH1gKTtcbiAgICB9LFxuXG4gICAgLy8gTWFyayBsZXNzb24gYXMgY29tcGxldGVcbiAgICBhc3luYyBtYXJrTGVzc29uQ29tcGxldGUoY291cnNlSWQ6IHN0cmluZywgc2VjdGlvbklkOiBzdHJpbmcsIGxlY3R1cmVJZDogc3RyaW5nLCB0aW1lU3BlbnQ/OiBudW1iZXIpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL3Byb2dyZXNzL2xlc3Nvbi1jb21wbGV0ZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGNvdXJzZUlkLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBsZWN0dXJlSWQsXG4gICAgICAgICAgICAgICAgdGltZVNwZW50OiB0aW1lU3BlbnQgfHwgMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFVubWFyayBsZXNzb24gYXMgY29tcGxldGVcbiAgICBhc3luYyB1bm1hcmtMZXNzb25Db21wbGV0ZShjb3Vyc2VJZDogc3RyaW5nLCBzZWN0aW9uSWQ6IHN0cmluZywgbGVjdHVyZUlkOiBzdHJpbmcsIHRpbWVTcGVudD86IG51bWJlcik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvcHJvZ3Jlc3MvbGVzc29uLXVuY29tcGxldGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBjb3Vyc2VJZCxcbiAgICAgICAgICAgICAgICBzZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgbGVjdHVyZUlkLFxuICAgICAgICAgICAgICAgIHRpbWVTcGVudDogdGltZVNwZW50IHx8IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgc3R1ZGVudCBkYXNoYm9hcmQgb3ZlcnZpZXdcbiAgICBhc3luYyBnZXREYXNoYm9hcmRPdmVydmlldygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL3Byb2dyZXNzL292ZXJ2aWV3Jyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBzcGVjaWZpYyBlbnJvbGxtZW50IGRldGFpbHNcbiAgICBhc3luYyBnZXRFbnJvbGxtZW50RGV0YWlscyhjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9lbnJvbGxtZW50cy9teS1lbnJvbGxtZW50LyR7Y291cnNlSWR9YCk7XG4gICAgfSxcbn07XG5cbi8vIENlcnRpZmljYXRlIEFQSVxuZXhwb3J0IGNvbnN0IGNlcnRpZmljYXRlQXBpID0ge1xuICAgIC8vIEdldCB1c2VyJ3MgY2VydGlmaWNhdGVzXG4gICAgYXN5bmMgZ2V0Q2VydGlmaWNhdGVzKCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2NlcnRpZmljYXRlcycpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdmFyaW91cyBjZXJ0aWZpY2F0ZSBBUEkgdW5hdmFpbGFiaWxpdHkgc2NlbmFyaW9zXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NlcnRpZmljYXRlIGxpc3QgZXJyb3I6JywgZXJyb3Iuc3RhdHVzLCBlcnJvci5tZXNzYWdlKTtcblxuICAgICAgICAgICAgLy8gRm9yIGFueSBjZXJ0aWZpY2F0ZSBBUEkgZXJyb3IsIGp1c3QgcmV0dXJuIGVtcHR5IGxpc3RcbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgZGFzaGJvYXJkIGxvYWRpbmcgaXNzdWVzXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IGVycm9yLnN0YXR1cyA9PT0gNDAzIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRm9yYmlkZGVuJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2V0IGNlcnRpZmljYXRlIGJ5IGNvdXJzZSBJRFxuICAgIGFzeW5jIGdldENlcnRpZmljYXRlQnlDb3Vyc2UoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NlcnRpZmljYXRlcy9jb3Vyc2UvJHtjb3Vyc2VJZH1gKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHZhcmlvdXMgY2VydGlmaWNhdGUgQVBJIHVuYXZhaWxhYmlsaXR5IHNjZW5hcmlvc1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDZXJ0aWZpY2F0ZSBBUEkgZXJyb3I6JywgZXJyb3Iuc3RhdHVzLCBlcnJvci5tZXNzYWdlKTtcblxuICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBub3QgZm91bmQnLFxuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAzIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRm9yYmlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGFjY2VzcyBkZW5pZWQnLFxuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID09PSAwIHx8IGVycm9yLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBzZXJ2aWNlIHVuYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBhbnkgb3RoZXIgZXJyb3IsIHJldHVybiBhIGdlbmVyaWMgdW5hdmFpbGFibGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2VuZXJhdGUgY2VydGlmaWNhdGUgZm9yIGNvbXBsZXRlZCBjb3Vyc2VcbiAgICBhc3luYyBnZW5lcmF0ZUNlcnRpZmljYXRlKGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jZXJ0aWZpY2F0ZXMvZ2VuZXJhdGUvJHtjb3Vyc2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdmFyaW91cyBjZXJ0aWZpY2F0ZSBBUEkgdW5hdmFpbGFiaWxpdHkgc2NlbmFyaW9zXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NlcnRpZmljYXRlIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyb3Iuc3RhdHVzLCBlcnJvci5tZXNzYWdlKTtcblxuICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBnZW5lcmF0aW9uIG5vdCBhdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDMgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0luc3VmZmljaWVudCBwZXJtaXNzaW9ucycpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdGb3JiaWRkZW4nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgZ2VuZXJhdGlvbiBhY2Nlc3MgZGVuaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YXR1cyA9PT0gMCB8fCBlcnJvci5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgc2VydmljZSB1bmF2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3IgYW55IG90aGVyIGVycm9yLCByZXR1cm4gYSBnZW5lcmljIHVuYXZhaWxhYmxlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBnZW5lcmF0aW9uIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2V0IGNlcnRpZmljYXRlIGJ5IElEXG4gICAgYXN5bmMgZ2V0Q2VydGlmaWNhdGUoY2VydGlmaWNhdGVJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jZXJ0aWZpY2F0ZXMvJHtjZXJ0aWZpY2F0ZUlkfWApO1xuICAgIH0sXG5cbiAgICAvLyBEb3dubG9hZCBjZXJ0aWZpY2F0ZVxuICAgIGFzeW5jIGRvd25sb2FkQ2VydGlmaWNhdGUoY2VydGlmaWNhdGVJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jZXJ0aWZpY2F0ZXMvJHtjZXJ0aWZpY2F0ZUlkfS9kb3dubG9hZGApO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgY2VydGlmaWNhdGUgaW1hZ2Ugd2l0aCBjdXN0b20gdGV4dCBvdmVybGF5c1xuICAgIGFzeW5jIGdldENlcnRpZmljYXRlSW1hZ2UoY2VydGlmaWNhdGVJZDogc3RyaW5nKTogUHJvbWlzZTxCbG9iPiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9jZXJ0aWZpY2F0ZXMvJHtjZXJ0aWZpY2F0ZUlkfS9pbWFnZWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtnZXRUb2tlbigpfWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBjZXJ0aWZpY2F0ZSBpbWFnZScsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgIH0sXG59O1xuXG4vLyBWaWRlbyBBUElcbmV4cG9ydCBjb25zdCB2aWRlb0FwaSA9IHtcbiAgICAvLyBHZXQgdmlkZW8gZGV0YWlscyBmcm9tIGFwaS52aWRlb1xuICAgIGFzeW5jIGdldFZpZGVvRGV0YWlscyh2aWRlb0lkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3ZpZGVvcy8ke3ZpZGVvSWR9YCk7XG4gICAgfSxcbn07XG5cbi8vIENhcnQgQVBJXG5leHBvcnQgY29uc3QgY2FydEFwaSA9IHtcbiAgICAvLyBHZXQgdXNlcidzIGNhcnRcbiAgICBhc3luYyBnZXRDYXJ0KCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvY2FydCcpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgY291cnNlIHRvIGNhcnRcbiAgICBhc3luYyBhZGRUb0NhcnQoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2FydC8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgY291cnNlIGZyb20gY2FydFxuICAgIGFzeW5jIHJlbW92ZUZyb21DYXJ0KGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NhcnQvJHtjb3Vyc2VJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiBjb3Vyc2UgaXMgaW4gY2FydFxuICAgIGFzeW5jIGNoZWNrSW5DYXJ0KGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NhcnQvY2hlY2svJHtjb3Vyc2VJZH1gKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgZW50aXJlIGNhcnRcbiAgICBhc3luYyBjbGVhckNhcnQoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9jYXJ0Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcblxuLy8gV2lzaGxpc3QgQVBJXG5leHBvcnQgY29uc3Qgd2lzaGxpc3RBcGkgPSB7XG4gICAgLy8gR2V0IHVzZXIncyB3aXNobGlzdFxuICAgIGFzeW5jIGdldFdpc2hsaXN0KCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvd2lzaGxpc3QnKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGNvdXJzZSB0byB3aXNobGlzdFxuICAgIGFzeW5jIGFkZFRvV2lzaGxpc3QoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvd2lzaGxpc3QvJHtjb3Vyc2VJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGNvdXJzZSBmcm9tIHdpc2hsaXN0XG4gICAgYXN5bmMgcmVtb3ZlRnJvbVdpc2hsaXN0KGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3dpc2hsaXN0LyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgY291cnNlIGlzIGluIHdpc2hsaXN0XG4gICAgYXN5bmMgY2hlY2tJbldpc2hsaXN0KGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3dpc2hsaXN0L2NoZWNrLyR7Y291cnNlSWR9YCk7XG4gICAgfSxcbn07XG5cbi8vIEV4cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG5leHBvcnQgeyBBcGlFcnJvciwgZ2V0VG9rZW4sIHNldFRva2VuLCByZW1vdmVUb2tlbiB9OyJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkFwaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJkYXRhIiwibmFtZSIsImdldFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldFRva2VuIiwidG9rZW4iLCJzZXRJdGVtIiwicmVtb3ZlVG9rZW4iLCJyZW1vdmVJdGVtIiwiYXBpUmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsImNvbmZpZyIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicmVzcG9uc2UiLCJmZXRjaCIsImpzb24iLCJlIiwib2siLCJlcnJvciIsImF1dGhBcGkiLCJsb2dpbiIsInBheWxvYWQiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlZ2lzdGVyIiwiZ2V0UHJvZmlsZSIsInVwZGF0ZVByb2ZpbGUiLCJwcm9maWxlRGF0YSIsInVwZGF0ZUluc3RydWN0b3JQcm9maWxlIiwiaW5zdHJ1Y3RvckRhdGEiLCJsb2dvdXQiLCJjaXRpZXNBcGkiLCJnZXRBbGwiLCJwYXJhbXMiLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidW5kZWZpbmVkIiwiYXBwZW5kIiwidG9TdHJpbmciLCJnZXRCeUlkIiwiaWQiLCJjcmVhdGUiLCJ1cGRhdGUiLCJkZWxldGUiLCJ0aGVhdGVyc0FwaSIsInRoZWF0ZXJEYXRhIiwidXBkYXRlRGF0YSIsInNob3dzQXBpIiwic2hvd0RhdGEiLCJzdHVkZW50QXBpIiwiZ2V0TXlFbnJvbGxtZW50cyIsImdldE15Q291cnNlcyIsImVucm9sbEluQ291cnNlIiwiY291cnNlSWQiLCJnZXRDb3Vyc2VQcm9ncmVzcyIsIm1hcmtMZXNzb25Db21wbGV0ZSIsInNlY3Rpb25JZCIsImxlY3R1cmVJZCIsInRpbWVTcGVudCIsInVubWFya0xlc3NvbkNvbXBsZXRlIiwiZ2V0RGFzaGJvYXJkT3ZlcnZpZXciLCJnZXRFbnJvbGxtZW50RGV0YWlscyIsImNlcnRpZmljYXRlQXBpIiwiZ2V0Q2VydGlmaWNhdGVzIiwiY29uc29sZSIsIndhcm4iLCJzdWNjZXNzIiwiY2VydGlmaWNhdGVzIiwic2VydmljZVVuYXZhaWxhYmxlIiwiaW5jbHVkZXMiLCJnZXRDZXJ0aWZpY2F0ZUJ5Q291cnNlIiwiY2VydGlmaWNhdGUiLCJnZW5lcmF0ZUNlcnRpZmljYXRlIiwiZ2V0Q2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZUlkIiwiZG93bmxvYWRDZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlSW1hZ2UiLCJibG9iIiwidmlkZW9BcGkiLCJnZXRWaWRlb0RldGFpbHMiLCJ2aWRlb0lkIiwiY2FydEFwaSIsImdldENhcnQiLCJhZGRUb0NhcnQiLCJyZW1vdmVGcm9tQ2FydCIsImNoZWNrSW5DYXJ0IiwiY2xlYXJDYXJ0Iiwid2lzaGxpc3RBcGkiLCJnZXRXaXNobGlzdCIsImFkZFRvV2lzaGxpc3QiLCJyZW1vdmVGcm9tV2lzaGxpc3QiLCJjaGVja0luV2lzaGxpc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});