"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   authApi: () => (/* binding */ authApi),\n/* harmony export */   cartApi: () => (/* binding */ cartApi),\n/* harmony export */   categoriesApi: () => (/* binding */ categoriesApi),\n/* harmony export */   certificateApi: () => (/* binding */ certificateApi),\n/* harmony export */   citiesApi: () => (/* binding */ citiesApi),\n/* harmony export */   coursesApi: () => (/* binding */ coursesApi),\n/* harmony export */   getToken: () => (/* binding */ getToken),\n/* harmony export */   removeToken: () => (/* binding */ removeToken),\n/* harmony export */   setToken: () => (/* binding */ setToken),\n/* harmony export */   studentApi: () => (/* binding */ studentApi),\n/* harmony export */   theatersApi: () => (/* binding */ theatersApi),\n/* harmony export */   videoApi: () => (/* binding */ videoApi),\n/* harmony export */   wishlistApi: () => (/* binding */ wishlistApi)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// API service layer for connecting frontend to backend\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';\nclass ApiError extends Error {\n    constructor(message, status, data = null){\n        super(message);\n        this.name = 'ApiError';\n        this.status = status;\n        this.data = data;\n    }\n}\n// Token management\nconst getToken = ()=>{\n    if (true) {\n        return localStorage.getItem('aiq-token');\n    }\n    return null;\n};\nconst setToken = (token)=>{\n    if (true) {\n        localStorage.setItem('aiq-token', token);\n    }\n};\nconst removeToken = ()=>{\n    if (true) {\n        localStorage.removeItem('aiq-token');\n    }\n};\n// Base API request function\nconst apiRequest = async function(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    const token = getToken();\n    const config = {\n        headers: {\n            'Content-Type': 'application/json',\n            ...options.headers\n        },\n        ...options\n    };\n    // Add authentication header if token exists\n    if (token) {\n        config.headers.Authorization = \"Bearer \".concat(token);\n    }\n    try {\n        const response = await fetch(url, config);\n        let data;\n        try {\n            data = await response.json();\n        } catch (e) {\n            data = null;\n        }\n        if (!response.ok) {\n            // Handle 401 Unauthorized specifically\n            if (response.status === 401) {\n                // Token might be expired, remove it\n                removeToken();\n                if (true) {\n                    localStorage.removeItem('aiq-user');\n                }\n            }\n            throw new ApiError((data === null || data === void 0 ? void 0 : data.message) || \"HTTP error! status: \".concat(response.status), response.status, data);\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        throw new ApiError('Network error occurred', 0);\n    }\n};\n// Auth API\nconst authApi = {\n    // Login\n    async login (payload) {\n        const data = await apiRequest('/auth/login', {\n            method: 'POST',\n            body: JSON.stringify(payload)\n        });\n        if (data.token) {\n            setToken(data.token);\n        }\n        return data;\n    },\n    // Register\n    async register (payload) {\n        const data = await apiRequest('/auth/register', {\n            method: 'POST',\n            body: JSON.stringify(payload)\n        });\n        if (data.token) {\n            setToken(data.token);\n        }\n        return data;\n    },\n    // Get current user profile\n    async getProfile () {\n        return await apiRequest('/auth/profile');\n    },\n    // Update profile\n    async updateProfile (profileData) {\n        return await apiRequest('/auth/profile', {\n            method: 'PUT',\n            body: JSON.stringify(profileData)\n        });\n    },\n    // Update instructor profile\n    async updateInstructorProfile (instructorData) {\n        return await apiRequest('/auth/instructor-profile', {\n            method: 'PUT',\n            body: JSON.stringify(instructorData)\n        });\n    },\n    // Logout\n    logout () {\n        removeToken();\n        if (true) {\n            localStorage.removeItem('aiq-user');\n        }\n    }\n};\n// City API\nconst citiesApi = {\n    //  Get all cities (public endpoint)\n    async getAll () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/cities?\".concat(queryParams));\n    },\n    //  Get single city by ID\n    async getById (id) {\n        return await apiRequest(\"/cities/\".concat(id));\n    },\n    //  Create new city (Admin only)\n    async create (data) {\n        const token = getToken();\n        return await apiRequest(\"/cities\", {\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n    },\n    // Update existing city\n    async update (id, data) {\n        const token = getToken();\n        return await apiRequest(\"/cities/\".concat(id), {\n            method: \"PUT\",\n            headers: {\n                Authorization: \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n    },\n    // Delete city\n    async delete (id) {\n        const token = getToken();\n        return await apiRequest(\"/cities/\".concat(id), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"Bearer \".concat(token)\n            }\n        });\n    }\n};\n// theater\nconst theatersApi = {\n    async getAll () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/theaters?\".concat(queryParams));\n    },\n    // âœ… Get a theater by ID\n    async getById (id) {\n        return await apiRequest(\"/theaters/\".concat(id));\n    },\n    // âœ… Create a new theater (admin only)\n    async create (theaterData) {\n        const token = getToken();\n        return await apiRequest(\"/theaters\", {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(theaterData)\n        });\n    },\n    // âœ… Update theater (admin only)\n    async update (id, updateData) {\n        const token = getToken();\n        return await apiRequest(\"/theaters/\".concat(id), {\n            method: \"PUT\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(token),\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(updateData)\n        });\n    },\n    // âœ… Delete theater (admin only)\n    async delete (id) {\n        const token = getToken();\n        return await apiRequest(\"/theaters/\".concat(id), {\n            method: \"DELETE\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(token)\n            }\n        });\n    }\n};\nconst coursesApi = {\n    // Get all published courses (for students to browse)\n    async getPublished () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams();\n        // Convert params to URLSearchParams\n        Object.keys(params).forEach((key)=>{\n            if (params[key] !== undefined && params[key] !== null) {\n                queryParams.append(key, params[key].toString());\n            }\n        });\n        return await apiRequest(\"/courses?\".concat(queryParams));\n    },\n    // Get instructor dashboard stats\n    async getDashboardStats () {\n        return await apiRequest('/courses/instructor/dashboard-stats');\n    },\n    // Get instructor's courses\n    async getMyCourses () {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const queryParams = new URLSearchParams(params);\n        return await apiRequest(\"/courses/instructor/my-courses?\".concat(queryParams));\n    },\n    // Create draft course\n    async createDraft (formData) {\n        return await apiRequest('/courses/draft', {\n            method: 'POST',\n            headers: {},\n            body: formData\n        });\n    },\n    // Update course basic info\n    async updateBasicInfo (courseId, formData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/basic-info\"), {\n            method: 'PUT',\n            headers: {},\n            body: formData\n        });\n    },\n    // Get course details\n    async getCourse (courseId) {\n        return await apiRequest(\"/courses/\".concat(courseId));\n    },\n    // Get course by ID (alias for getCourse)\n    async getById (courseId) {\n        return await this.getCourse(courseId);\n    },\n    // Update course\n    async update (courseId, formData) {\n        return await this.updateBasicInfo(courseId, formData);\n    },\n    // Add section to course\n    async addSection (courseId, sectionData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections\"), {\n            method: 'POST',\n            body: JSON.stringify(sectionData)\n        });\n    },\n    // Add lecture to section\n    async addLecture (courseId, sectionId, lectureData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections/\").concat(sectionId, \"/lectures\"), {\n            method: 'POST',\n            body: JSON.stringify(lectureData)\n        });\n    },\n    // Update lecture\n    async updateLecture (courseId, sectionId, lectureId, lectureData) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections/\").concat(sectionId, \"/lectures/\").concat(lectureId), {\n            method: 'PUT',\n            body: JSON.stringify(lectureData)\n        });\n    },\n    // Publish/unpublish course\n    async togglePublish (courseId) {\n        let publish = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        return await apiRequest(\"/courses/\".concat(courseId, \"/publish\"), {\n            method: 'PATCH',\n            body: JSON.stringify({\n                publish\n            })\n        });\n    },\n    // Delete course\n    async deleteCourse (courseId) {\n        return await apiRequest(\"/courses/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Delete lecture (immediately from MongoDB + api.video)\n    async deleteLecture (courseId, sectionId, lectureId) {\n        return await apiRequest(\"/courses/\".concat(courseId, \"/sections/\").concat(sectionId, \"/lectures/\").concat(lectureId), {\n            method: 'DELETE'\n        });\n    },\n    // Test SSE connection\n    testSSE () {\n        return new Promise((resolve)=>{\n            console.log('ðŸ§ª Testing SSE connection...');\n            const sseUrl = \"\".concat(API_BASE_URL, \"/courses/test-sse\");\n            const eventSource = new EventSource(sseUrl);\n            let messageCount = 0;\n            eventSource.onopen = ()=>{\n                console.log('âœ… SSE test connection opened successfully');\n            };\n            eventSource.onmessage = (event)=>{\n                console.log('ðŸ“© SSE test message received:', event.data);\n                messageCount++;\n                try {\n                    const data = JSON.parse(event.data);\n                    if (data.complete) {\n                        console.log('âœ… SSE test completed successfully, received', messageCount, 'messages');\n                        eventSource.close();\n                        resolve(true);\n                    }\n                } catch (error) {\n                    console.error('âŒ SSE test message parse error:', error);\n                }\n            };\n            eventSource.onerror = (error)=>{\n                console.error('âŒ SSE test connection error:', error);\n                eventSource.close();\n                resolve(false);\n            };\n            // Timeout after 10 seconds\n            setTimeout(()=>{\n                console.warn('â±ï¸ SSE test timeout');\n                eventSource.close();\n                resolve(false);\n            }, 10000);\n        });\n    },\n    // Test CORS connectivity to backend\n    async testCORS () {\n        try {\n            console.log('ðŸ§ª Testing CORS connectivity to:', \"\".concat(API_BASE_URL, \"/courses/cors-test\"));\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/courses/cors-test\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            const data = await response.json();\n            console.log('âœ… CORS Test Response:', data);\n            return data;\n        } catch (error) {\n            console.error('âŒ CORS Test Failed:', error);\n            throw error;\n        }\n    },\n    // Simple video upload to api.video with progress tracking\n    async uploadVideo (courseId, sectionIndex, lectureIndex, videoFile, thumbnailFile, onProgress) {\n        const formData = new FormData();\n        formData.append('video', videoFile);\n        formData.append('courseId', courseId);\n        formData.append('sectionIndex', sectionIndex.toString());\n        formData.append('lectureIndex', lectureIndex.toString());\n        if (thumbnailFile) {\n            formData.append('thumbnail', thumbnailFile);\n        }\n        const token = getToken();\n        // Hybrid progress tracking: Try SSE first, fall back to polling\n        // Simple milestone-based progress tracking\n        const progressKey = \"\".concat(courseId, \"-\").concat(sectionIndex, \"-\").concat(lectureIndex);\n        let progressMilestones = [\n            20,\n            40,\n            60,\n            80,\n            90,\n            100\n        ];\n        let currentMilestoneIndex = 0;\n        // Start progress tracking by periodically checking backend\n        let progressCheckInterval = null;\n        let progressCompleted = false;\n        if (onProgress) {\n            console.log('ðŸ“¹ Starting milestone-based progress tracking...');\n            onProgress(0); // Start at 0%\n            progressCheckInterval = setInterval(async ()=>{\n                if (progressCompleted) {\n                    clearInterval(progressCheckInterval);\n                    return;\n                }\n                try {\n                    const response = await fetch(\"\".concat(API_BASE_URL, \"/courses/progress-milestone/\").concat(progressKey), {\n                        headers: {\n                            'Authorization': \"Bearer \".concat(token)\n                        }\n                    });\n                    if (response.ok) {\n                        const data = await response.json();\n                        if (data.milestone && data.milestone > (progressMilestones[currentMilestoneIndex - 1] || 0)) {\n                            console.log('ðŸ“¹ Progress milestone reached:', data.milestone + '%');\n                            onProgress(data.milestone);\n                            if (data.milestone >= 100) {\n                                progressCompleted = true;\n                                clearInterval(progressCheckInterval);\n                            }\n                        }\n                    }\n                } catch (error) {\n                    console.warn('ðŸ“¹ Progress milestone check failed:', error);\n                }\n            }, 1000); // Check every second for milestone updates\n        }\n        try {\n            console.log('ðŸ“¹ Starting video upload...');\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/courses/upload-video\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token)\n                },\n                body: formData\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                throw new ApiError(data.message || 'Upload failed', response.status, data);\n            }\n            // Clean up progress tracking and ensure 100%\n            progressCompleted = true;\n            if (progressCheckInterval) {\n                clearInterval(progressCheckInterval);\n            }\n            if (onProgress) {\n                console.log('ðŸ“¹ Upload completed - setting progress to 100%');\n                onProgress(100);\n            }\n            return data;\n        } catch (error) {\n            // Clean up progress tracking on error\n            progressCompleted = true;\n            if (progressCheckInterval) {\n                clearInterval(progressCheckInterval);\n            }\n            if (error instanceof ApiError) {\n                throw error;\n            }\n            throw new ApiError('Network error during upload', 0, null);\n        }\n    },\n    // Upload video for lecture (legacy - complex route)\n    async uploadLectureVideo (courseId, sectionId, lectureId, videoFile, thumbnailFile) {\n        const formData = new FormData();\n        formData.append('video', videoFile);\n        if (thumbnailFile) {\n            formData.append('thumbnail', thumbnailFile);\n        }\n        const token = getToken();\n        return await fetch(\"\".concat(API_BASE_URL, \"/courses/\").concat(courseId, \"/sections/\").concat(sectionId, \"/lectures/\").concat(lectureId, \"/upload-video\"), {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(token)\n            },\n            body: formData\n        }).then(async (response)=>{\n            const data = await response.json();\n            if (!response.ok) {\n                throw new ApiError(data.message || 'Upload failed', response.status, data);\n            }\n            return data;\n        });\n    }\n};\n// Categories API\nconst categoriesApi = {\n    async getAll () {\n        return await apiRequest('/categories');\n    }\n};\n// Student/Learner API\nconst studentApi = {\n    // Get student's enrollments\n    async getMyEnrollments () {\n        return await apiRequest('/enrollments/my-enrollments');\n    },\n    // Get student's enrolled courses with progress\n    async getMyCourses () {\n        return await apiRequest('/enrollments/my-courses');\n    },\n    // Enroll in a course\n    async enrollInCourse (courseId) {\n        return await apiRequest(\"/enrollments/enroll/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Get course progress\n    async getCourseProgress (courseId) {\n        return await apiRequest(\"/progress/course/\".concat(courseId));\n    },\n    // Mark lesson as complete\n    async markLessonComplete (courseId, sectionId, lectureId, timeSpent) {\n        return await apiRequest('/progress/lesson-complete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                courseId,\n                sectionId,\n                lectureId,\n                timeSpent: timeSpent || 0\n            })\n        });\n    },\n    // Unmark lesson as complete\n    async unmarkLessonComplete (courseId, sectionId, lectureId, timeSpent) {\n        return await apiRequest('/progress/lesson-uncomplete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                courseId,\n                sectionId,\n                lectureId,\n                timeSpent: timeSpent || 0\n            })\n        });\n    },\n    // Get student dashboard overview\n    async getDashboardOverview () {\n        return await apiRequest('/progress/overview');\n    },\n    // Get specific enrollment details\n    async getEnrollmentDetails (courseId) {\n        return await apiRequest(\"/enrollments/my-enrollment/\".concat(courseId));\n    }\n};\n// Certificate API\nconst certificateApi = {\n    // Get user's certificates\n    async getCertificates () {\n        try {\n            return await apiRequest('/certificates');\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate list error:', error.status, error.message);\n            // For any certificate API error, just return empty list\n            // This prevents dashboard loading issues\n            return {\n                success: true,\n                certificates: [],\n                serviceUnavailable: error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))\n            };\n        }\n    },\n    // Get certificate by course ID\n    async getCertificateByCourse (courseId) {\n        try {\n            return await apiRequest(\"/certificates/course/\".concat(courseId));\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate API error:', error.status, error.message);\n            if (error.status === 404) {\n                return {\n                    success: false,\n                    message: 'Certificate not found',\n                    certificate: null\n                };\n            } else if (error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))) {\n                return {\n                    success: false,\n                    message: 'Certificate access denied',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 0 || error.status === 500) {\n                return {\n                    success: false,\n                    message: 'Certificate service unavailable',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            }\n            // For any other error, return a generic unavailable response\n            return {\n                success: false,\n                message: 'Certificate temporarily unavailable',\n                certificate: null,\n                serviceUnavailable: true\n            };\n        }\n    },\n    // Generate certificate for completed course\n    async generateCertificate (courseId) {\n        try {\n            return await apiRequest(\"/certificates/generate/\".concat(courseId), {\n                method: 'POST'\n            });\n        } catch (error) {\n            var _error_message, _error_message1;\n            // Handle various certificate API unavailability scenarios\n            console.warn('Certificate generation error:', error.status, error.message);\n            if (error.status === 404) {\n                return {\n                    success: false,\n                    message: 'Certificate generation not available',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 403 || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('Insufficient permissions')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Forbidden'))) {\n                return {\n                    success: false,\n                    message: 'Certificate generation access denied',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            } else if (error.status === 0 || error.status === 500) {\n                return {\n                    success: false,\n                    message: 'Certificate service unavailable',\n                    certificate: null,\n                    serviceUnavailable: true\n                };\n            }\n            // For any other error, return a generic unavailable response\n            return {\n                success: false,\n                message: 'Certificate generation temporarily unavailable',\n                certificate: null,\n                serviceUnavailable: true\n            };\n        }\n    },\n    // Get certificate by ID\n    async getCertificate (certificateId) {\n        return await apiRequest(\"/certificates/\".concat(certificateId));\n    },\n    // Download certificate\n    async downloadCertificate (certificateId) {\n        return await apiRequest(\"/certificates/\".concat(certificateId, \"/download\"));\n    },\n    // Get certificate image with custom text overlays\n    async getCertificateImage (certificateId) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/certificates/\").concat(certificateId, \"/image\"), {\n            headers: {\n                'Authorization': \"Bearer \".concat(getToken())\n            }\n        });\n        if (!response.ok) {\n            throw new ApiError('Failed to fetch certificate image', response.status);\n        }\n        return await response.blob();\n    }\n};\n// Video API\nconst videoApi = {\n    // Get video details from api.video\n    async getVideoDetails (videoId) {\n        return await apiRequest(\"/videos/\".concat(videoId));\n    }\n};\n// Cart API\nconst cartApi = {\n    // Get user's cart\n    async getCart () {\n        return await apiRequest('/cart');\n    },\n    // Add course to cart\n    async addToCart (courseId) {\n        return await apiRequest(\"/cart/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Remove course from cart\n    async removeFromCart (courseId) {\n        return await apiRequest(\"/cart/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Check if course is in cart\n    async checkInCart (courseId) {\n        return await apiRequest(\"/cart/check/\".concat(courseId));\n    },\n    // Clear entire cart\n    async clearCart () {\n        return await apiRequest('/cart', {\n            method: 'DELETE'\n        });\n    }\n};\n// Wishlist API\nconst wishlistApi = {\n    // Get user's wishlist\n    async getWishlist () {\n        return await apiRequest('/wishlist');\n    },\n    // Add course to wishlist\n    async addToWishlist (courseId) {\n        return await apiRequest(\"/wishlist/\".concat(courseId), {\n            method: 'POST'\n        });\n    },\n    // Remove course from wishlist\n    async removeFromWishlist (courseId) {\n        return await apiRequest(\"/wishlist/\".concat(courseId), {\n            method: 'DELETE'\n        });\n    },\n    // Check if course is in wishlist\n    async checkInWishlist (courseId) {\n        return await apiRequest(\"/wishlist/check/\".concat(courseId));\n    }\n};\n// Export helper functions\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WjtJQUNKO0lBRUEsNkJBQTZCO0lBQzdCLE1BQU1zSCxhQUFZaEYsUUFBZ0I7UUFDOUIsT0FBTyxNQUFNdEQsV0FBd0IsZUFBd0IsT0FBVHNEO0lBQ3hEO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1pRjtRQUNGLE9BQU8sTUFBTXZJLFdBQXdCLFNBQVM7WUFDMUNnQixRQUFRO1FBQ1o7SUFDSjtBQUNKLEVBQUU7QUFFRixlQUFlO0FBQ1IsTUFBTXdILGNBQWM7SUFDdkIsc0JBQXNCO0lBQ3RCLE1BQU1DO1FBQ0YsT0FBTyxNQUFNekksV0FBd0I7SUFDekM7SUFFQSx5QkFBeUI7SUFDekIsTUFBTTBJLGVBQWNwRixRQUFnQjtRQUNoQyxPQUFPLE1BQU10RCxXQUF3QixhQUFzQixPQUFUc0QsV0FBWTtZQUMxRHRDLFFBQVE7UUFDWjtJQUNKO0lBRUEsOEJBQThCO0lBQzlCLE1BQU0ySCxvQkFBbUJyRixRQUFnQjtRQUNyQyxPQUFPLE1BQU10RCxXQUF3QixhQUFzQixPQUFUc0QsV0FBWTtZQUMxRHRDLFFBQVE7UUFDWjtJQUNKO0lBRUEsaUNBQWlDO0lBQ2pDLE1BQU00SCxpQkFBZ0J0RixRQUFnQjtRQUNsQyxPQUFPLE1BQU10RCxXQUF3QixtQkFBNEIsT0FBVHNEO0lBQzVEO0FBQ0osRUFBRTtBQUVGLDBCQUEwQjtBQUMyQiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RcXENvbmNlcnQgVGlja2V0aW5nXFxUaWNrZXRpbmdVaVxcc3JjXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgc2VydmljZSBsYXllciBmb3IgY29ubmVjdGluZyBmcm9udGVuZCB0byBiYWNrZW5kXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpJztcblxuaW50ZXJmYWNlIEFwaVJlc3BvbnNlPFQgPSBhbnk+IHtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIHRva2VuPzogc3RyaW5nO1xuICAgIHVzZXI/OiBhbnk7XG4gICAgZGF0YT86IFQ7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5jbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICBkYXRhOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBkYXRhOiBhbnkgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG5cbi8vIFRva2VuIG1hbmFnZW1lbnRcbmNvbnN0IGdldFRva2VuID0gKCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FpcS10b2tlbicpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHNldFRva2VuID0gKHRva2VuOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FpcS10b2tlbicsIHRva2VuKTtcbiAgICB9XG59O1xuXG5jb25zdCByZW1vdmVUb2tlbiA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FpcS10b2tlbicpO1xuICAgIH1cbn07XG5cbi8vIEJhc2UgQVBJIHJlcXVlc3QgZnVuY3Rpb25cbmNvbnN0IGFwaVJlcXVlc3QgPSBhc3luYyA8VCA9IGFueT4oZW5kcG9pbnQ6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgJiB7IGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0gPSB7fSk6IFByb21pc2U8VD4gPT4ge1xuICAgIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFX1VSTH0ke2VuZHBvaW50fWA7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgY29uc3QgY29uZmlnOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gQWRkIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBpZiB0b2tlbiBleGlzdHNcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgKGNvbmZpZy5oZWFkZXJzIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgY29uZmlnKTtcblxuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIDQwMSBVbmF1dGhvcml6ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBtaWdodCBiZSBleHBpcmVkLCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICByZW1vdmVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWlxLXVzZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihcbiAgICAgICAgICAgICAgICBkYXRhPy5tZXNzYWdlIHx8IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKCdOZXR3b3JrIGVycm9yIG9jY3VycmVkJywgMCk7XG4gICAgfVxufTtcblxuLy8gQXV0aCBBUElcbmV4cG9ydCBjb25zdCBhdXRoQXBpID0ge1xuICAgIC8vIExvZ2luXG4gICAgYXN5bmMgbG9naW4ocGF5bG9hZCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkYXRhLnRva2VuKSB7XG4gICAgICAgICAgICBzZXRUb2tlbihkYXRhLnRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvLyBSZWdpc3RlclxuICAgIGFzeW5jIHJlZ2lzdGVyKHBheWxvYWQpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2F1dGgvcmVnaXN0ZXInLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGF0YS50b2tlbikge1xuICAgICAgICAgICAgc2V0VG9rZW4oZGF0YS50b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGN1cnJlbnQgdXNlciBwcm9maWxlXG4gICAgYXN5bmMgZ2V0UHJvZmlsZSgpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2F1dGgvcHJvZmlsZScpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgcHJvZmlsZVxuICAgIGFzeW5jIHVwZGF0ZVByb2ZpbGUocHJvZmlsZURhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2F1dGgvcHJvZmlsZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcm9maWxlRGF0YSksXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgaW5zdHJ1Y3RvciBwcm9maWxlXG4gICAgYXN5bmMgdXBkYXRlSW5zdHJ1Y3RvclByb2ZpbGUoaW5zdHJ1Y3RvckRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2F1dGgvaW5zdHJ1Y3Rvci1wcm9maWxlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGluc3RydWN0b3JEYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIExvZ291dFxuICAgIGxvZ291dCgpOiB2b2lkIHtcbiAgICAgICAgcmVtb3ZlVG9rZW4oKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWlxLXVzZXInKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG4vLyBDaXR5IEFQSVxuZXhwb3J0IGNvbnN0IGNpdGllc0FwaSA9IHtcbiAgICAvLyAgR2V0IGFsbCBjaXRpZXMgKHB1YmxpYyBlbmRwb2ludClcbiAgICBhc3luYyBnZXRBbGwocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW1zW2tleV0gIT09IHVuZGVmaW5lZCAmJiBwYXJhbXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHBhcmFtc1trZXldLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jaXRpZXM/JHtxdWVyeVBhcmFtc31gKTtcbiAgICB9LFxuXG4gICAgLy8gIEdldCBzaW5nbGUgY2l0eSBieSBJRFxuICAgIGFzeW5jIGdldEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2l0aWVzLyR7aWR9YCk7XG4gICAgfSxcblxuICAgIC8vICBDcmVhdGUgbmV3IGNpdHkgKEFkbWluIG9ubHkpXG4gICAgYXN5bmMgY3JlYXRlKGRhdGE6IHsgbmFtZTogc3RyaW5nOyBzdGF0ZTogc3RyaW5nOyBjb3VudHJ5Pzogc3RyaW5nIH0pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KFwiL2NpdGllc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNpdHlcbiAgICBhc3luYyB1cGRhdGUoXG4gICAgICAgIGlkOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IHsgbmFtZT86IHN0cmluZzsgc3RhdGU/OiBzdHJpbmc7IGNvdW50cnk/OiBzdHJpbmc7IGlzQWN0aXZlPzogYm9vbGVhbiB9XG4gICAgKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2l0aWVzLyR7aWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVsZXRlIGNpdHlcbiAgICBhc3luYyBkZWxldGUoaWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NpdGllcy8ke2lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuXG5cblxuLy8gdGhlYXRlclxuZXhwb3J0IGNvbnN0IHRoZWF0ZXJzQXBpID0ge1xuICBhc3luYyBnZXRBbGwocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKHBhcmFtc1trZXldICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1zW2tleV0udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC90aGVhdGVycz8ke3F1ZXJ5UGFyYW1zfWApO1xuICB9LFxuXG4gIC8vIOKchSBHZXQgYSB0aGVhdGVyIGJ5IElEXG4gIGFzeW5jIGdldEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC90aGVhdGVycy8ke2lkfWApO1xuICB9LFxuXG4gIC8vIOKchSBDcmVhdGUgYSBuZXcgdGhlYXRlciAoYWRtaW4gb25seSlcbiAgYXN5bmMgY3JlYXRlKHRoZWF0ZXJEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihcIi90aGVhdGVyc1wiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoZWF0ZXJEYXRhKSxcbiAgICB9KTtcbiAgfSxcblxuICAvLyDinIUgVXBkYXRlIHRoZWF0ZXIgKGFkbWluIG9ubHkpXG4gIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nLCB1cGRhdGVEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3RoZWF0ZXJzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZURhdGEpLFxuICAgIH0pO1xuICB9LFxuXG4gIC8vIOKchSBEZWxldGUgdGhlYXRlciAoYWRtaW4gb25seSlcbiAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuXG4gICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvdGhlYXRlcnMvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG59O1xuXG5cblxuXG5cblxuZXhwb3J0IGNvbnN0IGNvdXJzZXNBcGkgPSB7XG4gICAgLy8gR2V0IGFsbCBwdWJsaXNoZWQgY291cnNlcyAoZm9yIHN0dWRlbnRzIHRvIGJyb3dzZSlcbiAgICBhc3luYyBnZXRQdWJsaXNoZWQocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgcGFyYW1zIHRvIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1zW2tleV0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXM/JHtxdWVyeVBhcmFtc31gKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGluc3RydWN0b3IgZGFzaGJvYXJkIHN0YXRzXG4gICAgYXN5bmMgZ2V0RGFzaGJvYXJkU3RhdHMoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9jb3Vyc2VzL2luc3RydWN0b3IvZGFzaGJvYXJkLXN0YXRzJyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBpbnN0cnVjdG9yJ3MgY291cnNlc1xuICAgIGFzeW5jIGdldE15Q291cnNlcyhwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXMvaW5zdHJ1Y3Rvci9teS1jb3Vyc2VzPyR7cXVlcnlQYXJhbXN9YCk7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBkcmFmdCBjb3Vyc2VcbiAgICBhc3luYyBjcmVhdGVEcmFmdChmb3JtRGF0YTogRm9ybURhdGEpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2NvdXJzZXMvZHJhZnQnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsIC8vIEZvcm1EYXRhIGZvciBmaWxlIHVwbG9hZHNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBjb3Vyc2UgYmFzaWMgaW5mb1xuICAgIGFzeW5jIHVwZGF0ZUJhc2ljSW5mbyhjb3Vyc2VJZDogc3RyaW5nLCBmb3JtRGF0YTogRm9ybURhdGEpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXMvJHtjb3Vyc2VJZH0vYmFzaWMtaW5mb2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLCAvLyBGb3JtRGF0YSBmb3IgZmlsZSB1cGxvYWRzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgY291cnNlIGRldGFpbHNcbiAgICBhc3luYyBnZXRDb3Vyc2UoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy8ke2NvdXJzZUlkfWApO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgY291cnNlIGJ5IElEIChhbGlhcyBmb3IgZ2V0Q291cnNlKVxuICAgIGFzeW5jIGdldEJ5SWQoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q291cnNlKGNvdXJzZUlkKTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGNvdXJzZVxuICAgIGFzeW5jIHVwZGF0ZShjb3Vyc2VJZDogc3RyaW5nLCBmb3JtRGF0YTogRm9ybURhdGEpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwZGF0ZUJhc2ljSW5mbyhjb3Vyc2VJZCwgZm9ybURhdGEpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgc2VjdGlvbiB0byBjb3Vyc2VcbiAgICBhc3luYyBhZGRTZWN0aW9uKGNvdXJzZUlkOiBzdHJpbmcsIHNlY3Rpb25EYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jb3Vyc2VzLyR7Y291cnNlSWR9L3NlY3Rpb25zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzZWN0aW9uRGF0YSksXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgbGVjdHVyZSB0byBzZWN0aW9uXG4gICAgYXN5bmMgYWRkTGVjdHVyZShjb3Vyc2VJZDogc3RyaW5nLCBzZWN0aW9uSWQ6IHN0cmluZywgbGVjdHVyZURhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXMvJHtjb3Vyc2VJZH0vc2VjdGlvbnMvJHtzZWN0aW9uSWR9L2xlY3R1cmVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShsZWN0dXJlRGF0YSksXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgbGVjdHVyZVxuICAgIGFzeW5jIHVwZGF0ZUxlY3R1cmUoY291cnNlSWQ6IHN0cmluZywgc2VjdGlvbklkOiBzdHJpbmcsIGxlY3R1cmVJZDogc3RyaW5nLCBsZWN0dXJlRGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy8ke2NvdXJzZUlkfS9zZWN0aW9ucy8ke3NlY3Rpb25JZH0vbGVjdHVyZXMvJHtsZWN0dXJlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGxlY3R1cmVEYXRhKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFB1Ymxpc2gvdW5wdWJsaXNoIGNvdXJzZVxuICAgIGFzeW5jIHRvZ2dsZVB1Ymxpc2goY291cnNlSWQ6IHN0cmluZywgcHVibGlzaDogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NvdXJzZXMvJHtjb3Vyc2VJZH0vcHVibGlzaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHVibGlzaCB9KSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERlbGV0ZSBjb3Vyc2VcbiAgICBhc3luYyBkZWxldGVDb3Vyc2UoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY291cnNlcy8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEZWxldGUgbGVjdHVyZSAoaW1tZWRpYXRlbHkgZnJvbSBNb25nb0RCICsgYXBpLnZpZGVvKVxuICAgIGFzeW5jIGRlbGV0ZUxlY3R1cmUoY291cnNlSWQ6IHN0cmluZywgc2VjdGlvbklkOiBzdHJpbmcsIGxlY3R1cmVJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jb3Vyc2VzLyR7Y291cnNlSWR9L3NlY3Rpb25zLyR7c2VjdGlvbklkfS9sZWN0dXJlcy8ke2xlY3R1cmVJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVGVzdCBTU0UgY29ubmVjdGlvblxuICAgIHRlc3RTU0UoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfp6ogVGVzdGluZyBTU0UgY29ubmVjdGlvbi4uLicpO1xuICAgICAgICAgICAgY29uc3Qgc3NlVXJsID0gYCR7QVBJX0JBU0VfVVJMfS9jb3Vyc2VzL3Rlc3Qtc3NlYDtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gbmV3IEV2ZW50U291cmNlKHNzZVVybCk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgZXZlbnRTb3VyY2Uub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU1NFIHRlc3QgY29ubmVjdGlvbiBvcGVuZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBldmVudFNvdXJjZS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TqSBTU0UgdGVzdCBtZXNzYWdlIHJlY2VpdmVkOicsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFNTRSB0ZXN0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHJlY2VpdmVkJywgbWVzc2FnZUNvdW50LCAnbWVzc2FnZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFNTRSB0ZXN0IG1lc3NhZ2UgcGFyc2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU1NFIHRlc3QgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRpbWVvdXQgYWZ0ZXIgMTAgc2Vjb25kc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfij7HvuI8gU1NFIHRlc3QgdGltZW91dCcpO1xuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LCAxMDAwMCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0IENPUlMgY29ubmVjdGl2aXR5IHRvIGJhY2tlbmRcbiAgICBhc3luYyB0ZXN0Q09SUygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+nqiBUZXN0aW5nIENPUlMgY29ubmVjdGl2aXR5IHRvOicsIGAke0FQSV9CQVNFX1VSTH0vY291cnNlcy9jb3JzLXRlc3RgKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9jb3Vyc2VzL2NvcnMtdGVzdGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENPUlMgVGVzdCBSZXNwb25zZTonLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIENPUlMgVGVzdCBGYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHZpZGVvIHVwbG9hZCB0byBhcGkudmlkZW8gd2l0aCBwcm9ncmVzcyB0cmFja2luZ1xuICAgIGFzeW5jIHVwbG9hZFZpZGVvKFxuICAgICAgICBjb3Vyc2VJZDogc3RyaW5nLFxuICAgICAgICBzZWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgbGVjdHVyZUluZGV4OiBudW1iZXIsXG4gICAgICAgIHZpZGVvRmlsZTogRmlsZSxcbiAgICAgICAgdGh1bWJuYWlsRmlsZT86IEZpbGUsXG4gICAgICAgIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlcikgPT4gdm9pZFxuICAgICk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCd2aWRlbycsIHZpZGVvRmlsZSk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnY291cnNlSWQnLCBjb3Vyc2VJZCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnc2VjdGlvbkluZGV4Jywgc2VjdGlvbkluZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2xlY3R1cmVJbmRleCcsIGxlY3R1cmVJbmRleC50b1N0cmluZygpKTtcblxuICAgICAgICBpZiAodGh1bWJuYWlsRmlsZSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCd0aHVtYm5haWwnLCB0aHVtYm5haWxGaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcblxuICAgICAgICAvLyBIeWJyaWQgcHJvZ3Jlc3MgdHJhY2tpbmc6IFRyeSBTU0UgZmlyc3QsIGZhbGwgYmFjayB0byBwb2xsaW5nXG4gICAgICAgIC8vIFNpbXBsZSBtaWxlc3RvbmUtYmFzZWQgcHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NLZXkgPSBgJHtjb3Vyc2VJZH0tJHtzZWN0aW9uSW5kZXh9LSR7bGVjdHVyZUluZGV4fWA7XG4gICAgICAgIGxldCBwcm9ncmVzc01pbGVzdG9uZXMgPSBbMjAsIDQwLCA2MCwgODAsIDkwLCAxMDBdO1xuICAgICAgICBsZXQgY3VycmVudE1pbGVzdG9uZUluZGV4ID0gMDtcblxuICAgICAgICAvLyBTdGFydCBwcm9ncmVzcyB0cmFja2luZyBieSBwZXJpb2RpY2FsbHkgY2hlY2tpbmcgYmFja2VuZFxuICAgICAgICBsZXQgcHJvZ3Jlc3NDaGVja0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcHJvZ3Jlc3NDb21wbGV0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk7kgU3RhcnRpbmcgbWlsZXN0b25lLWJhc2VkIHByb2dyZXNzIHRyYWNraW5nLi4uJyk7XG4gICAgICAgICAgICBvblByb2dyZXNzKDApOyAvLyBTdGFydCBhdCAwJVxuXG4gICAgICAgICAgICBwcm9ncmVzc0NoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NDaGVja0ludGVydmFsISk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vY291cnNlcy9wcm9ncmVzcy1taWxlc3RvbmUvJHtwcm9ncmVzc0tleX1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5taWxlc3RvbmUgJiYgZGF0YS5taWxlc3RvbmUgPiAocHJvZ3Jlc3NNaWxlc3RvbmVzW2N1cnJlbnRNaWxlc3RvbmVJbmRleCAtIDFdIHx8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk7kgUHJvZ3Jlc3MgbWlsZXN0b25lIHJlYWNoZWQ6JywgZGF0YS5taWxlc3RvbmUgKyAnJScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoZGF0YS5taWxlc3RvbmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubWlsZXN0b25lID49IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NDaGVja0ludGVydmFsISk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfwn5O5IFByb2dyZXNzIG1pbGVzdG9uZSBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApOyAvLyBDaGVjayBldmVyeSBzZWNvbmQgZm9yIG1pbGVzdG9uZSB1cGRhdGVzXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk7kgU3RhcnRpbmcgdmlkZW8gdXBsb2FkLi4uJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vY291cnNlcy91cGxvYWQtdmlkZW9gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ1VwbG9hZCBmYWlsZWQnLCByZXNwb25zZS5zdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBwcm9ncmVzcyB0cmFja2luZyBhbmQgZW5zdXJlIDEwMCVcbiAgICAgICAgICAgIHByb2dyZXNzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0NoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHByb2dyZXNzQ2hlY2tJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5O5IFVwbG9hZCBjb21wbGV0ZWQgLSBzZXR0aW5nIHByb2dyZXNzIHRvIDEwMCUnKTtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKDEwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcHJvZ3Jlc3MgdHJhY2tpbmcgb24gZXJyb3JcbiAgICAgICAgICAgIHByb2dyZXNzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0NoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHByb2dyZXNzQ2hlY2tJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwaUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcignTmV0d29yayBlcnJvciBkdXJpbmcgdXBsb2FkJywgMCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVXBsb2FkIHZpZGVvIGZvciBsZWN0dXJlIChsZWdhY3kgLSBjb21wbGV4IHJvdXRlKVxuICAgIGFzeW5jIHVwbG9hZExlY3R1cmVWaWRlbyhcbiAgICAgICAgY291cnNlSWQ6IHN0cmluZyxcbiAgICAgICAgc2VjdGlvbklkOiBzdHJpbmcsXG4gICAgICAgIGxlY3R1cmVJZDogc3RyaW5nLFxuICAgICAgICB2aWRlb0ZpbGU6IEZpbGUsXG4gICAgICAgIHRodW1ibmFpbEZpbGU/OiBGaWxlXG4gICAgKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3ZpZGVvJywgdmlkZW9GaWxlKTtcblxuICAgICAgICBpZiAodGh1bWJuYWlsRmlsZSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCd0aHVtYm5haWwnLCB0aHVtYm5haWxGaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vY291cnNlcy8ke2NvdXJzZUlkfS9zZWN0aW9ucy8ke3NlY3Rpb25JZH0vbGVjdHVyZXMvJHtsZWN0dXJlSWR9L3VwbG9hZC12aWRlb2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIH0pLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ1VwbG9hZCBmYWlsZWQnLCByZXNwb25zZS5zdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuXG4vLyBDYXRlZ29yaWVzIEFQSVxuZXhwb3J0IGNvbnN0IGNhdGVnb3JpZXNBcGkgPSB7XG4gICAgYXN5bmMgZ2V0QWxsKCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvY2F0ZWdvcmllcycpO1xuICAgIH0sXG59O1xuXG4vLyBTdHVkZW50L0xlYXJuZXIgQVBJXG5leHBvcnQgY29uc3Qgc3R1ZGVudEFwaSA9IHtcbiAgICAvLyBHZXQgc3R1ZGVudCdzIGVucm9sbG1lbnRzXG4gICAgYXN5bmMgZ2V0TXlFbnJvbGxtZW50cygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2Vucm9sbG1lbnRzL215LWVucm9sbG1lbnRzJyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBzdHVkZW50J3MgZW5yb2xsZWQgY291cnNlcyB3aXRoIHByb2dyZXNzXG4gICAgYXN5bmMgZ2V0TXlDb3Vyc2VzKCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvZW5yb2xsbWVudHMvbXktY291cnNlcycpO1xuICAgIH0sXG5cbiAgICAvLyBFbnJvbGwgaW4gYSBjb3Vyc2VcbiAgICBhc3luYyBlbnJvbGxJbkNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9lbnJvbGxtZW50cy9lbnJvbGwvJHtjb3Vyc2VJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGNvdXJzZSBwcm9ncmVzc1xuICAgIGFzeW5jIGdldENvdXJzZVByb2dyZXNzKGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL3Byb2dyZXNzL2NvdXJzZS8ke2NvdXJzZUlkfWApO1xuICAgIH0sXG5cbiAgICAvLyBNYXJrIGxlc3NvbiBhcyBjb21wbGV0ZVxuICAgIGFzeW5jIG1hcmtMZXNzb25Db21wbGV0ZShjb3Vyc2VJZDogc3RyaW5nLCBzZWN0aW9uSWQ6IHN0cmluZywgbGVjdHVyZUlkOiBzdHJpbmcsIHRpbWVTcGVudD86IG51bWJlcik6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvcHJvZ3Jlc3MvbGVzc29uLWNvbXBsZXRlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgY291cnNlSWQsXG4gICAgICAgICAgICAgICAgc2VjdGlvbklkLFxuICAgICAgICAgICAgICAgIGxlY3R1cmVJZCxcbiAgICAgICAgICAgICAgICB0aW1lU3BlbnQ6IHRpbWVTcGVudCB8fCAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVW5tYXJrIGxlc3NvbiBhcyBjb21wbGV0ZVxuICAgIGFzeW5jIHVubWFya0xlc3NvbkNvbXBsZXRlKGNvdXJzZUlkOiBzdHJpbmcsIHNlY3Rpb25JZDogc3RyaW5nLCBsZWN0dXJlSWQ6IHN0cmluZywgdGltZVNwZW50PzogbnVtYmVyKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9wcm9ncmVzcy9sZXNzb24tdW5jb21wbGV0ZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGNvdXJzZUlkLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBsZWN0dXJlSWQsXG4gICAgICAgICAgICAgICAgdGltZVNwZW50OiB0aW1lU3BlbnQgfHwgMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCBzdHVkZW50IGRhc2hib2FyZCBvdmVydmlld1xuICAgIGFzeW5jIGdldERhc2hib2FyZE92ZXJ2aWV3KCk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvcHJvZ3Jlc3Mvb3ZlcnZpZXcnKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHNwZWNpZmljIGVucm9sbG1lbnQgZGV0YWlsc1xuICAgIGFzeW5jIGdldEVucm9sbG1lbnREZXRhaWxzKGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2Vucm9sbG1lbnRzL215LWVucm9sbG1lbnQvJHtjb3Vyc2VJZH1gKTtcbiAgICB9LFxufTtcblxuLy8gQ2VydGlmaWNhdGUgQVBJXG5leHBvcnQgY29uc3QgY2VydGlmaWNhdGVBcGkgPSB7XG4gICAgLy8gR2V0IHVzZXIncyBjZXJ0aWZpY2F0ZXNcbiAgICBhc3luYyBnZXRDZXJ0aWZpY2F0ZXMoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KCcvY2VydGlmaWNhdGVzJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB2YXJpb3VzIGNlcnRpZmljYXRlIEFQSSB1bmF2YWlsYWJpbGl0eSBzY2VuYXJpb3NcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2VydGlmaWNhdGUgbGlzdCBlcnJvcjonLCBlcnJvci5zdGF0dXMsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAvLyBGb3IgYW55IGNlcnRpZmljYXRlIEFQSSBlcnJvciwganVzdCByZXR1cm4gZW1wdHkgbGlzdFxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBkYXNoYm9hcmQgbG9hZGluZyBpc3N1ZXNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogZXJyb3Iuc3RhdHVzID09PSA0MDMgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0luc3VmZmljaWVudCBwZXJtaXNzaW9ucycpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdGb3JiaWRkZW4nKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgY2VydGlmaWNhdGUgYnkgY291cnNlIElEXG4gICAgYXN5bmMgZ2V0Q2VydGlmaWNhdGVCeUNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2VydGlmaWNhdGVzL2NvdXJzZS8ke2NvdXJzZUlkfWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdmFyaW91cyBjZXJ0aWZpY2F0ZSBBUEkgdW5hdmFpbGFiaWxpdHkgc2NlbmFyaW9zXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NlcnRpZmljYXRlIEFQSSBlcnJvcjonLCBlcnJvci5zdGF0dXMsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIG5vdCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDMgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0luc3VmZmljaWVudCBwZXJtaXNzaW9ucycpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdGb3JiaWRkZW4nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgYWNjZXNzIGRlbmllZCcsXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDAgfHwgZXJyb3Iuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIHNlcnZpY2UgdW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIGFueSBvdGhlciBlcnJvciwgcmV0dXJuIGEgZ2VuZXJpYyB1bmF2YWlsYWJsZSByZXNwb25zZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZW5lcmF0ZSBjZXJ0aWZpY2F0ZSBmb3IgY29tcGxldGVkIGNvdXJzZVxuICAgIGFzeW5jIGdlbmVyYXRlQ2VydGlmaWNhdGUoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NlcnRpZmljYXRlcy9nZW5lcmF0ZS8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB2YXJpb3VzIGNlcnRpZmljYXRlIEFQSSB1bmF2YWlsYWJpbGl0eSBzY2VuYXJpb3NcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2VydGlmaWNhdGUgZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvci5zdGF0dXMsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGdlbmVyYXRpb24gbm90IGF2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlVW5hdmFpbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnSW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0ZvcmJpZGRlbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBnZW5lcmF0aW9uIGFjY2VzcyBkZW5pZWQnLFxuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVVuYXZhaWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID09PSAwIHx8IGVycm9yLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBzZXJ2aWNlIHVuYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBhbnkgb3RoZXIgZXJyb3IsIHJldHVybiBhIGdlbmVyaWMgdW5hdmFpbGFibGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGdlbmVyYXRpb24gdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlcnZpY2VVbmF2YWlsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgY2VydGlmaWNhdGUgYnkgSURcbiAgICBhc3luYyBnZXRDZXJ0aWZpY2F0ZShjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NlcnRpZmljYXRlcy8ke2NlcnRpZmljYXRlSWR9YCk7XG4gICAgfSxcblxuICAgIC8vIERvd25sb2FkIGNlcnRpZmljYXRlXG4gICAgYXN5bmMgZG93bmxvYWRDZXJ0aWZpY2F0ZShjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPihgL2NlcnRpZmljYXRlcy8ke2NlcnRpZmljYXRlSWR9L2Rvd25sb2FkYCk7XG4gICAgfSxcblxuICAgIC8vIEdldCBjZXJ0aWZpY2F0ZSBpbWFnZSB3aXRoIGN1c3RvbSB0ZXh0IG92ZXJsYXlzXG4gICAgYXN5bmMgZ2V0Q2VydGlmaWNhdGVJbWFnZShjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpOiBQcm9taXNlPEJsb2I+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2NlcnRpZmljYXRlcy8ke2NlcnRpZmljYXRlSWR9L2ltYWdlYCwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2dldFRva2VuKCl9YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcGlFcnJvcignRmFpbGVkIHRvIGZldGNoIGNlcnRpZmljYXRlIGltYWdlJywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgfSxcbn07XG5cbi8vIFZpZGVvIEFQSVxuZXhwb3J0IGNvbnN0IHZpZGVvQXBpID0ge1xuICAgIC8vIEdldCB2aWRlbyBkZXRhaWxzIGZyb20gYXBpLnZpZGVvXG4gICAgYXN5bmMgZ2V0VmlkZW9EZXRhaWxzKHZpZGVvSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvdmlkZW9zLyR7dmlkZW9JZH1gKTtcbiAgICB9LFxufTtcblxuLy8gQ2FydCBBUElcbmV4cG9ydCBjb25zdCBjYXJ0QXBpID0ge1xuICAgIC8vIEdldCB1c2VyJ3MgY2FydFxuICAgIGFzeW5jIGdldENhcnQoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy9jYXJ0Jyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBjb3Vyc2UgdG8gY2FydFxuICAgIGFzeW5jIGFkZFRvQ2FydChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC9jYXJ0LyR7Y291cnNlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBjb3Vyc2UgZnJvbSBjYXJ0XG4gICAgYXN5bmMgcmVtb3ZlRnJvbUNhcnQoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2FydC8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIGNvdXJzZSBpcyBpbiBjYXJ0XG4gICAgYXN5bmMgY2hlY2tJbkNhcnQoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvY2FydC9jaGVjay8ke2NvdXJzZUlkfWApO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhciBlbnRpcmUgY2FydFxuICAgIGFzeW5jIGNsZWFyQ2FydCgpOiBQcm9taXNlPEFwaVJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlSZXF1ZXN0PEFwaVJlc3BvbnNlPignL2NhcnQnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuXG4vLyBXaXNobGlzdCBBUElcbmV4cG9ydCBjb25zdCB3aXNobGlzdEFwaSA9IHtcbiAgICAvLyBHZXQgdXNlcidzIHdpc2hsaXN0XG4gICAgYXN5bmMgZ2V0V2lzaGxpc3QoKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oJy93aXNobGlzdCcpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgY291cnNlIHRvIHdpc2hsaXN0XG4gICAgYXN5bmMgYWRkVG9XaXNobGlzdChjb3Vyc2VJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpUmVxdWVzdDxBcGlSZXNwb25zZT4oYC93aXNobGlzdC8ke2NvdXJzZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgY291cnNlIGZyb20gd2lzaGxpc3RcbiAgICBhc3luYyByZW1vdmVGcm9tV2lzaGxpc3QoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvd2lzaGxpc3QvJHtjb3Vyc2VJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiBjb3Vyc2UgaXMgaW4gd2lzaGxpc3RcbiAgICBhc3luYyBjaGVja0luV2lzaGxpc3QoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaVJlcXVlc3Q8QXBpUmVzcG9uc2U+KGAvd2lzaGxpc3QvY2hlY2svJHtjb3Vyc2VJZH1gKTtcbiAgICB9LFxufTtcblxuLy8gRXhwb3J0IGhlbHBlciBmdW5jdGlvbnNcbmV4cG9ydCB7IEFwaUVycm9yLCBnZXRUb2tlbiwgc2V0VG9rZW4sIHJlbW92ZVRva2VuIH07Il0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQXBpRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInN0YXR1cyIsImRhdGEiLCJuYW1lIiwiZ2V0VG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0VG9rZW4iLCJ0b2tlbiIsInNldEl0ZW0iLCJyZW1vdmVUb2tlbiIsInJlbW92ZUl0ZW0iLCJhcGlSZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidXJsIiwiY29uZmlnIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJyZXNwb25zZSIsImZldGNoIiwianNvbiIsImUiLCJvayIsImVycm9yIiwiYXV0aEFwaSIsImxvZ2luIiwicGF5bG9hZCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVnaXN0ZXIiLCJnZXRQcm9maWxlIiwidXBkYXRlUHJvZmlsZSIsInByb2ZpbGVEYXRhIiwidXBkYXRlSW5zdHJ1Y3RvclByb2ZpbGUiLCJpbnN0cnVjdG9yRGF0YSIsImxvZ291dCIsImNpdGllc0FwaSIsImdldEFsbCIsInBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ1bmRlZmluZWQiLCJhcHBlbmQiLCJ0b1N0cmluZyIsImdldEJ5SWQiLCJpZCIsImNyZWF0ZSIsInVwZGF0ZSIsImRlbGV0ZSIsInRoZWF0ZXJzQXBpIiwidGhlYXRlckRhdGEiLCJ1cGRhdGVEYXRhIiwiY291cnNlc0FwaSIsImdldFB1Ymxpc2hlZCIsImdldERhc2hib2FyZFN0YXRzIiwiZ2V0TXlDb3Vyc2VzIiwiY3JlYXRlRHJhZnQiLCJmb3JtRGF0YSIsInVwZGF0ZUJhc2ljSW5mbyIsImNvdXJzZUlkIiwiZ2V0Q291cnNlIiwiYWRkU2VjdGlvbiIsInNlY3Rpb25EYXRhIiwiYWRkTGVjdHVyZSIsInNlY3Rpb25JZCIsImxlY3R1cmVEYXRhIiwidXBkYXRlTGVjdHVyZSIsImxlY3R1cmVJZCIsInRvZ2dsZVB1Ymxpc2giLCJwdWJsaXNoIiwiZGVsZXRlQ291cnNlIiwiZGVsZXRlTGVjdHVyZSIsInRlc3RTU0UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvbnNvbGUiLCJsb2ciLCJzc2VVcmwiLCJldmVudFNvdXJjZSIsIkV2ZW50U291cmNlIiwibWVzc2FnZUNvdW50Iiwib25vcGVuIiwib25tZXNzYWdlIiwiZXZlbnQiLCJwYXJzZSIsImNvbXBsZXRlIiwiY2xvc2UiLCJvbmVycm9yIiwic2V0VGltZW91dCIsIndhcm4iLCJ0ZXN0Q09SUyIsInVwbG9hZFZpZGVvIiwic2VjdGlvbkluZGV4IiwibGVjdHVyZUluZGV4IiwidmlkZW9GaWxlIiwidGh1bWJuYWlsRmlsZSIsIm9uUHJvZ3Jlc3MiLCJGb3JtRGF0YSIsInByb2dyZXNzS2V5IiwicHJvZ3Jlc3NNaWxlc3RvbmVzIiwiY3VycmVudE1pbGVzdG9uZUluZGV4IiwicHJvZ3Jlc3NDaGVja0ludGVydmFsIiwicHJvZ3Jlc3NDb21wbGV0ZWQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJtaWxlc3RvbmUiLCJ1cGxvYWRMZWN0dXJlVmlkZW8iLCJ0aGVuIiwiY2F0ZWdvcmllc0FwaSIsInN0dWRlbnRBcGkiLCJnZXRNeUVucm9sbG1lbnRzIiwiZW5yb2xsSW5Db3Vyc2UiLCJnZXRDb3Vyc2VQcm9ncmVzcyIsIm1hcmtMZXNzb25Db21wbGV0ZSIsInRpbWVTcGVudCIsInVubWFya0xlc3NvbkNvbXBsZXRlIiwiZ2V0RGFzaGJvYXJkT3ZlcnZpZXciLCJnZXRFbnJvbGxtZW50RGV0YWlscyIsImNlcnRpZmljYXRlQXBpIiwiZ2V0Q2VydGlmaWNhdGVzIiwic3VjY2VzcyIsImNlcnRpZmljYXRlcyIsInNlcnZpY2VVbmF2YWlsYWJsZSIsImluY2x1ZGVzIiwiZ2V0Q2VydGlmaWNhdGVCeUNvdXJzZSIsImNlcnRpZmljYXRlIiwiZ2VuZXJhdGVDZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsImRvd25sb2FkQ2VydGlmaWNhdGUiLCJnZXRDZXJ0aWZpY2F0ZUltYWdlIiwiYmxvYiIsInZpZGVvQXBpIiwiZ2V0VmlkZW9EZXRhaWxzIiwidmlkZW9JZCIsImNhcnRBcGkiLCJnZXRDYXJ0IiwiYWRkVG9DYXJ0IiwicmVtb3ZlRnJvbUNhcnQiLCJjaGVja0luQ2FydCIsImNsZWFyQ2FydCIsIndpc2hsaXN0QXBpIiwiZ2V0V2lzaGxpc3QiLCJhZGRUb1dpc2hsaXN0IiwicmVtb3ZlRnJvbVdpc2hsaXN0IiwiY2hlY2tJbldpc2hsaXN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});